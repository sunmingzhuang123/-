<!doctype html>
<html>
<head>
    <style>
        .watermark {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            background-repeat: repeat;
            /* background-image: linear-gradient(45deg, rgba(0, 0, 0, 0.1) 0%, rgba(0, 0, 0, 0.1) 100%); */
        }
        
        .watermark::after {
            content: "菏泽学院 23物联网工程 QQ365938188";
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-45deg);
            font-size: 24px;
            color: rgba(0, 0, 0, 0.1);
            white-space: nowrap;
            letter-spacing: 5px;
        }
        </style>
        
       
        <div class="watermark"></div>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>ARM期末考试 .md</title><link href='https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}#write, body { height: auto; }
#write, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write ol, #write p, #write ul { position: relative; }
#write, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
.CodeMirror, .md-fences, table { text-align: left; }
.md-reset, a:active, a:hover { outline: 0px; }
.md-reset, .md-toc-item a { text-decoration: none; }
.MathJax_SVG, .md-reset { float: none; direction: ltr; }
:root { --bg-color:#ffffff; --text-color:#333333; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; }
.in-text-selection, ::selection { background: rgb(181, 214, 252); text-shadow: none; }
#write { margin: 0px auto; word-break: normal; word-wrap: break-word; padding-bottom: 70px; white-space: pre-wrap; overflow-x: visible; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
.typora-export #write { margin: 0px auto; }
#write > blockquote:first-child, #write > div:first-child, #write > ol:first-child, #write > p:first-child, #write > pre:first-child, #write > table:first-child, #write > ul:first-child { margin-top: 30px; }
#write li > table:first-child { margin-top: -20px; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
p { -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; }
.typora-export p { white-space: normal; }
.mathjax-block { margin-top: 0px; margin-bottom: 0px; -webkit-margin-before: 0px; -webkit-margin-after: 0px; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
#write > figure:first-child { margin-top: 16px; }
figure { overflow-x: auto; margin: -8px 0px 0px -8px; max-width: calc(100% + 16px); padding: 8px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; }
.CodeMirror-line, .md-fences { break-inside: avoid; }
table.md-table td { min-width: 80px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; margin-right: 4px; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
pre { white-space: pre-wrap; }
.md-fences { font-size: 0.9rem; display: block; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
.md-fences .CodeMirror.CodeMirror-wrap { top: -1.6em; margin-bottom: -1.6em; }
.md-fences.mock-cm { white-space: pre-wrap; }
.show-fences-line-number .md-fences { padding-left: 0px; }
.show-fences-line-number .md-fences.mock-cm { padding-left: 40px; }
.footnotes { opacity: 0.8; font-size: 0.9rem; padding-top: 1em; padding-bottom: 1em; }
.footnotes + .footnotes { margin-top: -1em; }
.md-reset { margin: 0px; padding: 0px; border: 0px; vertical-align: top; background: 0px 0px; text-shadow: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; }
.md-toc-inner, a img, img a { cursor: pointer; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: nowrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  h1, h2, h3, h4, h5, h6 { break-after: avoid-page; orphans: 2; }
  p { orphans: 4; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 1cm; padding-right: 1cm; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > img:only-child { display: block; margin: auto; }
.md-line > .md-image:only-child, p > .md-image:only-child { display: inline-block; width: 100%; text-align: center; }
.mathjax-block:not(:empty)::after, .md-toc-content::after, .md-toc::after { display: none; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.mathjax-block { white-space: pre; overflow: hidden; width: 100%; }
p + .mathjax-block { margin-top: -1.143rem; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.MathJax_SVG, .mathjax-block .MathJax_SVG_Display { text-indent: 0px; max-width: none; max-height: none; min-height: 0px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-inner:hover { }
.md-toc-inner { display: inline-block; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
.md-tag { opacity: 0.5; }
code, pre, tt { font-family: var(--monospace); }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; }
h1 .md-tag, h2 .md-tag, h3 .md-tag, h4 .md-tag, h5 .md-tag, h6 .md-tag { font-weight: initial; opacity: 0.35; }
a.md-print-anchor { border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.mathjax-block .MathJax_SVG_Display { text-align: center; margin: 1em 0px; position: relative; min-width: 100%; width: auto; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: monospace; }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; min-width: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.md-diagram-panel > svg, [lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }


.CodeMirror, .CodeMirror-sizer { position: relative; }
.CodeMirror.cm-s-inner { background: inherit; }
.fences-no-line-wrapping .md-fences .CodeMirror { margin-top: -30px; }
.CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; }
.CodeMirror-lines { padding: 4px 0px; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-scroll, .cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta, .cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error, .cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.CodeMirror { height: auto; overflow: hidden; }
.CodeMirror-scroll { margin-bottom: -30px; padding-bottom: 30px; height: 100%; outline: 0px; position: relative; box-sizing: content-box; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow-x: hidden; overflow-y: scroll; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow-y: hidden; overflow-x: scroll; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; border-right: none; width: 0px; visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.CodeMirror-selected { background: rgb(217, 217, 217); }
.CodeMirror-focused .CodeMirror-selected { background: rgb(215, 212, 240); }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}
.CodeMirror-lint-markers { width: 16px; }
.CodeMirror-lint-tooltip { background-color: infobackground; border: 1px solid rgb(0, 0, 0); border-radius: 4px; color: infotext; font-family: var(--monospace); overflow: hidden; padding: 2px 5px; position: fixed; white-space: pre-wrap; z-index: 10000; max-width: 600px; opacity: 0; transition: opacity 0.4s; font-size: 0.8em; }
.CodeMirror-lint-mark-error, .CodeMirror-lint-mark-warning { background-position: left bottom; background-repeat: repeat-x; }
.CodeMirror-lint-mark-error { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg=="); }
.CodeMirror-lint-marker-error, .CodeMirror-lint-marker-warning { background-position: center center; background-repeat: no-repeat; cursor: pointer; display: inline-block; height: 16px; width: 16px; vertical-align: middle; position: relative; }
.CodeMirror-lint-message-error, .CodeMirror-lint-message-warning { padding-left: 18px; background-position: left top; background-repeat: no-repeat; }
.CodeMirror-lint-marker-error, .CodeMirror-lint-message-error { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII="); }
.CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII="); }
.CodeMirror-lint-marker-multiple { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC"); background-repeat: no-repeat; background-position: right bottom; width: 100%; height: 100%; }


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
@font-face { font-family: "Open Sans"; font-style: normal; font-weight: normal; src: local("Open Sans Regular"), url("./github/400.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: italic; font-weight: normal; src: local("Open Sans Italic"), url("./github/400i.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: normal; font-weight: bold; src: local("Open Sans Bold"), url("./github/700.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: italic; font-weight: bold; src: local("Open Sans Bold Italic"), url("./github/700i.woff") format("woff"); }
html { font-size: 16px; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 20px 30px 100px; }
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
body > :first-child { margin-top: 0px !important; }
body > :last-child { margin-bottom: 0px !important; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 4px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border-width: 0px 0px 1px; border-style: none none solid; border-top-color: initial; border-right-color: initial; border-left-color: initial; border-image: initial; overflow: hidden; box-sizing: content-box; border-bottom-color: rgb(221, 221, 221); }
body > h2:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child + h2 { margin-top: 0px; padding-top: 0px; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child { margin-top: 0px; padding-top: 0px; }
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0px; padding-top: 0px; }
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p { margin-top: 0px; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 4px solid rgb(221, 221, 221); padding: 0px 15px; color: rgb(119, 119, 119); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border-top: 1px solid rgb(204, 204, 204); margin: 0px; padding: 0px; }
table tr:nth-child(2n) { background-color: rgb(248, 248, 248); }
table tr th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; text-align: left; margin: 0px; padding: 6px 13px; }
table tr td { border: 1px solid rgb(204, 204, 204); text-align: left; margin: 0px; padding: 6px 13px; }
table tr th:first-child, table tr td:first-child { margin-top: 0px; }
table tr th:last-child, table tr td:last-child { margin-bottom: 0px; }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); }
.md-fences, code, tt { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding: 8px 1em 6px; }
.md-task-list-item > input { margin-left: -1.3em; }
@media screen and (min-width: 914px) {
}
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; color: inherit; }
.md-tag { color: inherit; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
#md-notification::before { top: 10px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }
.html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; }






</style>
</head>
<body class='typora-export' >
<div  id='write'  class = 'is-node'><h1><a name='header-n0' class='md-header-anchor '></a>ARM期末</h1><p>23物联网工程 2023124306</p><h2><a name='header-n4' class='md-header-anchor '></a>第二章</h2><h3><a name='header-n5' class='md-header-anchor '></a>2.1.1 冯·诺依曼结构与哈佛结构</h3><p>冯·诺依曼结构和哈佛结构是两种不同的计算机体系结构，它们在处理数据和指令的方式上存在显著差异。</p><h4><a name='header-n8' class='md-header-anchor '></a>1. <strong>冯·诺依曼结构（Von Neumann Architecture）</strong></h4><p>冯·诺依曼结构是由数学家约翰·冯·诺依曼于1945年提出的计算机体系结构，它是现代计算机的基础。冯·诺依曼结构的特点在于<strong>指令存储和数据存储共用同一存储器和总线</strong>，即程序代码和数据存储在同一内存中，并通过相同的总线进行访问。</p><p><strong>特点</strong>：</p><ul><li><strong>单一内存空间</strong>：程序代码和数据存储在同一个内存区域。</li><li><strong>共享总线</strong>：数据和指令的读取都需要通过同一条总线，导致数据访问的竞争。</li><li><strong>顺序执行</strong>：指令按顺序从内存加载到CPU进行执行。</li></ul><p><strong>优点</strong>：</p><ul><li>设计简单，硬件实现较为容易。</li><li>可编程性强，可以在同一内存中存储程序和数据。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>瓶颈问题</strong>：因为指令和数据共享同一总线，读取指令和数据时可能会发生冲突，造成性能瓶颈。</li><li><strong>效率较低</strong>：需要多次访问内存，导致执行速度受限。</li></ul><h4><a name='header-n41' class='md-header-anchor '></a>2. <strong>哈佛结构（Harvard Architecture）</strong></h4><p>哈佛结构由哈佛大学的研究人员在20世纪40年代提出，通常用于专用的数字信号处理器（DSP）和嵌入式系统中。它的特点是<strong>将程序指令和数据存储分开</strong>，指令和数据分别存储在不同的内存中，并通过不同的总线进行访问。</p><p><strong>特点</strong>：</p><ul><li><strong>独立的指令和数据存储器</strong>：程序代码和数据存储在不同的内存中。</li><li><strong>独立的总线</strong>：指令和数据通过独立的总线进行传输，避免了冯·诺依曼结构中的数据总线竞争问题。</li><li><strong>并行处理</strong>：能够同时访问指令和数据，提高了效率。</li></ul><p><strong>优点</strong>：</p><ul><li><strong>高效并行性</strong>：由于指令和数据可以同时访问，执行效率大大提高。</li><li><strong>减少瓶颈</strong>：没有指令和数据竞争总线的问题，减少了访问延迟。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>硬件复杂</strong>：需要更多的内存和总线，设计和实现较为复杂。</li><li><strong>灵活性较差</strong>：在内存空间分配上不如冯·诺依曼结构灵活，因为指令和数据是分开存储的。</li></ul><h4><a name='header-n74' class='md-header-anchor '></a><strong>冯·诺依曼结构与哈佛结构的比较</strong>：</h4><figure><table><thead><tr><th>特性</th><th>冯·诺依曼结构</th><th>哈佛结构</th></tr></thead><tbody><tr><td><strong>内存</strong></td><td>程序和数据共用同一内存</td><td>程序和数据存储在不同的内存中</td></tr><tr><td><strong>总线</strong></td><td>使用单一总线传输数据和指令</td><td>使用不同的总线传输数据和指令</td></tr><tr><td><strong>访问</strong></td><td>指令和数据访问存在竞争</td><td>可以同时访问指令和数据</td></tr><tr><td><strong>硬件复杂性</strong></td><td>硬件实现简单</td><td>硬件实现较为复杂</td></tr><tr><td><strong>执行效率</strong></td><td>受限于总线瓶颈，效率较低</td><td>由于指令和数据分开存储，效率较高</td></tr><tr><td><strong>应用场景</strong></td><td>适用于一般计算机</td><td>适用于嵌入式系统、数字信号处理等</td></tr></tbody></table></figure><h4><a name='header-n104' class='md-header-anchor '></a><strong>在嵌入式系统中的应用</strong></h4><p>在现代嵌入式系统中，ARM Cortex系列内核通常采用了<strong>哈佛架构的变种</strong>。ARM处理器采用哈佛架构的优点，尤其是指令和数据的分离，使得嵌入式系统在性能、功耗和实时性方面得到了很好的优化。尤其是Cortex-M3等内核，它们通过实现较高效的指令集（如Thumb-2）以及独立的存储和总线，提供了较好的运行效率。</p><hr /><h3><a name='header-n108' class='md-header-anchor '></a>2.1.2 ARM存储模式</h3><p>ARM架构的存储模式主要决定了处理器如何访问内存中的数据。ARM体系结构采用了一种灵活的存储模式，使得内存访问高效且具有较好的性能。具体来说，ARM处理器支持字节（Byte）、半字（Halfword）、字（Word）和双字（Doubleword）的存储模式。</p><h4><a name='header-n111' class='md-header-anchor '></a>ARM存储模式的关键点：</h4><ol start='' ><li><strong>字节（Byte）</strong>：最小存储单位为1字节（8位），ARM处理器可以读取和写入单个字节的数据。</li><li><strong>半字（Halfword）</strong>：存储2字节（16位）的数据。ARM支持以半字为单位对内存进行访问。</li><li><strong>字（Word）</strong>：存储4字节（32位）的数据。大多数ARM处理器支持4字节对齐的存储和访问。</li><li><strong>双字（Doubleword）</strong>：存储8字节（64位）的数据。高端ARM处理器（如Cortex-A系列）可以支持双字存储和访问。</li></ol><h4><a name='header-n125' class='md-header-anchor '></a><strong>字节对齐</strong></h4><p>ARM处理器通常要求内存访问是对齐的，即访问的地址应当是相应存储单位的整数倍。例如，读取一个字时，地址必须是4的倍数。如果发生未对齐的访问，可能会导致性能下降或产生异常。</p><h4><a name='header-n128' class='md-header-anchor '></a><strong>大端模式与小端模式</strong></h4><p>ARM架构支持两种字节序：大端模式（Big Endian）和小端模式（Little Endian）。大端模式是指数据的高位字节存储在低地址处，而小端模式则相反。ARM处理器可以根据需要在这两种字节序中切换。</p><hr /><h3><a name='header-n132' class='md-header-anchor '></a>2.1.3 CISC和RISC</h3><p>CISC（复杂指令集计算机）和RISC（精简指令集计算机）是两种不同的指令集架构，它们在设计理念、指令集复杂性和性能上有很大区别。</p><h4><a name='header-n135' class='md-header-anchor '></a>1. <strong>CISC（复杂指令集计算机）</strong></h4><p>CISC架构的特点是具有<strong>复杂的指令集</strong>，每条指令通常能够执行多个低级操作，如内存读取、加法运算等。因此，CISC架构的指令数目相对较多，且每条指令的功能较为复杂。常见的CISC架构有x86架构。</p><p><strong>特点</strong>：</p><ul><li>每条指令可以执行多个操作，如内存访问和算术运算。</li><li>指令长度不固定，可以是1到多个字节。</li><li>提供复杂的寻址方式。</li><li>需要更复杂的解码器来解析指令。</li></ul><p><strong>优点</strong>：</p><ul><li>较少的指令数目可以实现较为复杂的操作，节省存储空间。</li><li>提高了编程效率，因为通过一条指令就可以执行多个操作。</li></ul><p><strong>缺点</strong>：</p><ul><li>指令集较为复杂，硬件实现难度较大。</li><li>指令的执行时间不一致，导致CPU的效率降低。</li></ul><h4><a name='header-n171' class='md-header-anchor '></a>2. <strong>RISC（精简指令集计算机）</strong></h4><p>RISC架构的特点是具有<strong>简化的指令集</strong>，每条指令执行一个简单的操作，并且每条指令的长度通常是固定的。ARM架构就是典型的RISC架构，强调指令的简洁和执行效率。</p><p><strong>特点</strong>：</p><ul><li>每条指令执行一个简单的操作，通常为数据的加载、存储或算术运算。</li><li>指令长度固定，通常是4字节。</li><li>寻址方式简化，一般使用寄存器间接寻址。</li><li>解码和执行过程较简单，能够实现较高的指令执行速率。</li></ul><p><strong>优点</strong>：</p><ul><li>硬件实现较为简单，设计和制造成本较低。</li><li>由于指令集较小，CPU的执行效率较高。</li><li>每条指令的执行时间相对固定，提高了流水线处理能力。</li></ul><p><strong>缺点</strong>：</p><ul><li>需要更多的指令来完成复杂操作，相对于CISC可能需要更多的程序空间。</li><li>为了完成一个复杂的操作，可能需要多条指令。</li></ul><h4><a name='header-n210' class='md-header-anchor '></a><strong>CISC与RISC的比较</strong>：</h4><figure><table><thead><tr><th>特性</th><th>CISC架构</th><th>RISC架构</th></tr></thead><tbody><tr><td><strong>指令集复杂性</strong></td><td>指令集复杂，支持多种操作</td><td>指令集简单，每条指令执行单一操作</td></tr><tr><td><strong>指令长度</strong></td><td>不固定</td><td>固定</td></tr><tr><td><strong>执行时间</strong></td><td>执行时间不一致</td><td>执行时间固定</td></tr><tr><td><strong>硬件实现</strong></td><td>硬件复杂，解码器较复杂</td><td>硬件相对简单，解码器简单</td></tr><tr><td><strong>程序空间</strong></td><td>通常需要较少的指令</td><td>需要更多的指令完成复杂任务</td></tr><tr><td><strong>应用</strong></td><td>适用于需要复杂操作的任务（如桌面计算机）</td><td>适用于高效、低功耗的嵌入式系统</td></tr></tbody></table></figure><p>ARM处理器采用了RISC架构，它的指令集小而高效，能够在较低的功耗下实现较高的性能，非常适合嵌入式系统和移动设备。</p><hr /><h3><a name='header-n243' class='md-header-anchor '></a>2.1.4 流水线技术</h3><p>流水线技术是一种通过将指令的执行过程划分为多个阶段，并且让不同的指令在不同阶段并行处理，从而提高计算机系统执行效率的技术。</p><h4><a name='header-n246' class='md-header-anchor '></a>流水线的基本概念：</h4><p>流水线技术将指令的执行过程划分为若干个独立的阶段（通常包括取指、解码、执行、访存和写回阶段），每个阶段完成特定的操作。处理器可以在同一时刻并行执行多条指令的不同阶段，从而提高整体指令吞吐量。</p><h4><a name='header-n249' class='md-header-anchor '></a><strong>流水线的工作原理</strong>：</h4><p>在没有流水线的情况下，CPU执行每条指令时会依次完成所有操作。采用流水线技术后，CPU会在同一时刻同时处理多条指令的不同阶段。例如，当指令1正在取指阶段时，指令2可以在解码阶段，指令3可以在执行阶段，这样就能够并行处理多条指令。</p><h4><a name='header-n252' class='md-header-anchor '></a><strong>流水线的优点</strong>：</h4><ul><li><strong>提高吞吐量</strong>：由于多个指令并行执行，指令的执行速度得到了显著提高。</li><li><strong>提高效率</strong>：每个时钟周期都能完成一条指令的执行，减少了空闲时间。</li></ul><h4><a name='header-n260' class='md-header-anchor '></a><strong>流水线的挑战</strong>：</h4><ul><li><strong>流水线停顿（Pipeline Stall）</strong>：如果某条指令依赖于前一条指令的结果（如数据依赖），就会导致流水线停顿，影响性能。</li><li><strong>分支预测</strong>：当遇到条件分支指令时，处理器需要预测分支的结果，否则会造成流水线的清空（称为“流水线冲刷”），也会影响性能。</li></ul><h4><a name='header-n268' class='md-header-anchor '></a><strong>ARM Cortex-M3内核的流水线技术</strong>：</h4><p>ARM Cortex-M3处理器采用了三级流水线技术，通常包括<strong>取指阶段（IF）、解码阶段（ID）和执行阶段（EX）</strong>。通过流水线技术，Cortex-M3能够在每个时钟周期内执行一条指令，极大提高了指令的处理效率。</p><hr /><h3><a name='header-n272' class='md-header-anchor '></a>2.2 ARM</h3><h4><a name='header-n273' class='md-header-anchor '></a>2.2.1 ARM介绍</h4><p>ARM（Advanced RISC Machines）是一种基于精简指令集（RISC）架构的处理器架构，最初由Acorn Computers公司于1980年代开发，并逐渐成为全球范围内广泛使用的微处理器架构之一。ARM架构以其高效、低功耗和良好的性能广泛应用于各种嵌入式系统、移动设备（如智能手机、平板电脑）、物联网设备以及一些高性能计算平台。</p><p>ARM处理器以其简洁的指令集和低功耗特性，满足了现代移动设备对计算性能和电池续航时间的高要求。ARM架构不直接制造芯片，而是授权其他公司（如高通、苹果、三星等）使用其架构来设计和生产具体的芯片产品。</p><h4><a name='header-n278' class='md-header-anchor '></a>2.2.2 ARM体系结构</h4><p>ARM体系结构采用RISC（精简指令集计算）原理，意味着它使用的是数量相对较少且效率高的指令集。这种设计有助于提高处理器的执行速度和节省功耗，适合低功耗和高性能的需求。ARM架构的核心特点包括：</p><ol start='' ><li><strong>精简指令集（RISC）</strong>：ARM使用的指令集相较于CISC（复杂指令集计算）架构更加简单，指令集较少，但每条指令的执行效率较高，通常在一个时钟周期内完成。</li><li><strong>多核架构</strong>：ARM处理器通常采用多核设计，支持并行处理能力，提升多任务和多线程的处理性能。现代ARM处理器普遍采用大核与小核结合的设计，以实现性能与功耗的平衡。</li><li><strong>低功耗设计</strong>：ARM架构以其低功耗特性闻名，适合移动设备使用。ARM设计在节能方面采用了多种技术，如动态电压频率调整（DVFS）、动态功耗管理等。</li><li><strong>32位与64位架构</strong>：ARM架构支持32位与64位两种模式。32位模式较早出现，广泛应用于嵌入式设备中；64位模式则在更高性能的设备中得到了应用，如高端智能手机、服务器等。</li><li><strong>高效的内存管理单元（MMU）</strong>：ARM架构具有高效的内存管理能力，支持虚拟内存管理和地址转换，能在不同的运行环境下实现高效的内存访问。</li><li><strong>丰富的指令集扩展</strong>：ARM架构支持多个扩展，包括NEON SIMD（单指令多数据）扩展用于多媒体处理，TrustZone用于安全性管理等。</li><li><strong>广泛的应用场景</strong>：ARM处理器被广泛应用于从低功耗嵌入式设备到高性能服务器的各类领域。特别是在移动设备、物联网（IoT）、汽车电子、消费电子等领域有着显著的应用。</li></ol><p>ARM架构的主要优势在于高效能与低功耗的结合，以及其灵活性，能够根据不同需求定制不同级别的处理器。ARM处理器的授权模式使得全球各地的芯片设计公司可以根据自己的需求进行定制，从而推动了ARM架构的广泛应用。</p><h3><a name='header-n305' class='md-header-anchor '></a>2.3 ARM Cortex-M3内核</h3><p>ARM Cortex-M3内核是基于ARM的RISC架构设计的一款高效能、低功耗的微控制器内核，广泛应用于嵌入式系统、物联网设备以及实时控制应用。Cortex-M3内核主要特点是支持高度集成的功能、灵活的内存管理以及高效的中断处理。</p><h4><a name='header-n308' class='md-header-anchor '></a>2.3.1 内核架构</h4><p>Cortex-M3内核采用的是<strong>哈佛架构</strong>的变种，指令和数据存储是分开的，采用独立的总线以提高内存访问效率。其内核架构的关键特性包括：</p><ol start='' ><li><p><strong>处理器模式</strong>：Cortex-M3处理器支持两种主要的执行模式：<strong>Thread模式</strong>和<strong>Handler模式</strong>。</p><ul><li><strong>Thread模式</strong>：这是处理器的正常运行模式，用于执行应用程序代码。</li><li><strong>Handler模式</strong>：当发生中断或异常时，处理器切换到此模式执行中断处理程序。</li></ul></li><li><p><strong>操作模式</strong>：Cortex-M3支持两种主要的工作状态：<strong>Privileged模式</strong>（特权模式）和<strong>Unprivileged模式</strong>（非特权模式）。</p><ul><li><strong>特权模式</strong>：通常由操作系统或核心程序使用，具有更高的访问权限。</li><li><strong>非特权模式</strong>：通常由应用程序使用，权限较低。</li></ul></li><li><p><strong>指令集</strong>：Cortex-M3采用<strong>ARMv7-M架构</strong>，支持<strong>Thumb-2指令集</strong>。该指令集结合了16位和32位指令，旨在提供较低的代码大小和较高的执行效率。</p></li><li><p><strong>多级流水线</strong>：Cortex-M3使用三级流水线（取指、解码、执行），提高了指令执行的效率和吞吐量。</p></li><li><p><strong>内存保护单元（MPU）</strong>：Cortex-M3内核内置了<strong>内存保护单元（MPU）</strong>，允许系统定义不同的内存区域及其访问权限，保护重要的数据和代码免受非法访问。</p></li><li><p><strong>系统控制单元（SCU）</strong>：该单元处理系统相关的控制操作，如系统复位、时钟控制、硬件中断管理等。</p></li><li><p><strong>调试支持</strong>：Cortex-M3内核支持多个调试接口，如JTAG、SWD（Serial Wire Debug）和CoreSight。它提供了执行跟踪、数据捕获和性能分析的功能，方便开发人员调试嵌入式应用。</p></li></ol><h4><a name='header-n347' class='md-header-anchor '></a>2.3.2 寄存器</h4><p>Cortex-M3内核中有多个不同类型的寄存器，用于存储执行过程中的数据、状态信息以及控制指令的执行。主要寄存器如下：</p><ol start='' ><li><p><strong>通用寄存器</strong>：Cortex-M3提供了16个通用寄存器（R0到R15），用于存储处理过程中使用的数据。主要的寄存器包括：</p><ul><li><strong>R0-R12</strong>：用于存储通用数据，供程序使用。</li><li><strong>R13（SP）</strong>：堆栈指针寄存器，指向栈顶，栈是用于存储局部变量、函数返回地址等数据的内存区域。</li><li><strong>R14（LR）</strong>：链接寄存器，存储函数调用的返回地址。</li><li><strong>R15（PC）</strong>：程序计数器，存储下一条将要执行的指令地址。</li></ul></li><li><p><strong>程序状态寄存器（xPSR）</strong>：xPSR（Program Status Register）包含处理器状态信息，包括当前的程序执行状态、条件标志和异常信息。</p><ul><li><strong>CPSR（Current Program Status Register）</strong>：存储当前的处理器状态，如中断使能标志、当前处理模式等。</li><li><strong>IPSR（Interrupt Program Status Register）</strong>：存储当前处理中断的ID。</li><li><strong>EPSR（Exception Program Status Register）</strong>：在处理中断时使用，记录当前的异常状态。</li></ul></li><li><p><strong>控制寄存器（CONTROL）</strong>：CONTROL寄存器控制处理器的运行模式，决定当前执行的特权级别和堆栈指针的选择。</p></li><li><p><strong>中断控制寄存器（NVIC寄存器）</strong>：Cortex-M3内核包含一组中断控制寄存器，用于管理和控制中断的优先级、使能和状态。</p></li></ol><h4><a name='header-n386' class='md-header-anchor '></a>2.3.3 存储结构</h4><p>Cortex-M3的存储结构包括程序存储器（代码存储）、数据存储器和系统存储器。主要组成部分如下：</p><ol start='' ><li><p><strong>程序存储器（Code Memory）</strong>：通常是<strong>闪存（Flash）</strong>或其他非易失性存储介质，用于存储程序代码。程序存储器通常是只读的，除非特定操作。</p></li><li><p><strong>数据存储器（Data Memory）</strong>：数据存储器一般使用<strong>静态随机存储器（SRAM）</strong>，用于存储程序执行时使用的数据（如全局变量、局部变量、堆栈等）。</p></li><li><p><strong>外设存储器映射（Memory-Mapped I/O）</strong>：Cortex-M3通过<strong>内存映射I/O</strong>（MMIO）机制与外设交互，所有外设寄存器（如GPIO、定时器、ADC等）都被映射到一个特定的内存地址区间，通过读取或写入这些地址可以与外设进行通信。</p></li><li><p><strong>堆栈和堆（Stack and Heap）</strong>：Cortex-M3通过堆栈（stack）和堆（heap）管理内存：</p><ul><li><strong>堆栈</strong>：用于存储局部变量、函数参数和返回地址等临时数据。</li><li><strong>堆</strong>：用于动态分配内存，通常在程序运行时由操作系统或程序员管理。</li></ul></li><li><p><strong>内存保护单元（MPU）</strong>：内存保护单元（MPU）是Cortex-M3的一个可选组件，用于设置内存区域的访问权限，确保程序的内存安全。</p></li></ol><h4><a name='header-n412' class='md-header-anchor '></a>2.3.4 中断与异常（NVIC）</h4><p>Cortex-M3内核提供了一个高效的中断控制系统，称为<strong>嵌套向量中断控制器（NVIC）</strong>，用于处理和管理硬件中断和异常。NVIC是Cortex-M3内核的一部分，支持快速响应和灵活的中断处理。</p><ol start='' ><li><p><strong>NVIC功能</strong>：</p><ul><li><strong>中断优先级管理</strong>：NVIC允许配置中断的优先级，支持多达256个中断源。每个中断源可以设置一个优先级，优先级越高的中断会被优先响应。</li><li><strong>中断使能和禁用</strong>：可以通过NVIC使能或禁用特定的中断源。</li><li><strong>中断嵌套</strong>：支持中断嵌套，允许较高优先级的中断打断低优先级的中断服务程序。</li><li><strong>中断清除和确认</strong>：处理完中断后，NVIC会自动清除或确认该中断源的状态。</li></ul></li><li><p><strong>中断处理流程</strong>：</p><ul><li>当中断请求发生时，处理器检查当前执行的指令，如果没有其他更高优先级的中断，则将处理器状态保存到堆栈中，并跳转到中断处理程序。</li><li>中断处理程序执行完毕后，使用<strong>中断返回指令（IRET）</strong>恢复先前的程序状态，返回到中断发生前的代码执行位置。</li></ul></li><li><p><strong>中断分组</strong>：NVIC允许根据不同的优先级设置中断的分组，支持较细粒度的优先级控制。例如，可以在不同的组之间设置优先级，确保重要的任务不会被低优先级的中断打断。</p></li></ol><hr /><h3><a name='header-n446' class='md-header-anchor '></a>2.4 STM32微控制器结构</h3><p>STM32微控制器采用高效的ARM Cortex-M系列内核，具有丰富的外设和灵活的系统架构。除了核心的处理器内核，STM32还包括多个子系统，确保其在多种应用场景中都能高效地运行。以下是STM32系统的详细结构内容。</p><h4><a name='header-n449' class='md-header-anchor '></a>2.4.1 STM32系统结构</h4><p>STM32系统结构的核心包括处理器内核、内存、外设和其他重要模块。STM32的设计使其在提供高性能的同时也能够满足低功耗和灵活的应用需求。其主要组成部分如下：</p><ol start='' ><li><p><strong>处理器内核</strong>：</p><ul><li>STM32微控制器基于<strong>ARM Cortex-M系列内核</strong>（如Cortex-M0/M3/M4/M7等）。不同的内核有不同的性能特点，Cortex-M0适用于低功耗应用，而Cortex-M4/M7则适合需要更强计算能力和数字信号处理的应用。</li><li><strong>指令集架构</strong>：ARM Cortex-M系列使用精简指令集（RISC），支持Thumb-2指令集，能提供较低的代码大小和较高的执行效率。</li></ul></li><li><p><strong>内存管理</strong>：</p><ul><li><strong>Flash存储器</strong>：用于存储程序代码，通常为非易失性存储，容量范围从几十KB到几MB不等。</li><li><strong>SRAM</strong>：静态随机存储器，用于存储运行时数据，如堆栈和全局变量。</li><li><strong>外部存储器</strong>：某些STM32型号支持外部Flash、SRAM或其他外设存储器。</li></ul></li><li><p><strong>外设接口</strong>：STM32提供丰富的外设接口，包括GPIO、USART、I2C、SPI、CAN、USB等，满足各种传感器、通信设备和其他外设的连接需求。</p></li><li><p><strong>中断管理</strong>：STM32微控制器内置<strong>NVIC</strong>（嵌套向量中断控制器），支持高效的中断和异常管理。</p></li><li><p><strong>低功耗管理</strong>：STM32支持多种低功耗模式（如睡眠模式、待机模式等），适合电池供电的应用。</p></li></ol><h4><a name='header-n485' class='md-header-anchor '></a>2.4.2 STM32总线结构</h4><p>STM32微控制器采用了高效的总线结构，确保各个模块之间能够快速、高效地通信。STM32的总线结构主要包括：</p><ol start='' ><li><p><strong>系统总线（AHB）</strong>：</p><ul><li><strong>AHB总线（Advanced High-performance Bus）</strong>是STM32的主总线，连接处理器内核、内存和高带宽的外设（如DMA控制器、外部存储器接口等）。</li><li>AHB总线提供高速数据传输，支持高带宽需求的模块。</li></ul></li><li><p><strong>外设总线（APB）</strong>：</p><ul><li><strong>APB总线（Advanced Peripheral Bus）</strong>用于连接低带宽外设，如定时器、GPIO、UART、I2C等。APB总线的工作频率通常较低，适用于对带宽要求不高的外设。</li><li>STM32支持APB1和APB2两种总线，APB2通常用于更高速的外设，如SPI和USART，而APB1则连接较慢的外设，如低速定时器。</li></ul></li><li><p><strong>外部总线接口（FSMC）</strong>：</p><ul><li>在某些STM32型号中，提供外部存储器控制器（FSMC，Flexible Static Memory Controller）来连接外部Flash、SRAM等外部存储器。FSMC具有灵活的配置选项，适用于扩展存储需求的应用。</li></ul></li><li><p><strong>系统互连</strong>：</p><ul><li>STM32的各个模块通过高效的互连方式进行通信，保证内存、外设和DMA之间的高效数据流。</li></ul></li></ol><h4><a name='header-n523' class='md-header-anchor '></a>2.4.3 STM32存储结构</h4><p>STM32微控制器的存储结构设计考虑了处理器、外设和低功耗模式的需求，提供了灵活而高效的内存管理。STM32的存储结构包括以下几个部分：</p><ol start='' ><li><p><strong>闪存（Flash）</strong>：</p><ul><li>用于存储程序代码和部分常量数据，闪存是非易失性的，可以在断电后保留数据。</li><li>STM32的闪存容量从几十KB到几MB不等，某些型号支持外部闪存接口。</li></ul></li><li><p><strong>SRAM</strong>：</p><ul><li>静态随机存储器（SRAM）用于存储运行时数据，如局部变量、堆栈、堆内存等。SRAM是易失性的，在断电后数据丢失。</li><li>STM32提供的SRAM容量根据型号不同，通常为几十KB到几百KB。</li></ul></li><li><p><strong>外部存储器</strong>：</p><ul><li>在需要大容量存储的应用中，STM32可以通过外部存储器接口（如FSMC）连接外部存储器（如外部SRAM、Flash等），扩展存储容量。</li></ul></li><li><p><strong>中断向量表</strong>：</p><ul><li>STM32内核使用中断向量表来存储中断服务程序的地址。该表位于闪存中，并通过特殊的指令机制进行访问。</li></ul></li><li><p><strong>内存保护单元（MPU）</strong>：</p><ul><li>部分STM32微控制器支持内存保护单元（MPU），可以在运行时对内存进行保护，防止非法访问或数据损坏。MPU能够划分不同的内存区域并设置访问权限。</li></ul></li></ol><h4><a name='header-n568' class='md-header-anchor '></a>2.4.4 STM32中断</h4><p>STM32微控制器采用嵌套向量中断控制器（NVIC）来管理系统的中断和异常。NVIC提供了快速的中断响应、优先级控制和中断嵌套能力。其主要特性如下：</p><ol start='' ><li><p><strong>中断源</strong>：</p><ul><li>STM32支持多达256个中断源，包括外部中断、内部外设中断和系统异常等。每个中断源都有一个唯一的标识符。</li></ul></li><li><p><strong>中断优先级</strong>：</p><ul><li>NVIC允许为每个中断源设置优先级，并且支持中断优先级嵌套。中断优先级越高的中断会优先响应，低优先级的中断可以被高优先级的中断打断。</li></ul></li><li><p><strong>中断使能和禁用</strong>：</p><ul><li>可以通过NVIC使能或禁用特定的中断源。禁用中断后，相关中断请求不会触发中断服务程序。</li></ul></li><li><p><strong>中断触发方式</strong>：</p><ul><li>STM32支持不同的中断触发方式，包括边沿触发（例如，GPIO引脚状态变化）和电平触发（例如，外部中断信号保持某一电平）。</li></ul></li><li><p><strong>中断嵌套</strong>：</p><ul><li>STM32支持中断嵌套，允许高优先级的中断中断低优先级的中断服务程序。通过设置中断优先级，可以灵活管理中断处理顺序。</li></ul></li><li><p><strong>异常管理</strong>：</p><ul><li>除了外部中断，STM32还能够管理硬件异常（如硬件故障）、系统异常（如内存访问错误）和软件中断。</li></ul></li></ol><h4><a name='header-n614' class='md-header-anchor '></a>2.4.5 STM32时钟系统</h4><p>STM32微控制器的时钟系统是整个芯片运行的核心，负责为处理器和外设提供时钟信号。时钟系统的结构包括多个时钟源和时钟分配模块，能够为不同模块提供适当的时钟频率。主要组成部分如下：</p><ol start='' ><li><p><strong>时钟源</strong>：</p><ul><li><strong>内部高速时钟（HSI）</strong>：用于提供处理器和系统模块的时钟源，频率通常为8MHz。</li><li><strong>外部高速时钟（HSE）</strong>：通过外部晶振提供高精度的时钟源，频率通常为8MHz或更高。</li><li><strong>内部低速时钟（LSI）</strong>：用于低功耗模式下的时钟源，频率通常为32kHz。</li><li><strong>外部低速时钟（LSE）</strong>：通过外部晶振提供低精度时钟源，通常用于实时时钟（RTC）功能。</li></ul></li><li><p><strong>时钟分配</strong>：</p><ul><li>STM32通过时钟树（Clock Tree）管理不同模块的时钟分配，确保系统、外设和低功耗模块能够获得适当的时钟信号。</li><li>支持通过<strong>PLL（Phase-Locked Loop）</strong>对时钟进行倍频，以提高处理器和外设的时钟频率。</li></ul></li><li><p><strong>低功耗模式</strong>：</p><ul><li>STM32支持多种低功耗模式，可以关闭某些时钟源以减少功耗。例如，进入<strong>待机模式</strong>时，CPU和部分外设会停止时钟信号，减少功耗。</li></ul></li><li><p><strong>时钟切换</strong>：</p><ul><li>STM32可以动态切换时钟源（例如从HSI切换到HSE），以适应不同应用场景的需求。通过软件控制时钟源的切换，可以在性能和功耗之间做平衡。</li></ul></li></ol><hr /><h3><a name='header-n659' class='md-header-anchor '></a>总结</h3><p>STM32微控制器的系统架构设计具有高度的灵活性和扩展性，能够满足从简单控制到复杂实时处理的各种应用需求。其丰富的外设支持、高效的总线架构、灵活的存储结构、强大的中断处理和精准的时钟系统使其成为嵌入式系统领域的广泛选择。</p><h2><a name='header-n662' class='md-header-anchor '></a>第5章 通用输入/输出 (GPIO)</h2><h3><a name='header-n663' class='md-header-anchor '></a>5.1 GPIO概述</h3><p>GPIO（General Purpose Input/Output，通用输入/输出）是微控制器中的一种基础外设，广泛应用于嵌入式系统中，用于实现与外部设备的通信和控制。STM32微控制器提供了灵活且功能强大的GPIO接口，可以配置为输入、输出、复用模式，并且支持中断、PWM输出等功能，适用于各种控制和信号处理任务。</p><p>GPIO端口是微控制器与外部世界互动的桥梁，常常用于读取开关状态、控制LED、与外部传感器通信、驱动电机等操作。根据功能需求，GPIO的工作模式可以灵活配置，以满足不同的应用场景。</p><h3><a name='header-n668' class='md-header-anchor '></a>5.2 STM32的GPIO</h3><p>STM32微控制器提供了灵活的GPIO（通用输入/输出）功能，可用于连接各种外部设备，实现输入、输出、复用功能以及中断管理等多种操作。STM32的GPIO引脚可通过多种方式进行配置，支持多种电气特性和功能模式，广泛应用于控制LED、按钮、传感器等设备的接口。</p><h4><a name='header-n671' class='md-header-anchor '></a>5.2.1 GPIO引脚</h4><p>STM32微控制器的GPIO引脚设计得非常灵活，每个引脚都可以配置成不同的功能模式，包括输入、输出、复用和模拟模式。每个GPIO端口（如GPIOA、GPIOB、GPIOC等）通常包含16个引脚，这些引脚通过配置寄存器来控制其功能和工作模式。</p><h5><a name='header-n674' class='md-header-anchor '></a>1. <strong>GPIO引脚的基本分类</strong></h5><p>STM32的GPIO引脚根据功能的不同可以分为以下几类：</p><ul><li><strong>普通I/O引脚</strong>：用于数字信号的输入或输出。</li><li><strong>复用I/O引脚</strong>：这些引脚可以被配置为连接到STM32的外设（如USART、SPI、I2C等），用于进行通信等高级功能。</li><li><strong>模拟I/O引脚</strong>：这些引脚用于连接模拟信号，如用于ADC（模拟到数字转换）或DAC（数字到模拟转换）。</li><li><strong>中断输入引脚</strong>：某些GPIO引脚可以配置为外部中断源，用于响应外部事件</li></ul><h3><a name='header-n690' class='md-header-anchor '></a>5.2.2 GPIO内部结构</h3><p>STM32的GPIO内部结构包括多个组成部分，用于控制和管理引脚的功能、工作模式和电气特性。每个GPIO端口由多个引脚组成，通常是16个引脚（从0到15），每个引脚都有独立的配置和控制寄存器。GPIO的内部结构包括以下几个重要部分：</p><h4><a name='header-n693' class='md-header-anchor '></a>1. <strong>GPIO引脚配置寄存器（CRL/CRH）</strong></h4><p>每个GPIO端口（如GPIOA、GPIOB等）都包含两个配置寄存器：<code>CRL</code>和<code>CRH</code>，分别控制低位（0<del>7）和高位（8</del>15）引脚的工作模式。每个引脚有4个比特位用于配置：</p><ul><li><strong>模式选择</strong>（2位）：选择输入、输出、复用或模拟模式。</li><li><strong>输出类型</strong>（1位）：选择推挽输出或开漏输出。</li><li><strong>输出速度</strong>（2位）：设置输出引脚的速度等级。</li><li><strong>上拉/下拉电阻</strong>（2位）：选择是否启用上拉或下拉电阻。</li></ul><p>通过这些寄存器，可以配置每个引脚的工作模式、输出类型和速度。</p><h4><a name='header-n711' class='md-header-anchor '></a>2. <strong>GPIO输入数据寄存器（IDR）</strong></h4><p><code>IDR</code>寄存器用于读取GPIO引脚的输入状态。当GPIO配置为输入模式时，可以通过该寄存器读取每个引脚的电平（高或低）。读取操作通常是对一个单独引脚的电平进行查询。</p><h4><a name='header-n714' class='md-header-anchor '></a>3. <strong>GPIO输出数据寄存器（ODR）</strong></h4><p><code>ODR</code>寄存器用于控制GPIO引脚的输出状态。当GPIO配置为输出模式时，可以通过该寄存器设置每个引脚的输出电平。该寄存器的每一位对应一个GPIO引脚，1表示高电平，0表示低电平。</p><h4><a name='header-n717' class='md-header-anchor '></a>4. <strong>GPIO设置位寄存器（BSRR）</strong></h4><p><code>BSRR</code>寄存器用于快速设置GPIO引脚的电平。与<code>ODR</code>不同，<code>BSRR</code>寄存器可以单独设置引脚为高电平或低电平，提供更高效的操作。通过设置不同的位（设置位和复位位），可以实现单独的高电平或低电平输出。</p><h4><a name='header-n720' class='md-header-anchor '></a>5. <strong>GPIO重置寄存器（BRR）</strong></h4><p><code>BRR</code>寄存器用于设置GPIO引脚为低电平。它是<code>BSRR</code>寄存器的一部分，用于控制引脚的低电平输出。</p><h4><a name='header-n723' class='md-header-anchor '></a>6. <strong>GPIO锁定寄存器（LCKR）</strong></h4><p><code>LCKR</code>寄存器用于锁定GPIO的配置，防止在配置过程中被更改。当需要确保GPIO配置不会被意外修改时，可以使用锁定寄存器来防止更改。</p><h4><a name='header-n726' class='md-header-anchor '></a>7. <strong>GPIO中断寄存器（EXTI）</strong></h4><p>STM32允许通过GPIO引脚触发外部中断，<code>EXTI</code>寄存器用于管理这些中断。每个GPIO引脚可以配置为外部中断源，并根据外部信号的变化触发中断。中断触发方式（上升沿、下降沿或双边沿）可以通过配置寄存器来选择。</p><hr /><h3><a name='header-n730' class='md-header-anchor '></a>5.2.3 GPIO工作模式</h3><p>STM32的GPIO引脚可以配置为多种工作模式，以下是主要的工作模式及其用途：</p><h4><a name='header-n733' class='md-header-anchor '></a>1. <strong>输入模式</strong></h4><p>输入模式用于读取外部信号。GPIO引脚在输入模式下可以有三种不同的配置：</p><ul><li><strong>浮空输入（Floating Input）</strong>：输入引脚不接任何电平（高电平或低电平），即该引脚不进行上拉或下拉，保持高阻抗状态。通常用于与外部设备连接时，不需要电平固定的情况。</li><li><strong>上拉输入（Pull-up Input）</strong>：输入引脚通过内部上拉电阻连接到Vdd电源，默认情况下将引脚拉高。适用于需要始终保持引脚高电平，除非外部电路将其拉低的情况。</li><li><strong>下拉输入（Pull-down Input）</strong>：输入引脚通过内部下拉电阻连接到GND，默认情况下将引脚拉低。适用于需要始终保持引脚低电平，除非外部电路将其拉高的情况。</li></ul><h4><a name='header-n746' class='md-header-anchor '></a>2. <strong>输出模式</strong></h4><p>输出模式用于将GPIO引脚配置为输出信号，控制外部设备（如LED、继电器、电机等）。输出模式有两种主要配置：</p><ul><li><strong>推挽输出（Push-pull）</strong>：引脚在输出逻辑高时驱动Vdd电压（高电平），在输出逻辑低时驱动GND电压（低电平）。这种模式适用于普通的数字信号输出。</li><li><strong>开漏输出（Open-drain）</strong>：引脚仅在输出逻辑低时驱动GND电压，而在输出逻辑高时处于高阻抗状态。适用于多个设备共用同一信号线的场景（例如I2C总线），引脚通过外部拉高电阻来维持高电平。</li></ul><h4><a name='header-n756' class='md-header-anchor '></a>3. <strong>复用模式</strong></h4><p>复用模式允许GPIO引脚连接到STM32的内部外设接口，如USART、SPI、I2C等。配置复用模式时，需要选择适当的外设功能来连接引脚。复用功能通过AF（Alternate Function）寄存器进行配置，允许每个引脚支持多个外设功能。</p><h4><a name='header-n759' class='md-header-anchor '></a>4. <strong>模拟模式</strong></h4><p>某些GPIO引脚支持模拟模式，允许读取模拟信号（如传感器输出），并通过内置的ADC（模拟到数字转换器）将其转换为数字信号。在模拟模式下，GPIO引脚不进行数字输入输出操作，而是直接与模拟电路交互。</p><hr /><h3><a name='header-n763' class='md-header-anchor '></a>5.2.4 GPIO输出速度</h3><p>STM32的GPIO引脚在配置为输出模式时，允许设置输出引脚的速度等级。输出速度等级控制GPIO引脚在输出高电平时的切换速率，影响信号的上升沿和下降沿的速度。速度设置有三个等级：</p><h4><a name='header-n766' class='md-header-anchor '></a>1. <strong>低速（Low Speed）</strong></h4><p>低速模式下，引脚的切换速率较慢，适用于低频或低速的输出信号。这种设置通常会减小功耗，并且用于驱动小电流负载。</p><h4><a name='header-n769' class='md-header-anchor '></a>2. <strong>中速（Medium Speed）</strong></h4><p>中速模式下，引脚的切换速率比低速模式快，适用于需要较快响应但又不需要极高速率的应用。适合一般的数字信号输出。</p><h4><a name='header-n772' class='md-header-anchor '></a>3. <strong>高速（High Speed）</strong></h4><p>高速模式下，引脚的切换速率最快，适用于需要快速切换信号的场景。该模式通常用于高速信号传输和需要较大驱动能力的应用，如驱动LED、PWM信号输出等。</p><p>选择合适的输出速度可以根据应用的需求平衡响应速度和功耗，同时还要考虑到所驱动负载的特性。</p><hr /><h3><a name='header-n778' class='md-header-anchor '></a>总结</h3><p>STM32的GPIO引脚具有非常灵活的配置选项，通过合理的配置寄存器，可以选择输入、输出、复用或模拟模式，控制每个引脚的工作行为。GPIO的输出速度、输入模式、复用功能等都可以根据应用需求进行调整。理解GPIO的内部结构和工作模式对开发高效稳定的嵌入式系统至关重要。</p><h3><a name='header-n781' class='md-header-anchor '></a>5.3 GPIO标准外设库接口函数及应用</h3><h4><a name='header-n782' class='md-header-anchor '></a>5.3.1 GPIO标准外设库接口函数</h4><p>STM32的标准外设库为GPIO提供了一系列接口函数，用于配置、操作和管理GPIO引脚。通过这些函数，用户可以方便地控制GPIO的输入输出、配置工作模式、设置中断等。标准外设库函数大大简化了直接操作寄存器的复杂度，并提供了高层次的抽象，使得开发更加便捷。</p><p><strong>常见的GPIO标准外设库接口函数：</strong></p><ol start='' ><li><p><strong>GPIO初始化函数：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><p><strong>功能：</strong> 配置GPIO引脚的模式、输出类型、速度、上拉/下拉电阻等。</p><p><strong>参数：</strong></p><ul><li><code>GPIOx</code>: 要配置的GPIO端口，例如GPIOA、GPIOB等。</li><li><code>GPIO_InitStruct</code>: 配置参数结构体，包含了引脚的配置参数（例如工作模式、输出类型、输出速度等）。</li></ul></li><li><p><strong>GPIO设置输出电平函数：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><p><strong>功能：</strong> 设置指定引脚为高电平。</p><p><strong>参数：</strong></p><ul><li><code>GPIOx</code>: 要设置的GPIO端口。</li><li><code>GPIO_Pin</code>: 要设置的引脚编号（如GPIO_Pin_0、GPIO_Pin_1等）。</li></ul><p><strong>示例：</strong> 设置GPIOA的第5引脚为高电平：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIO_SetBits(GPIOA, GPIO_Pin_5);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li><li><p><strong>GPIO清除输出电平函数：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><p><strong>功能：</strong> 设置指定引脚为低电平。</p><p><strong>参数：</strong></p><ul><li><code>GPIOx</code>: 要设置的GPIO端口。</li><li><code>GPIO_Pin</code>: 要设置的引脚编号。</li></ul><p><strong>示例：</strong> 设置GPIOA的第5引脚为低电平：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIO_ResetBits(GPIOA, GPIO_Pin_5);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li><li><p><strong>GPIO读取输入电平函数：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">BitAction GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><p><strong>功能：</strong> 读取指定引脚的输入电平。</p><p><strong>参数：</strong></p><ul><li><code>GPIOx</code>: 要读取的GPIO端口。</li><li><code>GPIO_Pin</code>: 要读取的引脚编号。</li></ul><p><strong>返回值：</strong></p><ul><li><code>Bit_SET</code>: 引脚为高电平。</li><li><code>Bit_RESET</code>: 引脚为低电平。</li></ul><p><strong>示例：</strong> 读取GPIOA的第5引脚的输入电平：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5) == Bit_SET)</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 引脚为高电平</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">else</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 引脚为低电平</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 192px;"></div><div class="CodeMirror-gutters" style="display: none; height: 222px;"></div></div></div></pre></li><li><p><strong>GPIO配置中断函数：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><p><strong>功能：</strong> 配置外部中断线路，以便外部事件触发中断。</p><p><strong>参数：</strong></p><ul><li><code>GPIO_PortSource</code>: 选择GPIO端口源，例如GPIO_PortSourceGPIOA、GPIO_PortSourceGPIOB等。</li><li><code>GPIO_PinSource</code>: 选择GPIO引脚源，例如GPIO_PinSource0、GPIO_PinSource1等。</li></ul></li><li><p><strong>GPIO设置为模拟模式：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><p><strong>功能：</strong> 初始化GPIO配置结构体为默认值，便于设置模拟模式。</p><p><strong>示例：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIO_InitTypeDef GPIO_InitStructure;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIO_StructInit(&amp;GPIO_InitStructure);  // 设置结构体为默认值</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;  // 设置为模拟模式</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);  // 初始化GPIOA</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 100px;"></div><div class="CodeMirror-gutters" style="display: none; height: 130px;"></div></div></div></pre></li><li><p><strong>GPIO重映射功能：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><p><strong>功能：</strong> 配置GPIO引脚复用功能。</p><p><strong>参数：</strong></p><ul><li><code>GPIOx</code>: 选择的GPIO端口（例如GPIOA、GPIOB等）。</li><li><code>GPIO_PinSource</code>: 选择引脚编号。</li><li><code>GPIO_AF</code>: 选择复用功能（例如USART、SPI等）。</li></ul><p><strong>示例：</strong> 配置GPIOA的第9引脚为USART1的TX引脚：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li></ol><hr /><h3><a name='header-n912' class='md-header-anchor '></a>5.3.2 GPIO标准外设库应用实例</h3><p>以下是一个简单的GPIO应用示例，演示如何配置GPIO引脚以控制一个LED灯。</p><p><strong>硬件连接：</strong></p><ul><li>将LED连接到GPIOA的第5个引脚（PA5）。</li></ul><p><strong>步骤：</strong></p><ol start='' ><li>配置PA5为输出模式。</li><li>在主循环中不断切换PA5的电平，从而控制LED的开关。</li></ol><p><strong>代码示例：</strong></p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include "stm32f10x.h"</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void GPIO_Init(void)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 启用GPIOA时钟</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 配置GPIOA的第5个引脚为推挽输出</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_InitTypeDef GPIO_InitStructure;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 选择PA5</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; &nbsp; &nbsp; // 配置为推挽输出</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; &nbsp;  // 设置输出速度</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_Init(GPIOA, &amp;GPIO_InitStructure); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 初始化PA5</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void Delay(uint32_t delay)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  while (delay--)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  __NOP();  // 空操作，用于延时</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main(void)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_Init();  // 初始化GPIO</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  while (1)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  GPIO_SetBits(GPIOA, GPIO_Pin_5);  // 设置PA5为高电平（LED亮）</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Delay(1000000); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 延时</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  GPIO_ResetBits(GPIOA, GPIO_Pin_5);  // 设置PA5为低电平（LED灭）</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Delay(1000000); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 延时</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 813px;"></div><div class="CodeMirror-gutters" style="display: none; height: 843px;"></div></div></div></pre><p>在此示例中，PA5被配置为推挽输出模式。主程序中通过<code>GPIO_SetBits</code>和<code>GPIO_ResetBits</code>函数切换PA5的电平，控制LED的亮灭。</p><hr /><h3><a name='header-n936' class='md-header-anchor '></a>5.3.3 基于标准外设库开发的一般流程</h3><p>基于STM32标准外设库开发GPIO应用程序通常遵循以下步骤：</p><h4><a name='header-n939' class='md-header-anchor '></a>1. <strong>初始化硬件资源</strong></h4><p>在应用程序开始之前，首先需要初始化硬件资源（例如GPIO、时钟等）。这通常在<code>main()</code>函数的开头进行。</p><ul><li>启用外设时钟：使用<code>RCC_APB2PeriphClockCmd</code>或<code>RCC_AHB1PeriphClockCmd</code>函数启用GPIO等外设的时钟。</li><li>配置GPIO引脚：使用<code>GPIO_Init</code>函数配置GPIO引脚的工作模式、输出类型、上拉/下拉电阻等。</li></ul><h4><a name='header-n949' class='md-header-anchor '></a>2. <strong>配置GPIO引脚</strong></h4><p>根据应用的需求配置GPIO引脚。常见配置包括设置为输入、输出、模拟模式或复用功能。可以使用<code>GPIO_InitTypeDef</code>结构体和<code>GPIO_Init</code>函数进行配置。</p><h4><a name='header-n952' class='md-header-anchor '></a>3. <strong>操作GPIO引脚</strong></h4><p>根据需要的功能，使用库函数控制GPIO引脚。例如，使用<code>GPIO_SetBits</code>和<code>GPIO_ResetBits</code>设置输出引脚的高低电平，使用<code>GPIO_ReadInputDataBit</code>读取输入引脚的电平。</p><h4><a name='header-n955' class='md-header-anchor '></a>4. <strong>中断配置（如果需要）</strong></h4><p>如果应用需要GPIO中断功能，配置外部中断线路（EXTI），并在中断服务程序（ISR）中处理相关事件。使用<code>GPIO_EXTILineConfig</code>和<code>EXTI_Init</code>函数进行配置。</p><h4><a name='header-n958' class='md-header-anchor '></a>5. <strong>调试与优化</strong></h4><p>在应用程序完成后，通过调试工具（如ST-Link或J-Link）进行调试，查看GPIO操作是否符合预期。如果需要，进一步优化代码，减少延时、提高效率等。</p><hr /><h3><a name='header-n962' class='md-header-anchor '></a>总结</h3><p>通过使用STM32标准外设库，开发者可以更加便捷地配置和控制GPIO引脚。标准库提供了丰富的接口函数，涵盖了GPIO的输入输出、复用功能、中断配置等常见操作。应用实例展示了如何使用这些函数控制LED，同时基于标准外设库的开发流程也为嵌入式系统开发提供了清晰的步骤和方法。</p><h2><a name='header-n965' class='md-header-anchor '></a>第6章 中断</h2><h3><a name='header-n966' class='md-header-anchor '></a>6.1 中断的相关概念</h3><p>中断是嵌入式系统中非常重要的概念，它用于应对外部事件的及时响应。中断的使用可以使系统在处理某些任务时不会一直停留在一个流程中，而是能够灵活响应外部的变化，从而提高系统的响应性和效率。</p><h4><a name='header-n969' class='md-header-anchor '></a>6.1.1 什么是中断</h4><p>中断（Interrupt）是一种在微处理器中用于暂停当前程序执行并转而执行其他任务的机制。中断通常由硬件或软件触发，当某个特定事件发生时，处理器会暂停正在执行的程序，转而处理该事件对应的中断服务程序（ISR）。中断是一种异步机制，即它可以在程序执行的任何时刻发生。</p><p><strong>中断的主要特点：</strong></p><ul><li><strong>中断源：</strong> 中断源可以是外部设备、内部事件或者定时器等。</li><li><strong>中断响应：</strong> 当中断发生时，处理器会响应中断请求，并跳转到对应的中断服务程序（ISR）去处理。</li><li><strong>中断优先级：</strong> 不同的中断可以设置不同的优先级，优先级高的中断会先被处理。</li></ul><p>中断分为两类：</p><ol start='' ><li><strong>外部中断：</strong> 由外部设备或事件触发，例如外部按键按下、外部信号变化等。</li><li><strong>内部中断：</strong> 由内部事件触发，例如定时器溢出、看门狗超时、软件中断等。</li></ol><h4><a name='header-n993' class='md-header-anchor '></a>6.1.2 为什么使用中断</h4><p>使用中断有以下几个主要原因：</p><ol start='' ><li><strong>提高响应速度：</strong> 中断允许处理器实时响应外部事件，减少了传统轮询方式的等待时间。例如，当外部设备如传感器产生变化时，使用中断可以立即响应，而不需要程序每隔一段时间轮询设备状态。</li><li><strong>节省CPU资源：</strong> 在没有中断的情况下，CPU需要持续轮询外设以检查是否发生了事件，这会占用大量的处理时间。而使用中断时，CPU可以在空闲时进行其他任务，只有在中断发生时才中断当前工作，节省了处理器资源。</li><li><strong>提高系统实时性：</strong> 中断机制让系统能够及时响应关键事件，这对于实时性要求较高的应用至关重要。例如，在控制系统中，响应外部传感器数据或时间中断可以影响系统的稳定性和性能。</li><li><strong>简化系统设计：</strong> 中断机制使得程序设计更加简洁。在没有中断的情况下，程序设计可能需要复杂的轮询机制来检查事件，而中断使得这些机制变得更直观和高效。</li></ol><h4><a name='header-n1009' class='md-header-anchor '></a>6.1.3 中断处理流程</h4><p>中断处理流程涉及从中断事件的发生到处理完成的整个过程。STM32等嵌入式系统的中断处理流程通常包括以下几个步骤：</p><ol start='' ><li><strong>中断请求（IRQ）生成：</strong>中断的发生通常由外部事件（如硬件设备状态变化、定时器溢出等）或内部事件（如软件触发的中断）触发。处理器持续监控这些事件，并且在发生中断请求时生成一个中断信号。</li><li><strong>中断请求的优先级判断：</strong>如果有多个中断请求发生，系统根据中断的优先级来决定先后处理顺序。STM32中通常有硬件优先级管理机制，用户可以在初始化时设置每个中断源的优先级。</li><li><strong>中断挂起与响应：</strong>一旦一个中断被触发，处理器会停止当前执行的程序，保存当前程序的状态（如PC寄存器、SP寄存器等），并开始执行中断服务程序（ISR）。此时，处理器进入中断处理状态，执行与该中断相关的代码。</li><li><strong>中断服务程序（ISR）执行：</strong>中断服务程序（ISR）是针对特定中断事件的处理代码。ISR的主要任务是处理触发中断的事件，并尽量快速地执行完毕。处理完成后，ISR应该尽量简洁，不要包含阻塞性操作（如延时等），以避免影响系统的实时性。</li><li><strong>中断清除与恢复：</strong>中断服务程序执行完成后，处理器需要清除中断标志位，以便后续中断能够被正确响应。然后，处理器会恢复到中断前的程序状态，继续执行原先的任务。</li><li><strong>中断嵌套（可选）：</strong>在某些情况下，高优先级的中断可以打断低优先级的中断服务程序，这种机制被称为中断嵌套。在中断嵌套的情况下，中断服务程序需要更小心地保存和恢复上下文，确保每个中断的处理能够正确执行。</li></ol><hr /><h3><a name='header-n1032' class='md-header-anchor '></a>总结</h3><p>中断是嵌入式系统中用于响应外部或内部事件的一种机制。它通过在事件发生时暂停当前程序并执行中断服务程序来提供即时响应。使用中断可以提高系统的实时性、响应速度、节省处理器资源，并简化系统设计。理解中断的概念、使用中断的原因以及中断处理流程，对于编写高效的嵌入式应用程序至关重要。</p><h3><a name='header-n1035' class='md-header-anchor '></a>6.2 STM32中断和异常</h3><p>在STM32微控制器中，中断和异常机制是处理外部和内部事件的关键工具。STM32使用中断和异常来中断程序的执行，并让系统响应各种硬件或软件的事件。了解STM32的中断和异常机制对于高效开发嵌入式系统非常重要。</p><h4><a name='header-n1038' class='md-header-anchor '></a>6.2.1 STM32中断和异常向量表</h4><p>在STM32中，所有中断和异常的入口地址都存储在一个叫做“中断向量表”（Interrupt Vector Table, IVT）的位置。中断向量表是一个包含各个中断和异常入口地址的数组，每个入口点对应一个特定的中断源或异常。</p><h5><a name='header-n1041' class='md-header-anchor '></a>中断向量表的结构</h5><p>中断向量表通常位于系统内存的起始位置，地址为<code>0x00000000</code>（起始地址）。在STM32中，向量表通常存储在Flash或RAM中。中断向量表的每一项是一个指向中断服务程序（ISR）的地址。</p><p>中断向量表包含两类内容：</p><ol start='' ><li><strong>复位向量（Reset Vector）：</strong> 当微控制器上电或复位时，系统会从复位向量指定的地址开始执行程序。复位向量通常是程序的起始位置。</li><li><strong>中断向量：</strong> 每个中断源都对应一个向量，向量表中存储每个中断的处理函数地址。中断向量是中断发生时，处理器跳转的地址。</li></ol><h5><a name='header-n1053' class='md-header-anchor '></a>中断向量表的组织</h5><p>STM32的中断向量表按如下顺序组织：</p><ul><li><strong>复位向量：</strong> 系统复位后处理的第一个函数地址。</li><li><strong>NMI向量（Non-Maskable Interrupt）：</strong> 处理不可屏蔽中断的函数地址。</li><li><strong>硬件中断向量：</strong> 各种硬件中断源的入口地址（如定时器、外部引脚、通信接口等）。</li><li><strong>系统异常向量：</strong> 用于处理各种系统异常（如硬错误、存储访问错误等）。</li></ul><p>向量表的大小和内容根据具体的STM32型号和应用而有所不同，但一般来说，向量表的前几个地址是固定的，用于存储复位地址、中断源的地址以及异常服务程序。</p><h5><a name='header-n1071' class='md-header-anchor '></a>向量表的定义</h5><p>STM32使用<code>startup.s</code>文件（汇编语言）定义中断向量表。在此文件中，你可以看到复位向量和各个中断的入口地址。例如：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">  .section .isr_vector, "a", %progbits</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">  .global _vectors</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">  _vectors:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  .word _estack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  /* 初始堆栈地址 */</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  .word Reset_Handler &nbsp; &nbsp; &nbsp;  /* 复位向量 */</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  .word NMI_Handler &nbsp; &nbsp; &nbsp; &nbsp;  /* NMI中断 */</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  .word HardFault_Handler &nbsp;  /* 硬错误异常 */</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  /* 其他中断向量 */</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 192px;"></div><div class="CodeMirror-gutters" style="display: none; height: 222px;"></div></div></div></pre><h4><a name='header-n1075' class='md-header-anchor '></a>6.2.2 STM32中断优先级</h4><p>在STM32中，中断优先级用于确定多个中断同时发生时，哪个中断应该先被处理。STM32的中断优先级机制具有一定的复杂性，允许用户配置中断的优先级，使得高优先级的中断能够打断低优先级的中断。</p><h5><a name='header-n1078' class='md-header-anchor '></a>中断优先级的设定</h5><p>STM32使用一个分为两部分的优先级系统：</p><ol start='' ><li><strong>抢占优先级（Pre-emption Priority）：</strong> 用于决定中断是否能打断当前的中断服务程序。抢占优先级越高的中断能越早抢占低优先级的中断。</li><li><strong>子优先级（Subpriority）：</strong> 用于在相同抢占优先级的中断之间进一步排序。在多个中断具有相同抢占优先级时，子优先级决定哪个中断先执行。</li></ol><p>优先级的设定是通过配置中断控制寄存器（NVIC）中的<code>IP</code>（Interrupt Priority）字段来完成的。STM32的优先级字段通常是4位的，但实际的优先级位数根据具体的型号和中断控制器的配置有所不同。</p><h5><a name='header-n1090' class='md-header-anchor '></a>STM32中断优先级设置</h5><p>STM32允许通过以下方式设置中断的优先级：</p><ol start='' ><li><strong>中断优先级分组：</strong> STM32支持多个中断优先级分组，分组数决定了抢占优先级和子优先级的位数。可以通过<code>NVIC_PriorityGroupConfig</code>函数设置中断优先级分组。</li><li><strong>设置具体中断的优先级：</strong> 通过<code>NVIC_SetPriority</code>函数设置某个中断的优先级。</li></ol><p><strong>优先级设置示例：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_SetPriority(USART1_IRQn, NVIC_EncodePriority(NVIC_PriorityGroup_2, 1, 0));</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><p>这行代码将USART1中断的抢占优先级设置为1，子优先级设置为0，优先级分组为<code>NVIC_PriorityGroup_2</code>，这意味着抢占优先级占用2位，子优先级占用2位。</p><h5><a name='header-n1105' class='md-header-anchor '></a>中断优先级分组</h5><p>中断优先级分组决定了优先级字段中的抢占优先级和子优先级的位数。STM32支持如下几种分组：</p><ul><li><strong>NVIC_PriorityGroup_0:</strong> 只有抢占优先级，没有子优先级。</li><li><strong>NVIC_PriorityGroup_1:</strong> 1位抢占优先级，3位子优先级。</li><li><strong>NVIC_PriorityGroup_2:</strong> 2位抢占优先级，2位子优先级。</li><li><strong>NVIC_PriorityGroup_3:</strong> 3位抢占优先级，1位子优先级。</li><li><strong>NVIC_PriorityGroup_4:</strong> 4位抢占优先级，0位子优先级。</li></ul><p>通过<code>NVIC_PriorityGroupConfig()</code>来设置优先级分组。</p><h4><a name='header-n1126' class='md-header-anchor '></a>6.2.3 STM32中断服务程序（ISR）</h4><p>中断服务程序（ISR，Interrupt Service Routine）是当中断发生时处理器执行的函数。它是响应特定中断源的程序，通常用于处理中断事件，例如读取外设数据、清除中断标志等。</p><h5><a name='header-n1129' class='md-header-anchor '></a>中断服务程序的工作流程</h5><ol start='' ><li><strong>中断发生：</strong> 当中断条件满足时（例如定时器溢出、外部输入等），中断请求被发出，处理器暂停当前任务，进入中断服务程序。</li><li><strong>保存上下文：</strong> 处理器保存当前任务的上下文（程序计数器PC、堆栈指针SP等），以便在中断结束后恢复。</li><li><strong>执行ISR：</strong> 处理器跳转到ISR的入口点，执行ISR代码。在ISR中，通常要进行必要的中断处理，如清除中断标志、读取数据、驱动外设等。</li><li><strong>恢复上下文：</strong> ISR执行完毕后，恢复上下文，恢复原先的任务并返回主程序。</li></ol><h5><a name='header-n1143' class='md-header-anchor '></a>编写中断服务程序</h5><p>中断服务程序必须尽量简洁和高效，以避免占用过多的CPU时间。通常，ISR只执行最低限度的处理工作（例如清除中断标志、设置标志位等），然后尽量快地退出，避免阻塞其他中断的处理。</p><p>STM32的中断服务程序格式如下：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void USART1_IRQHandler(void)</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) // 检查是否是接收中断</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  uint16_t received_data = USART_ReceiveData(USART1); // 读取接收到的数据</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  // 处理接收到的数据</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  USART_ClearITPendingBit(USART1, USART_IT_RXNE); // 清除中断标志</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 215px;"></div><div class="CodeMirror-gutters" style="display: none; height: 245px;"></div></div></div></pre><p>在ISR中，首先要判断中断标志位，确定是否触发了对应的中断，然后进行相应的处理，最后通过<code>USART_ClearITPendingBit</code>等函数清除中断标志，防止中断被重复触发。</p><hr /><h3><a name='header-n1152' class='md-header-anchor '></a>总结</h3><p>STM32的中断和异常机制允许系统在事件发生时快速响应，并通过优先级控制和中断服务程序来处理各种任务。中断向量表是中断处理的核心，STM32提供了灵活的中断优先级控制以及高效的中断服务程序设计方式。理解中断向量表、优先级管理和ISR的编写规范对于高效使用STM32中断系统至关重要。</p><h3><a name='header-n1155' class='md-header-anchor '></a>6.3 STM32外部中断（EXTI）</h3><p>STM32的外部中断（EXTI，External Interrupt）功能允许微控制器响应外部信号的变化（如按钮按下、外部传感器的信号等）。通过外部中断，STM32能够及时响应硬件事件，而无需通过轮询方式来检测设备状态，这大大提高了系统的响应速度和效率。</p><h4><a name='header-n1158' class='md-header-anchor '></a>6.3.1 EXTI概述</h4><p>EXTI是STM32的一个外设模块，用于处理外部引脚产生的中断或事件。每个EXTI通道（通常是GPIO引脚）都可以配置为响应上升沿、下降沿或双边沿（即状态变化）。EXTI模块可以与多个外部引脚（如GPIOA、GPIOB等）相连接，并通过中断机制响应这些引脚上的电平变化。</p><p>STM32的EXTI模块可以支持的功能包括：</p><ol start='' ><li><strong>外部中断</strong>：响应外部引脚状态的变化。</li><li><strong>事件触发</strong>：响应外部引脚的电平变化（高电平、低电平）或边沿触发（上升沿、下降沿）。</li></ol><p>STM32支持的外部中断引脚包括（具体的引脚依型号而异）：</p><ul><li><strong>GPIOA</strong>、<strong>GPIOB</strong>、<strong>GPIOC</strong>等。</li><li>每个GPIO引脚（如PA0、PA1等）都可以通过EXTI模块配置为外部中断源。</li></ul><h4><a name='header-n1179' class='md-header-anchor '></a>6.3.2 EXTI的工作原理</h4><p>EXTI的工作过程通常包括以下几个步骤：</p><ol start='' ><li><strong>配置GPIO引脚</strong>：首先，需要将某个GPIO引脚配置为输入模式，并启用外部中断功能。这通常通过配置GPIO引脚的寄存器来完成。</li><li><strong>配置EXTI模块</strong>：通过EXTI寄存器配置外部中断的触发条件（例如，选择上升沿、下降沿或双边沿触发）。</li><li><strong>使能EXTI中断</strong>：启用EXTI中断源，并配置中断优先级。</li><li><strong>中断服务</strong>：当EXTI引脚状态变化时，EXTI模块触发中断，控制器跳转到中断服务程序（ISR）来处理事件。</li><li><strong>清除中断标志</strong>：在ISR中，需要手动清除EXTI中断标志，防止中断重复触发。</li></ol><h4><a name='header-n1198' class='md-header-anchor '></a>6.3.3 EXTI中断配置</h4><p>EXTI模块的配置主要包括以下几个方面：</p><ul><li><strong>触发条件</strong>：选择中断的触发条件（上升沿、下降沿或双边沿）。</li><li><strong>中断使能</strong>：通过<code>EXTI_IMR</code>寄存器使能外部中断。</li><li><strong>中断优先级</strong>：通过NVIC配置中断优先级。</li><li><strong>中断标志清除</strong>：在ISR中通过清除<code>EXTI_PR</code>寄存器中的相应标志位来防止中断重复触发。</li></ul><h4><a name='header-n1214' class='md-header-anchor '></a>EXTI中断配置代码示例</h4><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">c</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">复制代码</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void EXTI0_IRQHandler(void)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 检查EXTI0中断是否发生</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  if (EXTI_GetITStatus(EXTI_Line0) != RESET)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  // 处理中断，例如读取外部传感器值</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  // 清除EXTI0中断标志</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  EXTI_ClearITPendingBit(EXTI_Line0);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 330px;"></div><div class="CodeMirror-gutters" style="display: none; height: 360px;"></div></div></div></pre><p>在上述示例中，当EXTI0引脚的状态变化触发中断时，程序进入<code>EXTI0_IRQHandler</code>函数进行处理中，并通过<code>EXTI_ClearITPendingBit</code>清除中断标志，防止中断被多次触发。</p><h3><a name='header-n1218' class='md-header-anchor '></a>6.4 EXTI标准外设库接口函数及应用</h3><p>在STM32的开发中，EXTI（外部中断）功能允许系统快速响应外部事件，如按钮按下、外部传感器的信号等。为了简化EXTI的配置与应用，STM32提供了标准外设库接口函数来帮助开发者快速实现外部中断功能。接下来将介绍标准外设库接口函数、编程步骤以及一些应用实例。</p><hr /><h4><a name='header-n1222' class='md-header-anchor '></a>6.4.1 EXTI标准外设库接口函数</h4><p>STM32的标准外设库提供了多种API函数，用于配置和管理EXTI模块。这些函数可以帮助开发者轻松实现外部中断的功能。</p><h4><a name='header-n1225' class='md-header-anchor '></a>常用的EXTI标准外设库接口函数</h4><ol start='' ><li><p><strong>EXTI_Init()</strong></p><ul><li><p><strong>功能</strong>：用于初始化EXTI线的配置（选择中断引脚、设置触发条件等）。</p></li><li><p>原型</p><p>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li></ul></li><li><p><strong>EXTI_ClearITPendingBit()</strong></p><ul><li><p><strong>功能</strong>：清除指定EXTI线的中断挂起标志。中断挂起标志是在中断发生后设置的，必须清除它才能防止中断重复触发。</p></li><li><p>原型</p><p>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void EXTI_ClearITPendingBit(uint32_t EXTI_Line);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li></ul></li><li><p><strong>EXTI_GenerateSWInterrupt()</strong></p><ul><li><p><strong>功能</strong>：生成一个软件触发的中断。该函数用于通过软件触发中断。</p></li><li><p>原型</p><p>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li></ul></li><li><p><strong>EXTI_ITConfig()</strong></p><ul><li><p><strong>功能</strong>：使能或禁用EXTI中断。可以通过该函数控制EXTI中断源的使能或禁用。</p></li><li><p>原型</p><p>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void EXTI_ITConfig(uint32_t EXTI_Line, FunctionalState NewState);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li></ul></li><li><p><strong>EXTI_LineConfig()</strong></p><ul><li><p><strong>功能</strong>：配置EXTI线与对应的GPIO引脚之间的映射。使用该函数可以将GPIO引脚与EXTI中断线进行连接。</p></li><li><p>原型</p><p>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void EXTI_LineConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li></ul></li></ol><h4><a name='header-n1292' class='md-header-anchor '></a>EXTI_InitTypeDef 结构体</h4><p><code>EXTI_InitTypeDef</code>结构体是用于配置EXTI的结构体，包含了各种设置EXTI行为的字段。常见的字段包括：</p><ul><li><code>EXTI_Line</code>: 配置的EXTI线（如<code>EXTI_Line0</code>、<code>EXTI_Line1</code>等）。</li><li><code>EXTI_Mode</code>: 配置中断模式（如<code>EXTI_Mode_Interrupt</code>或<code>EXTI_Mode_Event</code>）。</li><li><code>EXTI_Trigger</code>: 配置中断触发方式（如<code>EXTI_Trigger_Rising</code>、<code>EXTI_Trigger_Falling</code>、<code>EXTI_Trigger_Rising_Falling</code>）。</li><li><code>EXTI_LineCmd</code>: 配置EXTI线是否使能。</li></ul><p>例如，配置EXTI0中断触发上升沿：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_InitTypeDef EXTI_InitStructure;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_InitStructure.EXTI_Line = EXTI_Line0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_Init(&amp;EXTI_InitStructure);</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 146px;"></div><div class="CodeMirror-gutters" style="display: none; height: 176px;"></div></div></div></pre><hr /><h4><a name='header-n1312' class='md-header-anchor '></a>6.4.2 EXTI标准外设库中断应用编程步骤</h4><p>在STM32中使用外部中断时，需要按一定的步骤进行配置。以下是使用EXTI的标准外设库实现外部中断的基本步骤：</p><h5><a name='header-n1315' class='md-header-anchor '></a>步骤1：配置GPIO引脚</h5><p>首先，必须将需要作为中断源的GPIO引脚配置为输入模式，并使能相应的时钟。通常，通过上拉或下拉配置GPIO引脚，以确保其具有有效的电平。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIO_InitTypeDef GPIO_InitStructure;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // 使能GPIOA时钟</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 配置PA0为中断输入</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; &nbsp; &nbsp; &nbsp; &nbsp; // 配置为上拉输入</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 123px;"></div><div class="CodeMirror-gutters" style="display: none; height: 153px;"></div></div></div></pre><h5><a name='header-n1319' class='md-header-anchor '></a>步骤2：配置EXTI外部中断线</h5><p>EXTI模块将GPIO引脚与中断线连接，需要配置GPIO与EXTI线之间的映射。此操作通过<code>GPIO_EXTILineConfig()</code>函数完成。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); // 使能AFIO时钟</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); // 配置PA0引脚为EXTI0中断源</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre><h5><a name='header-n1323' class='md-header-anchor '></a>步骤3：配置EXTI触发条件</h5><p>接下来，通过配置<code>EXTI_InitTypeDef</code>结构体来设置EXTI中断触发的条件，如选择上升沿、下降沿或双边沿触发。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_InitTypeDef EXTI_InitStructure;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_InitStructure.EXTI_Line = EXTI_Line0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 配置EXTI0</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; &nbsp; &nbsp; &nbsp; // 配置为中断模式</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; &nbsp;  // 配置为上升沿触发</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_InitStructure.EXTI_LineCmd = ENABLE; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 使能EXTI0</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_Init(&amp;EXTI_InitStructure);</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 146px;"></div><div class="CodeMirror-gutters" style="display: none; height: 176px;"></div></div></div></pre><h5><a name='header-n1327' class='md-header-anchor '></a>步骤4：配置中断优先级和NVIC</h5><p>最后，配置中断优先级并使能NVIC中断。确保在中断发生时，处理器能够跳转到正确的中断处理函数。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_InitTypeDef NVIC_InitStructure;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; &nbsp; &nbsp; &nbsp; &nbsp;  // 配置EXTI0中断通道</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;  // 设置抢占优先级</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; &nbsp; &nbsp; &nbsp;  // 设置子优先级</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 使能NVIC中断</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_Init(&amp;NVIC_InitStructure);</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 146px;"></div><div class="CodeMirror-gutters" style="display: none; height: 176px;"></div></div></div></pre><h5><a name='header-n1331' class='md-header-anchor '></a>步骤5：编写中断服务程序</h5><p>当中断条件满足时，EXTI0中断会被触发并跳转到中断处理函数（<code>EXTI0_IRQHandler</code>）。在中断服务程序中，必须清除中断标志，以防止中断被重复触发。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void EXTI0_IRQHandler(void)</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  if (EXTI_GetITStatus(EXTI_Line0) != RESET)  // 检查EXTI0中断是否触发</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  // 处理外部中断，例如读取传感器数据</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  EXTI_ClearITPendingBit(EXTI_Line0); &nbsp;  // 清除EXTI0中断标志</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 192px;"></div><div class="CodeMirror-gutters" style="display: none; height: 222px;"></div></div></div></pre><hr /><h4><a name='header-n1336' class='md-header-anchor '></a>6.4.3 EXTI标准外设库应用实例</h4><p>以下是一个简单的外部中断应用实例，通过配置PA0引脚来响应按钮按下事件，当按钮按下时触发中断，LED灯的状态发生变化。</p><h5><a name='header-n1339' class='md-header-anchor '></a>应用实例：按键中断控制LED</h5><h5><a name='header-n1340' class='md-header-anchor '></a><strong>硬件配置：</strong></h5><ul><li>PA0引脚连接到一个按钮。</li><li>PD12引脚连接到一个LED。</li></ul><p><strong>代码实现：</strong></p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include "stm32f10x.h"</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 按钮和LED的GPIO配置</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void GPIO_Config(void)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_InitTypeDef GPIO_InitStructure;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 使能GPIOA和GPIOD时钟</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOD, ENABLE);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 配置PA0为输入模式（按钮）</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  // 配置为上拉输入</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 配置PD12为推挽输出模式（LED）</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  // 配置为推挽输出</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 外部中断配置</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void EXTI_Config(void)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  EXTI_InitTypeDef EXTI_InitStructure;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 配置EXTI Line0连接到PA0</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 配置EXTI中断</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  EXTI_InitStructure.EXTI_Line = EXTI_Line0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  // 配置为上升沿触发</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; </span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 790px;"></div><div class="CodeMirror-gutters" style="display: none; height: 820px;"></div></div></div></pre><p>EXTI_InitStructure.EXTI_LineCmd = ENABLE;EXTI_Init(&amp;EXTI_InitStructure);</p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 配置NVIC中断</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_InitTypeDef NVIC_InitStructure;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NVIC_Init(&amp;NVIC_InitStructure);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 中断服务程序</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void EXTI0_IRQHandler(void)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">if (EXTI_GetITStatus(EXTI_Line0) != RESET)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{// 按钮按下时，切换LED的状态</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GPIOB-&gt;ODR ^= GPIO_Pin_12;  // 切换PD12引脚（LED状态）</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 清除EXTI中断标志</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  EXTI_ClearITPendingBit(EXTI_Line0);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main(void){// 配置GPIO和外部中断GPIO_Config();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">EXTI_Config();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">while (1)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 主循环为空，外部中断处理LED状态</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 583px;"></div><div class="CodeMirror-gutters" style="display: none; height: 613px;"></div></div></div></pre><p>在这个实例中，我们使用PA0引脚连接到按钮，当按钮被按下时，PA0的状态会发生变化，从而触发EXTI中断。中断处理程序<code>EXTI0_IRQHandler</code>中，LED状态被切换（打开或关闭）。</p><hr /><h3><a name='header-n1357' class='md-header-anchor '></a>总结</h3><p>通过标准外设库接口函数，可以方便地配置STM32的EXTI模块来实现外部中断功能。配置步骤包括GPIO引脚设置、EXTI线配置、触发条件设置、中断优先级配置和编写中断服务程序。通过外部中断，STM32能够高效地响应外部事件，提高系统的实时性和响应速度。</p><h2><a name='header-n1360' class='md-header-anchor '></a>第7章 串口通信</h2><p>在嵌入式系统中，串口通信是最常见的数据传输方式之一，广泛应用于微控制器与其他设备之间的通信。串口通信的优势包括实现简单、成本低廉和可靠性高。本章将介绍串口通信的基本概念、异步串行通信协议及其接口配置。</p><hr /><h3><a name='header-n1364' class='md-header-anchor '></a>7.1 通信概述</h3><p>串口通信（Serial Communication）是一种常用的通信方式，它通过单根数据线按位传输数据，相较于并行通信，占用的引脚较少，通信距离较远，应用广泛。串口通信一般可以分为两种类型：</p><ol start='' ><li><strong>异步串行通信</strong>：不需要时钟信号，数据的传输依赖于预设的波特率。</li><li><strong>同步串行通信</strong>：需要时钟信号，数据传输通过时钟信号同步。</li></ol><p>在嵌入式系统中，异步串行通信被广泛使用，它的特点是简单、容易实现，并且适用于很多低速数据传输场景。</p><hr /><h3><a name='header-n1377' class='md-header-anchor '></a>7.2 异步串行通信</h3><p>异步串行通信（Asynchronous Serial Communication）是一种不需要同步时钟的通信方式。数据通过一系列的位（bit）在时间上顺序传输，通常使用起始位、数据位、校验位和停止位进行编码。接收端按照预定的波特率对数据流进行解码，从而还原出原始数据。</p><h4><a name='header-n1380' class='md-header-anchor '></a>7.2.1 异步串行通信协议</h4><p>异步串行通信协议是一套标准的约定，用于确保数据传输的正确性。常见的异步串行通信协议包括RS-232、RS-485和TTL串口通信等。协议规定了数据的格式、波特率、数据位、校验位和停止位等参数。</p><ol start='' ><li><p><strong>数据格式</strong>：</p><ul><li><strong>起始位</strong>：在数据传输的开始，起始位用来告诉接收端数据的开始位置。通常为1位，逻辑低电平。</li><li><strong>数据位</strong>：数据本身是通过多个数据位传输的。常见的传输位数为5、6、7或8位。最常见的是8位数据传输。</li><li><strong>校验位</strong>（可选）：校验位用于检测传输过程中的错误。常见的校验方式有无校验、奇校验和偶校验。</li><li><strong>停止位</strong>：停止位用来表示数据的结束，通常为1位、1.5位或2位。</li></ul><p>常见的串口帧格式为：</p><pre class="md-fences mock-cm md-end-block" lang="">| 起始位 | 数据位 | 校验位 | 停止位 |
|    1    |    8    |    1   |    1   |
</pre><p>在此格式中，起始位为1位，数据位为8位，校验位为1位（可选），停止位为1位。</p></li><li><p><strong>波特率</strong>：波特率是数据传输的速率，通常以“波特（bps）”表示。例如，9600波特率表示每秒钟传输9600位数据。发送端和接收端必须设置相同的波特率，以保证数据的正确接收。</p></li><li><p><strong>传输模式</strong>：</p><ul><li><strong>全双工</strong>：可以同时进行数据的双向传输，常见于RS-232和TTL接口。</li><li><strong>半双工</strong>：数据传输是单向的，但可以在两个方向之间切换，常见于RS-485。</li></ul></li></ol><h4><a name='header-n1418' class='md-header-anchor '></a>7.2.2 异步串行通信接口</h4><p>在STM32等微控制器中，异步串行通信通常使用<strong>USART</strong>（通用同步异步收发传输器）或<strong>UART</strong>（通用异步收发传输器）模块来实现。USART和UART模块在硬件上为串口通信提供了必要的功能，如起始位、数据位、停止位和波特率控制等。</p><h5><a name='header-n1421' class='md-header-anchor '></a>1. <strong>USART和UART的区别</strong>：</h5><ul><li><strong>USART</strong>：支持同步和异步通信，因此除了异步模式外，还可以进行同步模式下的通信。</li><li><strong>UART</strong>：通常指的是异步串行通信接口，它仅支持异步模式。</li></ul><p>在STM32微控制器中，USART模块支持异步串行通信，并通过标准外设库提供了一些接口函数，方便开发者配置和使用。</p><h4><a name='header-n1431' class='md-header-anchor '></a>1. <strong>USART配置步骤</strong></h4><p>以STM32的USART1为例，常见的配置步骤如下：</p><ol start='' ><li><p><strong>使能USART时钟</strong>：通过使能USART外设的时钟，可以启动串口通信模块。</p><pre class="md-fences mock-cm md-end-block" lang="">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
</pre></li><li><p><strong>配置GPIO引脚</strong>：配置USART的TX（发送端）和RX（接收端）引脚为复用模式。</p><pre class="md-fences mock-cm md-end-block" lang="">GPIO_InitTypeDef GPIO_InitStructure;
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  // 使能GPIOA时钟
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;              // USART1 TX引脚
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;         // 复用推挽输出
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;       // 引脚速度设置
GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;             // USART1 RX引脚
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;   // 浮空输入
GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
</pre></li><li><p><strong>配置USART参数</strong>：设置USART的工作模式，如波特率、数据位、停止位和校验位等。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_InitTypeDef USART_InitStructure;
USART_InitStructure.USART_BaudRate = 9600;            // 设置波特率
USART_InitStructure.USART_WordLength = USART_WordLength_8b; // 8位数据长度
USART_InitStructure.USART_StopBits = USART_StopBits_1; // 1位停止位
USART_InitStructure.USART_Parity = USART_Parity_No;    // 无校验位
USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // 无硬件流控制
USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; // 配置为收发模式
USART_Init(USART1, &amp;USART_InitStructure);
</pre></li><li><p><strong>使能USART</strong>：启用USART模块，开始进行数据传输。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_Cmd(USART1, ENABLE);  // 启用USART1
</pre></li></ol><h4><a name='header-n1451' class='md-header-anchor '></a>2. <strong>USART数据发送和接收</strong></h4><ol start='' ><li><p><strong>发送数据</strong>：使用<code>USART_SendData()</code>函数发送数据。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_SendData(USART1, 'A');  // 发送字符'A'
while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);  // 等待发送缓冲区空
</pre></li><li><p><strong>接收数据</strong>：使用<code>USART_ReceiveData()</code>函数接收数据。</p><pre class="md-fences mock-cm md-end-block" lang="">if (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) != RESET)  // 检查是否接收到数据
{
    char receivedData = USART_ReceiveData(USART1);  // 读取接收到的数据
}
</pre></li></ol><hr /><h3><a name='header-n1462' class='md-header-anchor '></a>总结</h3><p>异步串行通信是一种非常常见的通信方式，它通过标准的协议格式传输数据，适用于微控制器与外部设备之间的通信。STM32通过USART模块支持异步串行通信，开发者可以通过配置GPIO引脚和USART外设来实现数据的收发。理解异步串行通信协议以及如何配置USART接口，对于设计高效的嵌入式系统至关重要。</p><h3><a name='header-n1465' class='md-header-anchor '></a>7.3 STM32的USART模块</h3><p>在STM32微控制器中，USART（通用同步异步收发传输器）模块用于实现串行通信，支持异步（UART）和同步模式。USART模块广泛应用于数据传输、调试、通信协议的实现等场景。理解USART模块的内部结构、接口及编程模式对有效利用STM32进行串口通信至关重要。</p><hr /><h4><a name='header-n1469' class='md-header-anchor '></a>7.3.1 USART内部结构</h4><p>USART模块的内部结构设计用于支持异步和同步串行通信。STM32的USART模块一般由以下几个关键组成部分构成：</p><ol start='' ><li><p><strong>数据寄存器（DR，Data Register）</strong>：</p><ul><li>用于存储发送和接收的数据。USART模块通过该寄存器与外部设备进行数据交换。</li><li>发送数据时，将数据写入<code>DR</code>寄存器，USART将其移出并通过TX线发送。</li><li>接收数据时，数据从RX线接收并存储到<code>DR</code>寄存器中，供CPU读取。</li></ul></li><li><p><strong>控制寄存器（CR1、CR2、CR3）</strong>：</p><ul><li><strong>CR1</strong>：控制USART的工作模式，配置数据位、停止位、波特率、校验等。</li><li><strong>CR2</strong>：配置停止位数、LIN协议等。</li><li><strong>CR3</strong>：控制硬件流控制、DMA模式等。</li></ul></li><li><p><strong>状态寄存器（SR，Status Register）</strong>：</p><ul><li><p>用于标志USART模块的当前状态，如是否接收或发送数据、是否出现错误等。常用标志位包括：</p><ul><li><code>TXE</code>：发送缓冲区空标志。</li><li><code>RXNE</code>：接收缓冲区非空标志。</li><li><code>TC</code>：传输完成标志。</li><li><code>ORE</code>：溢出错误标志。</li></ul></li></ul></li><li><p><strong>波特率生成器（BRR，Baud Rate Register）</strong>：</p><ul><li>该寄存器用于设置USART的波特率。波特率由外部时钟频率（如APB时钟）与BRR寄存器的值共同确定。</li></ul></li><li><p><strong>控制与数据流管理</strong>：</p><ul><li><strong>USART的发送与接收寄存器</strong>：实现数据的串行传输。</li><li><strong>DMA传输支持</strong>：USART模块可与DMA（直接存储器访问）协同工作，自动处理数据传输，提高数据处理效率。</li></ul></li><li><p><strong>中断控制</strong>：</p><ul><li>USART模块内建中断支持，当数据准备好时（如接收到数据或发送完成），会触发中断，程序可以通过中断服务程序（ISR）处理数据。</li></ul></li></ol><hr /><h4><a name='header-n1544' class='md-header-anchor '></a>7.3.2 USART接口</h4><p>STM32的USART模块提供了多种接口功能，用于连接外部设备并进行串行通信。常见的USART接口包括：</p><ol start='' ><li><p><strong>TX（传输）和RX（接收）引脚</strong>：</p><ul><li><strong>TX引脚</strong>：用于发送数据。</li><li><strong>RX引脚</strong>：用于接收数据。</li></ul></li><li><p><strong>硬件流控制</strong>：</p><ul><li><p>STM32的USART模块支持硬件流控制，如RTS（请求发送）和CTS（清除发送），这些信号用于在串行通信中提供流量控制。</p><ul><li><strong>RTS（Request to Send）</strong>：在串行通信中，主设备可以通过RTS信号告知从设备准备发送数据。</li><li><strong>CTS（Clear to Send）</strong>：从设备通过CTS信号告诉主设备可以开始发送数据。</li></ul></li></ul></li><li><p><strong>同步与异步模式</strong>：</p><ul><li><strong>异步模式</strong>（UART）：没有时钟线，数据通过波特率同步发送，适用于一般的低速通信。</li><li><strong>同步模式</strong>：需要时钟信号，数据在时钟信号的控制下同步发送，适用于高速通信。</li></ul></li><li><p><strong>多路复用（GPIO复用）</strong>：</p><ul><li>USART的TX/RX引脚通常为复用引脚，可以通过修改GPIO的复用功能来选择这些引脚。比如，STM32的PA9和PA10引脚可以作为USART1的TX和RX引脚。</li></ul><p>例如，配置PA9和PA10为USART1的TX和RX：</p><pre class="md-fences mock-cm md-end-block" lang="">GPIO_InitTypeDef GPIO_InitStructure;
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  // 设置为复用推挽输出模式
GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  // 设置为浮空输入模式
GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
</pre></li><li><p><strong>中断引脚</strong>：</p><ul><li>STM32的USART模块支持多种中断模式，如接收中断（RXNE），发送中断（TXE）等。当USART接收到数据或发送完成时，会触发中断。</li></ul></li></ol><hr /><h4><a name='header-n1600' class='md-header-anchor '></a>7.3.3 USART编程模式</h4><p>USART模块的编程模式包括配置USART外设、设置波特率、数据位、停止位、校验位、启用/禁用接收和发送中断等。开发者通常通过设置USART的控制寄存器（CR1、CR2、CR3）来控制USART模块的行为。</p><h5><a name='header-n1603' class='md-header-anchor '></a>1. <strong>配置USART波特率</strong>：</h5><p>波特率是串行通信的基础，决定了数据传输的速率。在STM32中，波特率通常通过BRR寄存器配置。波特率由时钟频率（如APB时钟）和BRR寄存器的值共同确定。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_BRR = (APB_CLOCK / USART_BAUDRATE);
</pre><h5><a name='header-n1607' class='md-header-anchor '></a>2. <strong>配置USART传输模式（同步/异步）</strong>：</h5><ul><li><strong>异步模式</strong>：配置<code>USART_CR1</code>寄存器中的<code>USART_MODE</code>为发送/接收模式。</li><li><strong>同步模式</strong>：配置同步模式时需要额外的时钟线和时钟极性设置。</li></ul><h5><a name='header-n1615' class='md-header-anchor '></a>3. <strong>启用USART模块</strong>：</h5><p>使用<code>USART_Cmd</code>函数启用USART模块，使能数据的发送与接收。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_Cmd(USART1, ENABLE);
</pre><h5><a name='header-n1619' class='md-header-anchor '></a>4. <strong>发送数据</strong>：</h5><p>发送数据时，可以将数据写入数据寄存器（<code>DR</code>），并通过TX引脚发送数据。发送完成后，TXE标志会被置为1，表示发送缓冲区为空，准备发送下一个数据。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_SendData(USART1, data);
while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
</pre><h5><a name='header-n1623' class='md-header-anchor '></a>5. <strong>接收数据</strong>：</h5><p>接收数据时，接收到的数据会存储在<code>DR</code>寄存器中，RXNE标志被置为1，表示数据已准备好被读取。</p><pre class="md-fences mock-cm md-end-block" lang="">if (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) != RESET) {
    receivedData = USART_ReceiveData(USART1);
}
</pre><h5><a name='header-n1627' class='md-header-anchor '></a>6. <strong>启用中断模式</strong>：</h5><p>STM32的USART模块可以配置为中断模式，以便在数据接收或发送完成时触发中断。启用中断后，需要编写中断服务程序来处理数据。</p><p>启用接收中断：</p><pre class="md-fences mock-cm md-end-block" lang="">USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); // 启用接收中断
</pre><p>USART中断服务程序（接收数据）：</p><pre class="md-fences mock-cm md-end-block" lang="">void USART1_IRQHandler(void)
{
    if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    {
        uint8_t receivedByte = USART_ReceiveData(USART1);
        // 处理接收到的数据
        USART_ClearITPendingBit(USART1, USART_IT_RXNE); // 清除中断标志
    }
}
</pre><h5><a name='header-n1636' class='md-header-anchor '></a>7. <strong>错误检测</strong>：</h5><p>USART模块提供了错误检测功能，可以检测到如溢出错误（ORE）、帧错误（FE）等。发生错误时，需要清除错误标志并做相应处理。</p><pre class="md-fences mock-cm md-end-block" lang="">if (USART_GetFlagStatus(USART1, USART_FLAG_ORE) != RESET) {
    USART_ClearFlag(USART1, USART_FLAG_ORE); // 清除溢出错误标志
}
</pre><h5><a name='header-n1640' class='md-header-anchor '></a>8. <strong>DMA模式</strong>：</h5><p>USART还支持与DMA一起工作，可以在不使用中断的情况下进行数据传输。这对于需要高效传输大量数据的应用非常有用。</p><p>启用USART的DMA支持：</p><pre class="md-fences mock-cm md-end-block" lang="">USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE);  // 启用DMA发送
USART_DMACmd(USART1, USART_DMAReq_Rx, ENABLE);  // 启用DMA接收
</pre><hr /><h3><a name='header-n1647' class='md-header-anchor '></a>总结</h3><p>STM32的USART模块是嵌入式系统中常用的串行通信</p><h3><a name='header-n1650' class='md-header-anchor '></a>7.4 USART标准外设库接口函数及应用</h3><p>STM32的USART模块提供了标准外设库接口函数，简化了USART的配置与操作，帮助开发者高效地进行串口通信应用的开发。标准外设库提供的接口函数可以帮助配置USART的波特率、数据格式、发送与接收功能、流控制等。下面我们将详细介绍USART标准外设库接口函数及其应用实例。</p><hr /><h4><a name='header-n1654' class='md-header-anchor '></a>7.4.1 USART标准外设库接口函数</h4><p>USART的标准外设库提供了多种接口函数用于配置和操作USART模块。以下是一些常用的USART库函数。</p><h5><a name='header-n1657' class='md-header-anchor '></a>1. <strong>USART初始化与配置</strong></h5><ul><li><p><code>USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)</code>
配置USART的波特率、数据位、停止位、校验位、传输模式等。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_InitTypeDef USART_InitStructure;
USART_InitStructure.USART_BaudRate = 9600;           // 设置波特率为9600
USART_InitStructure.USART_WordLength = USART_WordLength_8b; // 8位数据
USART_InitStructure.USART_StopBits = USART_StopBits_1;    // 1位停止位
USART_InitStructure.USART_Parity = USART_Parity_No;        // 无校验位
USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; // 启用发送与接收功能
USART_Init(USART1, &amp;USART_InitStructure);
</pre></li><li><p><code>USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)</code>
启用或禁用USART外设。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_Cmd(USART1, ENABLE); // 启用USART1
</pre></li></ul><h4><a name='header-n1669' class='md-header-anchor '></a>2. <strong>USART发送与接收数据</strong>4</h4><ul><li><p><code>USART_SendData(USART_TypeDef* USARTx, uint16_t Data)</code>
发送一个字节的数据。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_SendData(USART1, 'A'); // 发送字符'A'
</pre></li><li><p><code>USART_ReceiveData(USART_TypeDef* USARTx)</code>
接收一个字节的数据。</p><pre class="md-fences mock-cm md-end-block" lang="">uint8_t receivedData = USART_ReceiveData(USART1); // 接收数据
</pre></li></ul><h4><a name='header-n1681' class='md-header-anchor '></a>3. <strong>USART标志和中断</strong></h4><ul><li><p><code>USART_GetFlagStatus(USART_TypeDef* USARTx, USART_FLAG Flag)</code>
获取USART模块的标志位状态，如接收缓冲区是否为空（RXNE）等。</p><pre class="md-fences mock-cm md-end-block" lang="">if (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) != RESET) {
    uint8_t receivedByte = USART_ReceiveData(USART1); // 接收数据
}
</pre></li><li><p><code>USART_ITConfig(USART_TypeDef* USARTx, USART_IT USART_IT, FunctionalState NewState)</code>
配置USART中断。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); // 启用接收中断
</pre></li><li><p><code>USART_ClearITPendingBit(USART_TypeDef* USARTx, USART_IT USART_IT)</code>
清除USART中断待处理标志。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_ClearITPendingBit(USART1, USART_IT_RXNE); // 清除接收中断标志
</pre></li></ul><h4><a name='header-n1698' class='md-header-anchor '></a>4. <strong>波特率设置</strong></h4><ul><li><pre class="md-fences mock-cm md-end-block" lang="">USART_SetBaudRate(USART_TypeDef* USARTx, uint32_t BaudRate)
</pre><p>​</p><p>设置USART波特率。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_SetBaudRate(USART1, 9600); // 设置波特率为9600
</pre></li></ul><h4><a name='header-n1707' class='md-header-anchor '></a>5. <strong>流控制</strong></h4><ul><li><pre class="md-fences mock-cm md-end-block" lang="">USART_HardwareFlowControlCmd(USART_TypeDef* USARTx, FunctionalState NewState)
</pre><p>​</p><p>启用或禁用USART的硬件流控制（RTS/CTS）。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_HardwareFlowControlCmd(USART1, ENABLE); // 启用硬件流控制
</pre></li></ul><hr /><h3><a name='header-n1717' class='md-header-anchor '></a>7.4.2 USART串口应用编程步骤</h3><p>开发一个简单的USART串口通信应用通常需要以下几个步骤：</p><h5><a name='header-n1720' class='md-header-anchor '></a>1. <strong>使能USART时钟</strong></h5><p>首先，需要使能USART外设的时钟。以USART1为例：</p><pre class="md-fences mock-cm md-end-block" lang="">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
</pre><h5><a name='header-n1724' class='md-header-anchor '></a>2. <strong>配置GPIO引脚</strong></h5><p>USART的TX和RX引脚通常是复用引脚，需要配置为相应的复用模式。例如配置PA9和PA10为USART1的TX和RX：</p><pre class="md-fences mock-cm md-end-block" lang="">GPIO_InitTypeDef GPIO_InitStructure;
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  // 使能GPIOA时钟

// 配置TX引脚
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

// 配置RX引脚
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
</pre><h5><a name='header-n1728' class='md-header-anchor '></a>3. <strong>配置USART参数</strong></h5><p>通过<code>USART_Init</code>函数配置USART的波特率、数据位、停止位和校验位等。</p><pre class="md-fences mock-cm md-end-block" lang="">USART_InitTypeDef USART_InitStructure;
USART_InitStructure.USART_BaudRate = 9600;
USART_InitStructure.USART_WordLength = USART_WordLength_8b;
USART_InitStructure.USART_StopBits = USART_StopBits_1;
USART_InitStructure.USART_Parity = USART_Parity_No;
USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
USART_Init(USART1, &amp;USART_InitStructure);
</pre><h5><a name='header-n1732' class='md-header-anchor '></a>4. <strong>启用USART</strong></h5><p>配置完成后，启用USART模块，使其开始工作：</p><pre class="md-fences mock-cm md-end-block" lang="">USART_Cmd(USART1, ENABLE);
</pre><h5><a name='header-n1736' class='md-header-anchor '></a>5. <strong>发送和接收数据</strong></h5><p>通过<code>USART_SendData</code>发送数据，通过<code>USART_ReceiveData</code>接收数据。</p><pre class="md-fences mock-cm md-end-block" lang="">// 发送数据
USART_SendData(USART1, 'A');
while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);

// 接收数据
if (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) != RESET) {
    uint8_t receivedData = USART_ReceiveData(USART1);
}
</pre><h5><a name='header-n1740' class='md-header-anchor '></a>6. <strong>启用USART中断（可选）</strong></h5><p>可以配置USART接收中断，使得每当接收到数据时，触发中断服务程序（ISR）进行处理：</p><pre class="md-fences mock-cm md-end-block" lang="">USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
</pre><p>在中断服务程序中接收数据：</p><pre class="md-fences mock-cm md-end-block" lang="">void USART1_IRQHandler(void) {
    if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
        uint8_t receivedByte = USART_ReceiveData(USART1);
        USART_ClearITPendingBit(USART1, USART_IT_RXNE); // 清除中断标志
    }
}
</pre><hr /><h4><a name='header-n1748' class='md-header-anchor '></a>7.4.3 USART标准外设库应用实例</h4><p>下面是一个基于STM32的简单USART应用实例，其中包含了USART的基本配置、数据发送和接收功能。</p><h5><a name='header-n1751' class='md-header-anchor '></a>应用场景</h5><p>通过USART1与PC进行串口通信，当接收到数据时，LED灯的状态会发生变化。</p><h5><a name='header-n1754' class='md-header-anchor '></a>代码实现</h5><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include "stm32f10x.h"

void GPIO_Config(void) {
    GPIO_InitTypeDef GPIO_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    // 配置TX引脚（PA9）
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    
    // 配置RX引脚（PA10）
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
}

void USART_Config(void) {
    USART_InitTypeDef USART_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    
    // 配置USART
    USART_InitStructure.USART_BaudRate = 9600;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
    USART_Init(USART1, &amp;USART_InitStructure);
    
    // 启用USART1
    USART_Cmd(USART1, ENABLE);
}

void USART_SendChar(uint8_t c) {
    USART_SendData(USART1, c);
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
}

uint8_t USART_ReceiveChar(void) {
    while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
    return USART_ReceiveData(USART1);
}

int main(void) {
    GPIO
</pre><p>_Config(); // 配置GPIO引脚USART_Config(); // 配置USART</p><pre class="md-fences mock-cm md-end-block" lang="">while (1) {
    uint8_t receivedData = USART_ReceiveChar(); // 接收数据
    if (receivedData == '1') {
        GPIO_SetBits(GPIOA, GPIO_Pin_1); // 点亮LED
    } else if (receivedData == '0') {
        GPIO_ResetBits(GPIOA, GPIO_Pin_1); // 熄灭LED
    }
    USART_SendChar(receivedData); // 回显接收到的数据
}
</pre><p>}</p><hr /><h3><a name='header-n1762' class='md-header-anchor '></a>总结</h3><p>STM32的USART模块通过标准外设库提供了丰富的接口函数，简化了串口通信的配置与应用开发。通过合理配置USART的波特率、数据格式、停止位等参数，可以实现可靠的串口通信应用。结合中断和DMA功能，可以进一步优化应用的性能和响应能力。</p><h2><a name='header-n1765' class='md-header-anchor '></a>第8章 DMA</h2><h3><a name='header-n1766' class='md-header-anchor '></a>8.1 DMA基础理论知识</h3><p>DMA（Direct Memory Access，直接存储器访问）是一种允许外设直接与内存交换数据的技术，无需CPU干预。通过DMA，可以在不占用CPU资源的情况下，实现高效的内存数据传输，显著提高数据传输速度，降低CPU的负担。DMA常用于需要高速传输大数据量的场景，如音视频处理、传感器数据采集等。</p><h5><a name='header-n1769' class='md-header-anchor '></a>1. <strong>DMA的工作原理</strong></h5><ul><li>DMA允许外设或内存之间的数据直接传输，无需CPU介入。</li><li>通过DMA控制器（DMA Controller）进行数据的传输，CPU负责配置DMA控制器。</li><li>传输过程中，DMA控制器会根据预设的传输条件（如数据量、源地址、目标地址等）进行数据的传送。</li></ul><h5><a name='header-n1780' class='md-header-anchor '></a>2. <strong>DMA的优势</strong></h5><ul><li><strong>减轻CPU负担</strong>：由于数据传输不需要CPU干预，CPU可以执行其他任务。</li><li><strong>提高数据传输速度</strong>：DMA能够在更短时间内完成数据传输，特别适合高速数据传输。</li><li><strong>降低能耗</strong>：通过减少CPU工作负担，DMA可以降低系统的能耗。</li></ul><h5><a name='header-n1791' class='md-header-anchor '></a>3. <strong>DMA的主要组成</strong></h5><ul><li><strong>DMA控制器</strong>：负责管理DMA传输。</li><li><strong>通道</strong>：DMA控制器有多个通道，每个通道可以处理一个数据传输任务。</li><li><strong>源地址和目标地址</strong>：配置数据传输的起始地址和目标地址。</li><li><strong>数据长度</strong>：配置传输的数据量。</li><li><strong>传输方向</strong>：配置数据的传输方向（内存到外设，外设到内存，内存到内存等）。</li></ul><h5><a name='header-n1808' class='md-header-anchor '></a>4. <strong>DMA传输类型</strong></h5><ul><li><strong>内存到外设</strong>（Memory to Peripheral）</li><li><strong>外设到内存</strong>（Peripheral to Memory）</li><li><strong>内存到内存</strong>（Memory to Memory）</li></ul><hr /><h3><a name='header-n1820' class='md-header-anchor '></a>8.2 STM32的DMA模块</h3><p>STM32微控制器的DMA模块与外设和内存之间的数据传输密切相关，支持多种模式和功能，能够显著提高数据传输效率。在STM32中，DMA控制器通常与多个外设（如USART、SPI、I2C、ADC等）结合使用，实现高速的数据交换。</p><h4><a name='header-n1823' class='md-header-anchor '></a>8.2.1 DMA内部结构</h4><p>STM32的DMA模块通常包含多个DMA通道，每个通道可以配置为与不同的外设或内存进行数据传输。DMA控制器的内部结构包括以下几个关键部分：</p><ol start='' ><li><p><strong>DMA控制器</strong>：</p><ul><li>STM32的DMA控制器负责管理DMA的所有传输任务，并根据配置的传输类型进行数据传送。</li><li>每个DMA控制器支持多个DMA通道。每个通道负责处理一对源地址和目标地址之间的数据传输。</li></ul></li><li><p><strong>DMA通道</strong>：</p><ul><li>每个DMA通道可以与一个外设（例如USART、ADC等）或内存进行数据传输。</li><li>每个通道可以配置为内存到外设、外设到内存、内存到内存等不同传输方向。</li><li>每个通道支持不同的传输模式，如单次传输、循环传输等。</li></ul></li><li><p><strong>DMA流</strong>：</p><ul><li>在某些STM32系列（例如STM32F4）中，DMA通道可以进一步划分为多个流，流和通道的配置可以分别管理不同的传输任务。</li></ul></li><li><p><strong>配置寄存器</strong>：</p><ul><li>DMA控制器包含多个配置寄存器，允许开发者配置传输的数据量、源地址、目标地址、数据宽度等参数。</li><li>例如，DMA的传输控制寄存器（DMA_CCR）控制着数据传输的各个方面，如传输方向、传输模式等。</li></ul></li><li><p><strong>DMA状态寄存器</strong>：</p><ul><li>DMA控制器还包含状态寄存器，用于监控DMA传输的状态，标志传输是否完成或是否发生错误。</li></ul></li></ol><h4><a name='header-n1874' class='md-header-anchor '></a>8.2.2 DMA优先权</h4><p>DMA控制器支持配置不同DMA通道的优先权，以确定在多个DMA通道同时请求数据传输时，哪些通道获得优先服务。DMA优先权配置对于确保重要外设的数据传输及时性至关重要。</p><p>STM32的DMA优先级通常有两种级别：高优先级和低优先级。通过配置DMA的优先级寄存器，可以为每个DMA通道分配不同的优先级。</p><p>优先级设置有两种方式：</p><ol start='' ><li><strong>固定优先级</strong>：DMA控制器按照优先级顺序处理多个通道的请求，较高优先级的通道优先进行数据传输。</li><li><strong>轮询优先级</strong>：DMA控制器按顺序处理各个通道的请求，没有固定的优先级。每次DMA通道请求时，系统会轮流响应。</li></ol><p>优先级的设置可以影响系统中多个DMA请求的响应顺序。例如，当多个外设通过DMA进行数据传输时，优先级较高的外设可以获得更快的传输速度。</p><h4><a name='header-n1890' class='md-header-anchor '></a>8.2.3 DMA中断请求</h4><p>在DMA数据传输过程中，可以使用中断来通知CPU传输的状态。例如，当传输完成时，DMA控制器会触发中断请求，CPU可以根据中断信号进行后续处理。DMA模块支持多种中断请求，包括：</p><ol start='' ><li><p><strong>传输完成中断（TC）</strong>：</p><ul><li>当DMA传输完成时，DMA控制器会触发传输完成中断。开发者可以在中断服务程序中进行后续处理。</li></ul></li><li><p><strong>传输错误中断（TE）</strong>：</p><ul><li>当DMA传输发生错误时，DMA控制器会触发传输错误中断。错误可能包括地址溢出、数据位错误等。</li></ul></li><li><p><strong>半传输中断（HT）</strong>：</p><ul><li>当DMA传输到一半时，触发半传输中断。可以用于实时数据处理应用，如音频处理、视频处理等。</li></ul></li><li><p><strong>FIFO溢出中断（FO）</strong>：</p><ul><li>当DMA的FIFO（先进先出）缓冲区溢出时，触发FIFO溢出中断。FIFO溢出通常发生在数据流速过快的情况下，DMA缓冲区未能及时处理数据。</li></ul></li></ol><h5><a name='header-n1922' class='md-header-anchor '></a>配置DMA中断：</h5><ol start='' ><li><p><strong>使能DMA中断</strong>：</p><ul><li>使用<code>DMA_ITConfig()</code>函数使能DMA的相关中断：</li></ul><pre class="md-fences mock-cm md-end-block" lang="">DMA_ITConfig(DMA1_Channel1, DMA_IT_TC, ENABLE);  // 启用传输完成中断
</pre></li><li><p><strong>中断服务程序（ISR）</strong>：</p><ul><li>在中断服务程序中，可以处理DMA传输完成或错误等事件：</li></ul><pre class="md-fences mock-cm md-end-block" lang="">void DMA1_Channel1_IRQHandler(void) {
    if (DMA_GetITStatus(DMA1_IT_TC1)) { // 判断是否为传输完成中断
        DMA_ClearITPendingBit(DMA1_IT_TC1); // 清除中断标志
        // 处理DMA传输完成事件
    }
}
</pre></li><li><p><strong>清除中断标志</strong>：</p><ul><li>在中断处理函数中，需要清除DMA中断标志，以确保系统可以响应后续的中断请求：</li></ul><pre class="md-fences mock-cm md-end-block" lang="">DMA_ClearITPendingBit(DMA1_IT_TC1);  // 清除传输完成中断标志
</pre></li></ol><p>通过使用DMA中断，开发者可以在传输完成时获得通知，避免CPU不断轮询DMA状态，从而节省系统资源。</p><hr /><h3><a name='header-n1951' class='md-header-anchor '></a>总结</h3><p>DMA（直接存储器访问）是STM32微控制器中用于高效数据传输的关键功能，能够实现外设与内存之间的数据交换而无需占用CPU时间。通过合理配置DMA的优先级、传输方向和中断请求，可以优化系统的数据传输效率和响应速度。DMA广泛应用于音频处理、图像处理、数据采集等需要高效数据传输的场景。STM32的DMA模块具有强大的灵活性和配置选项，可以满足不同的应用需求。</p><h3><a name='header-n1954' class='md-header-anchor '></a>8.3 DMA标准外设库接口函数及应用</h3><h4><a name='header-n1955' class='md-header-anchor '></a>8.3.1 DMA标准外设库接口函数</h4><p>DMA（Direct Memory Access，直接内存存取）是用于在外设和内存之间直接传输数据的一种机制，能够有效减少CPU的干预，提高数据传输效率。在STM32等嵌入式平台中，DMA通常通过标准外设库来配置和管理。以下是DMA标准外设库的主要接口函数。</p><h5><a name='header-n1958' class='md-header-anchor '></a>1. <strong>DMA初始化函数</strong></h5><ul><li><p><em>DMA_Init(DMA_Channel_TypeDef DMA_Channel, DMA_InitTypeDef</em> DMA_InitStruct)**
用于初始化DMA通道的配置。主要配置源地址、目标地址、数据传输方向、数据大小等。</p></li><li><p><strong>参数说明：</strong></p><ul><li><code>DMA_Channel</code>: 需要初始化的DMA通道（如DMA1_Channel1）。</li><li><code>DMA_InitStruct</code>: 配置结构体，包含了DMA的配置项（传输方向、数据大小、循环模式等）。</li></ul></li></ul><h5><a name='header-n1974' class='md-header-anchor '></a>2. <strong>DMA配置结构体</strong></h5><ul><li><p>DMA_InitTypeDef</p><p>​</p><p>配置DMA通道的结构体，包含以下主要字段：</p><ul><li><code>DMA_PeripheralBaseAddr</code>: 外设基地址。</li><li><code>DMA_MemoryBaseAddr</code>: 内存基地址。</li><li><code>DMA_DIR</code>: 数据传输方向（从外设到内存，或从内存到外设）。</li><li><code>DMA_BufferSize</code>: 数据传输的字节数。</li><li><code>DMA_PeripheralDataSize</code>: 外设数据宽度。</li><li><code>DMA_MemoryDataSize</code>: 内存数据宽度。</li><li><code>DMA_Mode</code>: 传输模式（正常模式、循环模式）。</li><li><code>DMA_Priority</code>: DMA传输优先级。</li><li><code>DMA_FIFOMode</code>: FIFO模式使能。</li></ul></li></ul><h5><a name='header-n2011' class='md-header-anchor '></a>3. <strong>DMA启动函数</strong></h5><ul><li><p>*DMA_Cmd(DMA_Channel_TypeDef DMA_Channel, FunctionalState NewState)**
启动或停止DMA传输。</p></li><li><p><strong>参数说明：</strong></p><ul><li><code>DMA_Channel</code>: DMA通道。</li><li><code>NewState</code>: 启动DMA传输（<code>ENABLE</code>）或停止（<code>DISABLE</code>）。</li></ul></li></ul><h5><a name='header-n2027' class='md-header-anchor '></a>4. <strong>DMA中断配置函数</strong></h5><ul><li><p>*DMA_ITConfig(DMA_Channel_TypeDef DMA_Channel, DMA_IT_TypeDef DMA_IT, FunctionalState NewState)**
配置DMA中断，设置DMA传输完成或错误时触发中断。</p></li><li><p><strong>参数说明：</strong></p><ul><li><code>DMA_Channel</code>: DMA通道。</li><li><code>DMA_IT</code>: DMA中断类型，如传输完成中断、传输错误中断等。</li><li><code>NewState</code>: 启用（<code>ENABLE</code>）或禁用（<code>DISABLE</code>）中断。</li></ul></li></ul><h5><a name='header-n2046' class='md-header-anchor '></a>5. <strong>DMA标志检查与清除</strong></h5><ul><li>*DMA_GetFlagStatus(DMA_Channel_TypeDef DMA_Channel, uint32_t DMA_FLAG)**
检查DMA标志，确定DMA传输是否完成。</li><li>*DMA_ClearFlag(DMA_Channel_TypeDef DMA_Channel, uint32_t DMA_FLAG)**
清除DMA传输完成的标志。</li><li>*DMA_GetITStatus(DMA_Channel_TypeDef DMA_Channel, DMA_IT_TypeDef DMA_IT)**
检查DMA中断状态。</li><li>*DMA_ClearITPendingBit(DMA_Channel_TypeDef DMA_Channel, DMA_IT_TypeDef DMA_IT)**
清除DMA中断挂起位。</li></ul><h4><a name='header-n2064' class='md-header-anchor '></a>8.3.2 DMA标准外设库应用编程步骤</h4><p>使用DMA时，一般需要按照以下步骤进行编程：</p><ol start='' ><li><p><strong>配置DMA通道</strong>：</p><ul><li>首先，初始化DMA通道的配置结构体（<code>DMA_InitTypeDef</code>），设置数据源、数据目标、数据大小等。</li><li>调用<code>DMA_Init()</code>函数将配置应用到指定的DMA通道。</li></ul></li><li><p><strong>配置外设</strong>：</p><ul><li>配置外设（例如ADC、SPI、USART等）进行DMA传输。外设通常需要启用DMA支持，并配置相应的DMA请求。</li></ul></li><li><p><strong>启用DMA</strong>：</p><ul><li>调用<code>DMA_Cmd()</code>函数启动DMA传输。</li></ul></li><li><p><strong>配置DMA中断（可选）</strong>：</p><ul><li>如果需要在DMA传输完成后进行处理，可以配置DMA中断。启用相应的中断，设置中断服务程序。</li></ul></li><li><p><strong>等待DMA传输完成</strong>：</p><ul><li>使用<code>DMA_GetFlagStatus()</code>检查DMA传输是否完成，或在中断服务程序中处理传输完成事件。</li></ul></li><li><p><strong>清除DMA标志和中断</strong>：</p><ul><li>DMA传输完成后，需要清除DMA标志和中断挂起位，准备下一次传输。</li></ul></li></ol><h4><a name='header-n2113' class='md-header-anchor '></a>8.3.3 DMA标准外设库应用实例</h4><p>以下是一个简单的DMA应用实例，演示如何使用DMA将数据从内存传输到外设。</p><h5><a name='header-n2116' class='md-header-anchor '></a>示例：使用DMA将数据从内存传输到USART</h5><ol start='' ><li><strong>初始化DMA通道</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">DMA_InitTypeDef DMA_InitStructure;
DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&amp;USART1-&gt;DR;  // 外设基地址
DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)txBuffer;         // 内存基地址
DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;             // 数据传输方向：内存到外设
DMA_InitStructure.DMA_BufferSize = sizeof(txBuffer);               // 传输数据的字节数
DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;                       // 正常模式
DMA_InitStructure.DMA_Priority = DMA_Priority_High;                 // 高优先级
DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;              // 禁用FIFO
DMA_Init(DMA1_Channel4, &amp;DMA_InitStructure);  // 初始化DMA通道
</pre><ol start='' ><li><strong>配置USART外设以支持DMA传输</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE);  // 启用USART的DMA传输请求
</pre><ol start='' ><li><strong>启动DMA传输</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">DMA_Cmd(DMA1_Channel4, ENABLE);  // 启动DMA传输
</pre><ol start='' ><li><strong>等待传输完成</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">while (DMA_GetFlagStatus(DMA1_FLAG_TC4) == RESET);  // 等待传输完成
</pre><ol start='' ><li><strong>清除DMA标志</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">DMA_ClearFlag(DMA1_FLAG_TC4);  // 清除传输完成标志
</pre><p>在这个例子中，数据通过DMA从<code>txBuffer</code>传输到USART1的数据寄存器。当传输完成时，DMA会自动停止传输。</p><p>以上是一个简单的DMA应用，实际应用中，DMA通常用于更复杂的操作，如数据采集、音频传输等。</p><h2><a name='header-n2146' class='md-header-anchor '></a>第9章 定时器</h2><p>定时器是嵌入式系统中非常重要的外设之一，广泛应用于产生延时、生成PWM信号、测量时间间隔等。STM32的定时器模块具有多个功能，可以根据需要配置为不同的定时器类型。</p><h3><a name='header-n2149' class='md-header-anchor '></a>9.1 STM32定时器模块</h3><p>STM32系列微控制器提供了多种类型的定时器，包括通用定时器、基本定时器和高级定时器。每种定时器都有其独特的功能，适用于不同的应用场景。</p><h4><a name='header-n2152' class='md-header-anchor '></a>9.1.1 通用定时器</h4><p>通用定时器（General-purpose timers）是STM32中最常用的一类定时器，适用于一般的定时、计数、PWM输出等应用。</p><h6><a name='header-n2155' class='md-header-anchor '></a>功能特点：</h6><ul><li><strong>计数模式</strong>：可以配置为向上计数、向下计数或向上/向下计数。</li><li><strong>PWM输出</strong>：可以用于生成PWM信号，用于控制电机、LED调光等。</li><li><strong>输入捕获</strong>：可以用于测量信号的周期、频率等参数。</li><li><strong>输出比较</strong>：可以根据设定的阈值产生定时中断，进行某些任务的触发。</li><li><strong>死区时间控制</strong>：可用于双通道的PWM输出，控制通道之间的死区时间。</li></ul><h6><a name='header-n2172' class='md-header-anchor '></a>常见的通用定时器：</h6><ul><li><strong>TIM2、TIM3、TIM4、TIM5</strong> 等，这些定时器可以在各种模式下工作，如普通定时模式、PWM模式、输入捕获模式等。</li></ul><h6><a name='header-n2177' class='md-header-anchor '></a>典型应用：</h6><ul><li>定时器1和定时器2常用于产生PWM信号控制电机或LED亮度。</li><li>定时器3和定时器4可以用作输入捕获模式，测量外部信号的频率。</li></ul><h6><a name='header-n2185' class='md-header-anchor '></a>配置实例（PWM输出）：</h6><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">// 1. 初始化定时器
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_TimeBaseStructure.TIM_Period = 999;  // 设置PWM周期
TIM_TimeBaseStructure.TIM_Prescaler = 71;  // 设置预分频器
TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure);

// 2. 配置PWM输出模式
TIM_OCInitTypeDef TIM_OCInitStructure;
TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
TIM_OCInitStructure.TIM_Pulse = 499;  // 设置占空比
TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);

// 3. 启动定时器
TIM_Cmd(TIM2, ENABLE);
TIM_CtrlPWMOutputs(TIM2, ENABLE);
</pre><h4><a name='header-n2187' class='md-header-anchor '></a>9.1.2 基本定时器</h4><p>基本定时器（Basic timers）通常用于较简单的定时和计数任务。它们没有PWM功能，也没有输入捕获和输出比较功能，主要用于产生定时中断。</p><h6><a name='header-n2190' class='md-header-anchor '></a>功能特点：</h6><ul><li><strong>定时功能</strong>：最简单的计时器，主要用于生成定时中断。</li><li><strong>简化的配置</strong>：不支持PWM输出、输入捕获等复杂功能。</li><li><strong>单通道模式</strong>：没有高级定时器或通用定时器那样的多个通道支持。</li></ul><h6><a name='header-n2201' class='md-header-anchor '></a>常见的基本定时器：</h6><ul><li><strong>TIM6、TIM7</strong> 等，这些定时器只能提供最基本的定时功能，通常用于产生固定时间间隔的中断。</li></ul><h6><a name='header-n2206' class='md-header-anchor '></a>典型应用：</h6><ul><li>用于延时生成、系统节拍（SysTick）等。</li><li>在某些低功耗应用中，基本定时器也可以在低功耗模式下运行，节省能源。</li></ul><h6><a name='header-n2214' class='md-header-anchor '></a>配置实例（定时中断）：</h6><pre class="md-fences mock-cm md-end-block" lang="">// 1. 配置基本定时器
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_TimeBaseStructure.TIM_Period = 999;  // 设置定时器周期
TIM_TimeBaseStructure.TIM_Prescaler = 71;  // 设置定时器预分频器
TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
TIM_TimeBaseInit(TIM6, &amp;TIM_TimeBaseStructure);

// 2. 启动定时器
TIM_Cmd(TIM6, ENABLE);
</pre><h4><a name='header-n2216' class='md-header-anchor '></a>9.1.3 高级定时器</h4><p>高级定时器（Advanced-control timers）主要用于需要精确控制和多个输出通道的应用。它们提供了更加复杂的功能，适用于电机控制、复杂PWM生成等应用。</p><h6><a name='header-n2219' class='md-header-anchor '></a>功能特点：</h6><ul><li><strong>高精度PWM输出</strong>：支持多个输出通道，适用于电机控制等高精度场景。</li><li><strong>死区时间控制</strong>：支持通道之间的死区时间，避免输出信号之间的短路。</li><li><strong>输入捕获与输出比较</strong>：支持高级的输入捕获与输出比较功能。</li><li><strong>多通道PWM输出</strong>：支持生成多个通道的PWM信号。</li><li><strong>反向PWM</strong>：可以控制PWM信号的反向输出。</li></ul><h6><a name='header-n2236' class='md-header-anchor '></a>常见的高级定时器：</h6><ul><li><strong>TIM1、TIM8</strong> 等，这些定时器具有多种高级功能，包括死区时间控制、双通道输出比较等。</li></ul><h6><a name='header-n2241' class='md-header-anchor '></a>典型应用：</h6><ul><li>电机控制：使用多通道PWM输出。</li><li>精密计时：应用于需要多个输出信号控制的系统。</li><li>高精度PWM和双通道输出，应用于高功率设备控制。</li></ul><h6><a name='header-n2252' class='md-header-anchor '></a>配置实例（双通道PWM输出）：</h6><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">// 1. 配置高级定时器
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_TimeBaseStructure.TIM_Period = 999;  // 设置PWM周期
TIM_TimeBaseStructure.TIM_Prescaler = 71;  // 设置预分频器
TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseStructure);

// 2. 配置PWM输出
TIM_OCInitTypeDef TIM_OCInitStructure;
TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
TIM_OCInitStructure.TIM_Pulse = 499;  // 设置占空比
TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
TIM_OC1Init(TIM1, &amp;TIM_OCInitStructure);
TIM_OC2Init(TIM1, &amp;TIM_OCInitStructure);

// 3. 启动定时器
TIM_Cmd(TIM1, ENABLE);
TIM_CtrlPWMOutputs(TIM1, ENABLE);
</pre><h3><a name='header-n2254' class='md-header-anchor '></a>总结：</h3><ul><li><strong>通用定时器</strong>：适用于一般计时、PWM输出、输入捕获和输出比较。</li><li><strong>基本定时器</strong>：功能简单，适用于仅需要定时中断的应用。</li><li><strong>高级定时器</strong>：具有复杂功能，适用于电机控制、精确PWM输出等高精度控制的场景。</li></ul><h3><a name='header-n2265' class='md-header-anchor '></a>9.2 定时器标准外设库接口函数及应用</h3><p>STM32的定时器模块提供了丰富的功能，通过标准外设库接口函数可以轻松地进行配置和控制。以下是关于定时器的标准外设库接口函数、应用编程步骤和实例。</p><h4><a name='header-n2268' class='md-header-anchor '></a>9.2.1 定时器标准外设库接口函数</h4><p>定时器的标准外设库函数主要用于定时器的初始化、启动、配置模式、生成PWM输出、设置中断等功能。以下是定时器相关的标准外设库接口函数。</p><h5><a name='header-n2271' class='md-header-anchor '></a>1. <strong>定时器初始化函数</strong></h5><ul><li><p><strong>TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</strong>
用于初始化定时器的基本配置，如计数模式、预分频、自动重载值（周期）等。</p></li><li><p><strong>参数说明：</strong></p><ul><li><code>TIMx</code>: 指定的定时器（如<code>TIM1</code>, <code>TIM2</code>等）。</li><li><code>TIM_TimeBaseInitStruct</code>: 配置结构体，包含计数模式、预分频、自动重载值等。</li></ul></li><li><p><strong>配置结构体 TIM_TimeBaseInitTypeDef</strong>：</p><ul><li><code>TIM_Period</code>: 自动重载值，控制定时器计数周期。</li><li><code>TIM_Prescaler</code>: 预分频器，设置时钟频率。</li><li><code>TIM_ClockDivision</code>: 时钟分频，设置计数时钟的分频系数。</li><li><code>TIM_CounterMode</code>: 计数模式（向上计数、向下计数、向上/向下计数）。</li><li><code>TIM_RepetitionCounter</code>: 重复计数器，用于高级定时器的死区时间控制。</li></ul></li></ul><h5><a name='header-n2306' class='md-header-anchor '></a>2. <strong>定时器输出比较和PWM配置</strong></h5><ul><li><p><strong>TIM_OCInit(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</strong>
配置定时器的输出比较模式，可以用于PWM输出、比较事件等。</p></li><li><p><strong>参数说明：</strong></p><ul><li><code>TIMx</code>: 指定的定时器（如<code>TIM1</code>, <code>TIM2</code>等）。</li><li><code>TIM_OCInitStruct</code>: 配置输出比较的结构体，包含工作模式、占空比等。</li></ul></li><li><p><strong>配置结构体 TIM_OCInitTypeDef</strong>：</p><ul><li><code>TIM_OCMode</code>: 输出比较模式（如PWM模式、正向/反向PWM）。</li><li><code>TIM_OutputState</code>: 输出状态（使能或禁用）。</li><li><code>TIM_Pulse</code>: 输出比较值，用于控制PWM的占空比。</li><li><code>TIM_OCPolarity</code>: 输出极性（高电平或低电平）。</li></ul></li></ul><h5><a name='header-n2338' class='md-header-anchor '></a>3. <strong>定时器中断配置函数</strong></h5><ul><li><strong>TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)</strong>
配置定时器中断，使能或禁用特定的中断源（如更新中断、捕获中断等）。</li><li><strong>TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)</strong>
清除定时器的标志位，通常用于清除定时器溢出等标志。</li><li><strong>TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)</strong>
清除定时器的中断挂起位，通常在中断服务函数中使用。</li></ul><h5><a name='header-n2352' class='md-header-anchor '></a>4. <strong>定时器启动和停止</strong></h5><ul><li><strong>TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)</strong>
启动或停止指定的定时器。</li><li><strong>TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)</strong>
启用或禁用定时器的PWM输出，适用于高级定时器和通用定时器。</li></ul><h4><a name='header-n2362' class='md-header-anchor '></a>9.2.2 定时器标准外设库应用编程步骤</h4><p>使用STM32定时器时，应用编程通常按照以下步骤进行：</p><ol start='' ><li><p><strong>配置定时器基础参数</strong>：</p><ul><li>选择合适的定时器（如<code>TIM1</code>、<code>TIM2</code>等）。</li><li>配置定时器的计数模式（向上计数、向下计数等）、预分频器、自动重载值等。</li><li>调用<code>TIM_TimeBaseInit()</code>函数初始化定时器基础配置。</li></ul></li><li><p><strong>配置定时器输出比较或PWM</strong>：</p><ul><li>如果需要PWM输出，配置定时器的输出比较模式，设置占空比等参数。</li><li>调用<code>TIM_OCInit()</code>函数配置PWM或输出比较模式。</li></ul></li><li><p><strong>配置定时器中断（如果需要）</strong>：</p><ul><li>如果需要在定时器溢出或其他事件发生时进行中断处理，配置定时器中断源。</li><li>使用<code>TIM_ITConfig()</code>使能中断，配置中断优先级和中断服务函数。</li></ul></li><li><p><strong>启动定时器</strong>：</p><ul><li>调用<code>TIM_Cmd()</code>启动定时器。</li><li>对于PWM输出，使用<code>TIM_CtrlPWMOutputs()</code>使能PWM输出。</li></ul></li><li><p><strong>处理中断（如果需要）</strong>：</p><ul><li>在中断服务函数中处理定时器中断，清除中断标志或执行其他操作。</li></ul></li><li><p><strong>清除标志位（如果需要）</strong>：</p><ul><li>在中断服务程序或主程序中使用<code>TIM_ClearFlag()</code>和<code>TIM_ClearITPendingBit()</code>清除标志位和中断挂起位。</li></ul></li></ol><h4><a name='header-n2423' class='md-header-anchor '></a>9.2.3 定时器标准外设库应用实例</h4><p>以下是一个典型的应用实例，展示如何使用定时器产生PWM信号，控制一个LED的亮度。</p><h5><a name='header-n2426' class='md-header-anchor '></a>示例：使用TIM2生成PWM信号控制LED亮度</h5><ol start='' ><li><strong>初始化定时器2</strong>（TIM2）：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_TimeBaseStructure.TIM_Period = 999;  // PWM周期 (频率)
TIM_TimeBaseStructure.TIM_Prescaler = 71;  // 预分频器 (定时器频率)
TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure);
</pre><ol start='' ><li><strong>配置PWM输出通道1</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">TIM_OCInitTypeDef TIM_OCInitStructure;
TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;  // PWM模式
TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
TIM_OCInitStructure.TIM_Pulse = 499;  // 占空比 (50%)
TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;  // 正极性
TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);
</pre><ol start='' ><li><strong>启动定时器2</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">TIM_Cmd(TIM2, ENABLE);  // 启动定时器
TIM_CtrlPWMOutputs(TIM2, ENABLE);  // 启用PWM输出
</pre><ol start='' ><li><strong>改变占空比</strong>（动态调整亮度）：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">// 修改占空比为75%
TIM_SetCompare1(TIM2, 749);  // 占空比 = 749 / 999
</pre><ol start='' ><li><strong>清除中断标志（如果需要）</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET) {
    // 处理溢出事件
    TIM_ClearITPendingBit(TIM2, TIM_IT_Update);  // 清除更新中断标志
}
</pre><h4><a name='header-n2452' class='md-header-anchor '></a>解释：</h4><ul><li><strong>PWM输出</strong>：定时器2生成一个PWM信号，控制LED的亮度。通过调整<code>TIM_OCInitStructure.TIM_Pulse</code>值，可以改变PWM的占空比，从而控制LED的亮度。</li><li><strong>定时器配置</strong>：通过<code>TIM_TimeBaseInit()</code>设置定时器周期（<code>TIM_Period</code>）和预分频器（<code>TIM_Prescaler</code>），确保定时器的频率符合应用要求。</li><li><strong>动态调整</strong>：通过<code>TIM_SetCompare1()</code>动态修改占空比，改变LED的亮度。</li></ul><h4><a name='header-n2463' class='md-header-anchor '></a>总结：</h4><ul><li><strong>定时器的应用编程</strong>包括初始化、配置PWM或输出比较模式、配置中断、启动定时器等步骤。</li><li>使用定时器进行PWM输出控制是非常常见的应用，尤其在电机控制、LED调光等场景中。</li><li>通过定时器的标准外设库接口函数，可以轻松实现各种定时功能，提供高效和精确的定时控制。</li></ul><h3><a name='header-n2474' class='md-header-anchor '></a>9.4 PWM（脉宽调制）</h3><p>PWM（Pulse Width Modulation，脉宽调制）是一种通过调节信号的高电平持续时间（即占空比）来控制功率输出的技术。它广泛应用于电机控制、亮度调节、音频信号生成等多个领域。STM32微控制器通过其定时器模块提供了丰富的PWM输出功能，可以通过标准外设库（Standard Peripheral Library）或HAL库进行配置和使用。</p><h4><a name='header-n2477' class='md-header-anchor '></a>9.4.1 PWM的工作原理</h4><p>PWM的基本原理是通过调节周期内信号高电平（ON）的时间占整个周期的比例来控制输出功率。周期内的高电平时间越长，占空比（Duty Cycle）就越大，输出的平均功率也就越大。</p><ul><li><strong>周期（Period）</strong>：PWM信号的周期是指信号从一个完整周期的开始到下一个周期的开始所经过的时间。周期通常用秒（s）来表示。</li><li><strong>占空比（Duty Cycle）</strong>：占空比是高电平的持续时间与整个周期时间的比值，通常用百分比表示。例如，占空比为50%的PWM信号表示高电平持续时间占整个周期的50%。</li></ul><p>例如：</p><ul><li><strong>占空比 0%</strong>：信号一直处于低电平。</li><li><strong>占空比 50%</strong>：高电平和低电平各占周期的一半。</li><li><strong>占空比 100%</strong>：信号一直处于高电平。</li></ul><h5><a name='header-n2499' class='md-header-anchor '></a>PWM的输出信号：</h5><ul><li><strong>频率（Frequency）</strong>：频率是周期的倒数，单位为赫兹（Hz）。它决定了PWM信号切换的速度。</li><li><strong>占空比（Duty Cycle）</strong>：占空比越大，信号的平均功率越高。</li></ul><h4><a name='header-n2507' class='md-header-anchor '></a>9.4.2 PWM的标准外设库应用实例</h4><p>在STM32中，使用标准外设库来实现PWM输出的步骤通常包括定时器的初始化、配置PWM输出模式、设置占空比等。以下是一个简单的PWM输出实例，使用STM32的定时器（例如TIM2）来产生PWM信号。</p><h5><a name='header-n2510' class='md-header-anchor '></a>1. <strong>初始化定时器2</strong>（作为PWM生成器）</h5><pre class="md-fences mock-cm md-end-block" lang="">// 定时器2的基础配置
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_TimeBaseStructure.TIM_Period = 999;  // 设置PWM周期，周期为1000个时钟周期
TIM_TimeBaseStructure.TIM_Prescaler = 71;  // 设置预分频器，分频系数为72（定时器时钟为72 MHz）
TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  // 向上计数模式
TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure);
</pre><h5><a name='header-n2512' class='md-header-anchor '></a>2. <strong>配置PWM输出通道1</strong>（使用TIM2的通道1生成PWM）</h5><pre class="md-fences mock-cm md-end-block" lang="">// 配置定时器2的通道1为PWM模式
TIM_OCInitTypeDef TIM_OCInitStructure;
TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;  // PWM模式
TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
TIM_OCInitStructure.TIM_Pulse = 499;  // 设置PWM的占空比为50%（499/999）
TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;  // 正极性
TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);
</pre><h5><a name='header-n2514' class='md-header-anchor '></a>3. <strong>启动定时器2并使能PWM输出</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">// 启动定时器2
TIM_Cmd(TIM2, ENABLE);
// 启用PWM输出
TIM_CtrlPWMOutputs(TIM2, ENABLE);
</pre><h5><a name='header-n2516' class='md-header-anchor '></a>4. <strong>动态调整PWM占空比</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">// 设置占空比为75%（750/999）
TIM_SetCompare1(TIM2, 750);  // 修改比较值以调节占空比
</pre><h4><a name='header-n2518' class='md-header-anchor '></a>9.4.3 PWM的HAL库应用实例</h4><p>HAL库（硬件抽象层）提供了更加简洁的接口来配置和控制硬件外设。使用HAL库配置PWM的过程与标准外设库类似，但接口更简单、易于理解。以下是一个使用HAL库产生PWM信号的例子，假设使用TIM2通道1来生成PWM信号。</p><h5><a name='header-n2521' class='md-header-anchor '></a>1. <strong>初始化定时器2</strong>（作为PWM生成器）</h5><pre class="md-fences mock-cm md-end-block" lang="">// 定义定时器的句柄
TIM_HandleTypeDef htim2;

// 初始化定时器2
htim2.Instance = TIM2;
htim2.Init.Prescaler = 71;  // 设置预分频器
htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
htim2.Init.Period = 999;  // 设置PWM周期
htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_PWM_Init(&amp;htim2) != HAL_OK) {
    // 错误处理
}
</pre><h5><a name='header-n2523' class='md-header-anchor '></a>2. <strong>配置PWM输出通道1</strong>（使用TIM2的通道1生成PWM）</h5><pre class="md-fences mock-cm md-end-block" lang="">// 配置PWM的参数
TIM_OC_InitTypeDef sConfigOC;
sConfigOC.OCMode = TIM_OCMODE_PWM1;  // PWM模式
sConfigOC.Pulse = 499;  // 占空比50%（499/999）
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;  // 正极性
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
if (HAL_TIM_PWM_ConfigChannel(&amp;htim2, &amp;sConfigOC, TIM_CHANNEL_1) != HAL_OK) {
    // 错误处理
}
</pre><h5><a name='header-n2525' class='md-header-anchor '></a>3. <strong>启动PWM输出</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">// 启动PWM输出
if (HAL_TIM_PWM_Start(&amp;htim2, TIM_CHANNEL_1) != HAL_OK) {
    // 错误处理
}
</pre><h5><a name='header-n2527' class='md-header-anchor '></a>4. <strong>动态调整PWM占空比</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">// 设置占空比为75%（750/999）
__HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, 750);  // 修改比较值以调节占空比
</pre><h4><a name='header-n2529' class='md-header-anchor '></a>解释：</h4><ul><li><strong>初始化定时器</strong>：首先通过<code>HAL_TIM_PWM_Init()</code>初始化定时器，并配置时钟、预分频器、自动重载值等。</li><li><strong>配置PWM通道</strong>：通过<code>HAL_TIM_PWM_ConfigChannel()</code>设置PWM模式、占空比、极性等参数。</li><li><strong>启动PWM输出</strong>：使用<code>HAL_TIM_PWM_Start()</code>启动PWM输出。</li><li><strong>动态调整占空比</strong>：使用<code>__HAL_TIM_SET_COMPARE()</code>动态调整PWM占空比，从而改变输出信号的高电平持续时间。</li></ul><h3><a name='header-n2543' class='md-header-anchor '></a>总结：</h3><ul><li><strong>PWM的工作原理</strong>是通过改变占空比来调节输出的平均功率，在很多控制应用中，如电机驱动、LED调光等，PWM技术是非常重要的。</li><li><strong>标准外设库</strong>和<strong>HAL库</strong>提供了简单的接口来配置和使用PWM。标准外设库功能较为底层，提供更多控制选项，而HAL库则对外设进行了更高层次的封装，简化了开发过程。</li><li>通过定时器模块，STM32能够非常方便地实现PWM信号的产生，并且可以动态调整PWM信号的占空比，满足不同的应用需求。</li></ul><h3><a name='header-n2554' class='md-header-anchor '></a>9.5 SysTick定时器</h3><p>SysTick定时器是STM32微控制器中的一个内置定时器，通常用于实现系统时基、产生定时中断或用于调度任务。SysTick定时器是一个24位的递增定时器，通常用于操作系统的时间管理、产生节拍信号等。SysTick定时器的时钟来源通常是系统时钟（如HCLK或MCLK），并且它能够产生定时中断。</p><h4><a name='header-n2557' class='md-header-anchor '></a>9.5.1 SysTick标准外设库函数</h4><p>SysTick定时器的标准外设库提供了几个重要的函数，用于配置和控制SysTick定时器。以下是常用的标准外设库函数：</p><ol start='' ><li><p><strong>SysTick_Config(uint32_t Ticks)</strong></p><ul><li><p>配置SysTick定时器。</p></li><li><p>参数说明</p><p>：</p><ul><li><code>Ticks</code>: 定时器计数的初始值，表示SysTick定时器的重载值，即定时器中断的周期。该值通常是系统时钟频率与需要的延迟时间的商。</li></ul></li><li><p><strong>功能</strong>：配置SysTick定时器，使其根据系统时钟周期自动计数，并在计数达到指定的<code>Ticks</code>值时触发中断。</p></li></ul></li><li><p><strong>SysTick-&gt;CTRL</strong></p><ul><li>控制SysTick定时器的启用、定时源和中断使能。可以设置SysTick的不同工作模式。</li><li>通过修改SysTick的控制寄存器<code>CTRL</code>，可以使能/禁用SysTick定时器、选择时钟源（HCLK或内部时钟）和使能中断。</li></ul></li><li><p><strong>SysTick-&gt;LOAD</strong></p><ul><li>设置SysTick定时器的重载值，即计数周期。</li></ul></li><li><p><strong>SysTick-&gt;VAL</strong></p><ul><li>读取SysTick定时器当前的计数值。</li></ul></li><li><p><strong>SysTick-&gt;CTRL &amp; SysTick_CTRL_COUNTFLAG_Msk</strong></p><ul><li>检查SysTick定时器是否已经完成一个周期，返回计数标志。</li></ul></li><li><p><strong>SysTick_CLKSourceConfig(SysTick_CLKSource)</strong></p><ul><li>配置SysTick时钟源，可以选择内部时钟或外部时钟。</li></ul></li></ol><h4><a name='header-n2618' class='md-header-anchor '></a>9.5.2 SysTick标准外设库应用实例</h4><p>SysTick定时器的常见应用包括实现延时函数、定时器中断生成等。以下是一个使用SysTick定时器来生成定时中断的例子。</p><h5><a name='header-n2621' class='md-header-anchor '></a>示例：使用SysTick实现定时中断</h5><ol start='' ><li><strong>配置SysTick定时器并启动</strong></li></ol><pre class="md-fences mock-cm md-end-block" lang="">// 配置SysTick定时器以每1ms触发一次中断
SysTick_Config(SystemCoreClock / 1000);  // 系统时钟频率除以1000，得到1ms的定时周期
</pre><ol start='' ><li><strong>SysTick中断服务程序</strong></li></ol><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">// SysTick中断处理函数
void SysTick_Handler(void)
{
    // 每次SysTick中断发生时执行此函数
    // 例如，增加1ms的计数，或执行其他周期性任务
    static uint32_t msCounter = 0;
    msCounter++;

    // 每1000ms（1秒）时，切换LED状态
    if (msCounter &gt;= 1000) {
        msCounter = 0;
        // 切换LED状态
        HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);
    }
}
</pre><ol start='' ><li><strong>中断优先级设置（可选）</strong></li></ol><p>在一些情况下，可能需要设置SysTick中断的优先级。例如，在使用FreeRTOS时，可能需要调整中断的优先级来与RTOS的任务调度配合。</p><pre class="md-fences mock-cm md-end-block" lang="">// 设置SysTick中断的优先级（如果需要）
NVIC_SetPriority(SysTick_IRQn, 1);  // 设置SysTick中断的优先级为1（较低）
</pre><ol start='' ><li><strong>清除SysTick中断标志</strong></li></ol><p>如果需要手动清除SysTick中断标志（通常在中断服务函数中），可以通过读取<code>SysTick-&gt;CTRL</code>寄存器来清除中断标志。</p><pre class="md-fences mock-cm md-end-block" lang="">// 清除SysTick中断标志
if (SysTick-&gt;CTRL &amp; SysTick_CTRL_COUNTFLAG_Msk) {
    // 执行相关操作
}
</pre><h3><a name='header-n2646' class='md-header-anchor '></a>9.6 编程思想之状态机设计思想</h3><p>状态机（State Machine）是一种常用于嵌入式系统开发中的编程思想，尤其适用于处理多种不同状态和事件的应用。状态机通过一组状态及其转换规则来控制程序的执行流，通常用于任务调度、协议解析、设备控制等应用场景。</p><h5><a name='header-n2649' class='md-header-anchor '></a>状态机的基本概念</h5><ol start='' ><li><strong>状态（State）</strong>：表示系统的某种特定情况或条件。每个状态可能有特定的行为、输出或执行某个操作。</li><li><strong>事件（Event）</strong>：引起状态变化的触发因素，事件可以是外部输入（如传感器数据、按键输入）或系统内部的条件（如计时器溢出）。</li><li><strong>状态转换（Transition）</strong>：根据某个事件，系统从一个状态转移到另一个状态。每个状态之间的转换有一定的条件和动作。</li><li><strong>状态机表</strong>：通常使用一个状态转换表来记录每个状态与事件的对应关系。这张表定义了在某个特定状态下，遇到特定事件时应该转移到哪个状态，并且可能会执行某个特定的动作。</li></ol><h5><a name='header-n2663' class='md-header-anchor '></a>状态机的设计步骤</h5><ol start='' ><li><strong>确定状态</strong>：首先，明确系统的所有可能状态，并为每个状态定义一个唯一的标识符。</li><li><strong>确定事件</strong>：定义所有可能引起状态变化的事件。例如，按钮按下、传感器值变化、计时器到期等。</li><li><strong>确定状态转换规则</strong>：为每个状态定义在不同事件下的状态转换规则，并明确转换条件和执行的动作。</li><li><strong>实现状态机逻辑</strong>：编写代码来表示状态机的状态、事件、转换规则和动作。通常使用<code>switch-case</code>或<code>if-else</code>语句来实现状态的切换和事件的处理。</li></ol><h5><a name='header-n2677' class='md-header-anchor '></a>示例：简单的LED控制状态机</h5><p>假设我们设计一个LED控制系统，LED有两种状态：开和关。系统通过按键输入来切换LED的状态。</p><ol start='' ><li><strong>定义状态</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">typedef enum {
    LED_OFF = 0,
    LED_ON
} LED_State;
</pre><ol start='' ><li><strong>定义事件</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">typedef enum {
    BUTTON_PRESSED = 0
} Event;
</pre><ol start='' ><li><strong>定义状态机</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">LED_State currentState = LED_OFF;  // 初始状态为LED关

void LED_StateMachine(Event event) {
    switch (currentState) {
        case LED_OFF:
            if (event == BUTTON_PRESSED) {
                currentState = LED_ON;  // 按钮按下时切换到LED开
                HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);  // 打开LED
            }
            break;
        case LED_ON:
            if (event == BUTTON_PRESSED) {
                currentState = LED_OFF;  // 按钮按下时切换到LED关
                HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);  // 关闭LED
            }
            break;
        default:
            break;
    }
}
</pre><ol start='' ><li><strong>调用状态机</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">// 在主循环或定时中断中，根据按键输入调用状态机
if (buttonPressed) {
    LED_StateMachine(BUTTON_PRESSED);
}
</pre><h5><a name='header-n2700' class='md-header-anchor '></a>状态机的优势</h5><ol start='' ><li><strong>清晰的控制逻辑</strong>：状态机将复杂的控制逻辑分解为状态和事件，使得程序更易于理解和维护。</li><li><strong>灵活性</strong>：状态机可以轻松地扩展新的状态和事件。例如，如果需要增加一个新的LED闪烁状态，只需添加新的状态并定义相应的事件处理规则。</li><li><strong>可测试性</strong>：状态机的每个状态和事件可以独立地进行测试，确保程序逻辑的正确性。</li><li><strong>响应性</strong>：状态机能够快速响应外部事件（如按键、传感器变化等），并根据状态转换规则执行适当的操作。</li></ol><h5><a name='header-n2714' class='md-header-anchor '></a>总结</h5><ul><li><strong>SysTick定时器</strong>是一个重要的硬件定时器，常用于产生系统时基、实现延时或定时任务。通过配置SysTick定时器和编写相应的中断服务程序，可以实现精确的时间控制。</li><li><strong>状态机设计思想</strong>是嵌入式系统中常用的一种编程方法，它通过明确定义的状态、事件和状态转换规则来控制程序的执行流程。状态机简化了程序设计，特别适合处理多状态、多事件的应用，如任务调度、设备控制等。</li></ul><h2><a name='header-n2722' class='md-header-anchor '></a>第10章 模拟数字转换（ADC）</h2><p>模拟数字转换（Analog-to-Digital Conversion，简称ADC）是将连续的模拟信号（例如电压）转换为离散的数字信号的过程。STM32系列微控制器内置了高性能的ADC模块，可以用于各种传感器的信号采集、数字信号处理等应用。</p><h3><a name='header-n2725' class='md-header-anchor '></a>10.1 ADC基础理论知识</h3><p>模拟信号通常是连续的，而数字信号则是离散的。ADC的主要作用是将输入的模拟信号转换为可以由数字处理单元（如微控制器）处理的数字信号。通过采样和量化过程，ADC可以实现这一转换。</p><h4><a name='header-n2728' class='md-header-anchor '></a>10.1.1 A/D转换过程</h4><p>A/D转换过程可以分为以下几个步骤：</p><ol start='' ><li><p><strong>采样（Sampling）</strong></p><ul><li>采样过程是将连续的模拟信号在特定的时间点进行离散化。在此过程中，模拟信号在每个采样时刻被读取并保持在一个固定值。</li><li>采样定理：为了避免失真，采样频率必须至少是信号最高频率的两倍（奈奎斯特定理）。这个频率被称为采样率。</li></ul></li><li><p><strong>保持（Hold）</strong></p><ul><li>在采样之后，模拟信号的值会被保持在一个固定的电压上，直到转换完成。保持电路通常使用采样保持电容来存储模拟信号的电压。</li></ul></li><li><p><strong>量化（Quantization）</strong></p><ul><li>量化是将模拟信号的幅度转换为一个有限的离散值。量化的精度由ADC的分辨率决定，通常用“位数”来表示。例如，12位ADC的量化范围是从0到212−1=40952^{12}-1 = 4095。</li><li>量化误差（或量化噪声）是由于模拟信号的幅度值不能精确地映射到数字值所产生的误差。</li></ul></li><li><p><strong>编码（Encoding）</strong></p><ul><li>在编码步骤中，量化后的离散值会被转换为二进制数字。这些二进制数字可以被数字系统进一步处理或存储。</li></ul></li><li><p><strong>数字输出</strong></p><ul><li>最终，ADC的输出是一个数字信号，表示模拟信号在采样时刻的幅度。这个数字信号可以直接用于数字计算或通过接口传输到其他系统。</li></ul></li></ol><h4><a name='header-n2773' class='md-header-anchor '></a>10.1.2 A/D转换的主要技术参数</h4><p>在选择和设计ADC时，有几个关键参数需要考虑，这些参数决定了ADC的性能和适用性：</p><ol start='' ><li><p><strong>分辨率（Resolution）</strong></p><ul><li>分辨率是ADC可以表示的数字输出的位数，通常以“位”表示。例如，12位ADC的分辨率为212=40962^{12} = 4096个离散值。</li><li>分辨率越高，ADC能够捕捉到的信号细节就越多，转换的精度也就越高。</li></ul></li><li><p><strong>转换速率（Conversion Rate）</strong></p><ul><li>转换速率是ADC每秒钟完成多少次转换的速率，通常以“样本/秒”（SPS）或“赫兹”（Hz）来衡量。</li><li>在高转换速率下，ADC能够快速地对输入信号进行采样，适用于高速信号处理应用。但同时，高速采样可能增加功耗。</li></ul></li><li><p><strong>输入范围（Input Range）</strong></p><ul><li>输入范围定义了ADC能够正确转换的模拟输入信号的电压范围。常见的输入范围包括0到Vref（参考电压）或- Vref/2到Vref/2（对称范围）。</li><li>输入范围的选择直接影响到模拟信号的采样精度。</li></ul></li><li><p><strong>参考电压（Reference Voltage，Vref）</strong></p><ul><li>参考电压是ADC的基准电压，用于确定输入信号的最大可转换电压。ADC的最大数字输出值通常对应于参考电压。</li><li>如果输入信号的电压超过参考电压，ADC将无法正确转换该信号。因此，参考电压的选择对ADC的转换范围和精度至关重要。</li></ul></li><li><p><strong>采样时间（Sampling Time）</strong></p><ul><li>采样时间是ADC用于采样输入模拟信号的时间。采样时间越长，输入信号的稳定性越好，从而提高转换精度。</li><li>采样时间与ADC的转换精度密切相关，通常需要根据输入信号的特性进行调整。</li></ul></li><li><p><strong>转换精度（Conversion Accuracy）</strong></p><ul><li>转换精度是指ADC输出结果与实际模拟信号之间的误差。该误差受到ADC的分辨率、量化噪声以及参考电压精度等因素的影响。</li></ul></li><li><p><strong>输入阻抗（Input Impedance）</strong></p><ul><li>输入阻抗是指ADC输入端的电阻，影响输入信号源与ADC之间的匹配。如果输入阻抗过高，可能会导致信号衰减或采样误差。</li></ul></li><li><p><strong>采样保持时间（Sample-and-Hold Time）</strong></p><ul><li>采样保持时间是ADC在采样阶段对输入信号进行采样并将其保持的时间。短的保持时间可能导致输入信号不稳定，从而影响转换精度。</li></ul></li><li><p><strong>线性度（Linearity）</strong></p><ul><li>线性度表示ADC输出值与输入信号之间的关系是否一致。理想的ADC输出应与输入信号成线性关系，任何偏差都被视为非线性误差。</li></ul></li><li><p><strong>信号噪声（Signal Noise）</strong></p><ul><li>ADC的性能受输入信号噪声的影响。信号噪声会影响ADC的转换精度，因此在设计时需要考虑如何减少噪声影响，如使用滤波器等。</li></ul></li></ol><h3><a name='header-n2862' class='md-header-anchor '></a>总结</h3><ul><li><strong>ADC的基本过程</strong>：包括采样、保持、量化和编码，最终将模拟信号转换为数字信号。ADC的精度和转换速率是设计时的重要参数。</li><li><strong>主要技术参数</strong>：如分辨率、转换速率、参考电压、采样时间和输入阻抗等，直接影响ADC的性能和适用范围。在嵌入式系统中，合理配置这些参数非常关键，以满足不同应用的需求。</li></ul><h3><a name='header-n2870' class='md-header-anchor '></a>10.2 STM32的ADC</h3><p>STM32系列微控制器内置了高性能的ADC模块，支持多种转换模式、引脚选择、数据对齐方式等配置，适用于精密的模拟信号采集。STM32的ADC功能丰富，灵活性高，广泛应用于传感器接口、音频处理、信号测量等嵌入式应用中。</p><h4><a name='header-n2873' class='md-header-anchor '></a>10.2.1 ADC的引脚</h4><p>STM32的ADC模块通常有多个引脚可供选择用于模拟输入信号。不同的引脚可以映射到不同的ADC通道。ADC引脚分为以下几类：</p><ul><li><strong>标准输入引脚</strong>：这些引脚支持直接的模拟信号输入，通常是通过GPIO配置为模拟模式（Analog mode）来启用。</li><li><strong>特殊功能引脚</strong>：某些引脚具有多重功能，除了普通GPIO功能外，还可以用作ADC输入通道。</li><li><strong>内建传感器引脚</strong>：某些STM32微控制器还提供了内建的温度传感器、电压参考信号等输入，这些可以通过内置的ADC通道进行采集。</li></ul><p>例如：</p><ul><li><strong>STM32F4系列</strong>：引脚如<code>PA0</code>, <code>PA1</code>, <code>PA2</code>等都可以作为ADC输入引脚。</li><li><strong>STM32L4系列</strong>：支持更多的模拟输入通道，例如<code>PA0</code>到<code>PA15</code>等引脚。</li></ul><p>要选择特定的ADC引脚，通常需要在初始化过程中通过STM32的GPIO配置功能将相应引脚设置为模拟模式。</p><pre class="md-fences mock-cm md-end-block" lang="">// 配置PA0为模拟输入
GPIO_InitTypeDef GPIO_InitStruct = {0};
GPIO_InitStruct.Pin = GPIO_PIN_0;
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);
</pre><h4><a name='header-n2898' class='md-header-anchor '></a>10.2.2 ADC通道选择</h4><p>STM32的ADC模块支持多个通道，可以从不同的引脚或内部信号（如温度传感器）读取模拟信号。每个通道都可以独立配置。</p><ul><li><strong>通道选择</strong>：在STM32的ADC模块中，每个引脚通常都有一个与之对应的ADC通道。通道的选择是通过设置ADC通道的编号来实现的。</li><li><strong>通道顺序</strong>：多个通道可以按顺序依次转换，ADC的通道扫描模式（扫描模式）允许一次启动多个通道的转换。</li></ul><p>例如，STM32F4系列的ADC通道选择：</p><ul><li><code>ADC_CHANNEL_0</code> 对应引脚 <code>PA0</code></li><li><code>ADC_CHANNEL_1</code> 对应引脚 <code>PA1</code></li><li><code>ADC_CHANNEL_16</code> 对应内部温度传感器</li></ul><p>通过设置ADC的通道选择和顺序，可以采集多个模拟信号。</p><pre class="md-fences mock-cm md-end-block" lang="">// 配置ADC转换通道
ADC_ChannelConfig(ADC1, ADC_CHANNEL_0, ADC_SampleTime_15Cycles);
</pre><h4><a name='header-n2923' class='md-header-anchor '></a>10.2.3 ADC中断和DMA请求</h4><p>STM32的ADC模块支持中断和DMA请求，以便在ADC转换完成后进行处理。</p><ol start='' ><li><p><strong>ADC中断</strong>：ADC可以在转换完成后触发中断，应用程序可以通过中断服务程序（ISR）来处理数据，避免轮询。</p><p>配置ADC中断：</p><pre class="md-fences mock-cm md-end-block" lang="">// 启用ADC中断
HAL_NVIC_EnableIRQ(ADC_IRQn);
</pre><p>中断服务程序：</p><pre class="md-fences mock-cm md-end-block" lang="">void ADC_IRQHandler(void)
{
    if (__HAL_ADC_GET_FLAG(&amp;hadc1, ADC_FLAG_EOC)) {
        // 转换完成，读取数据
        uint32_t adcValue = HAL_ADC_GetValue(&amp;hadc1);
    }
}
</pre></li><li><p><strong>ADC DMA请求</strong>：ADC还支持直接存储器访问（DMA），用于将ADC转换结果直接传输到内存中，而无需通过CPU进行处理。DMA可以大大减少CPU负担，适合高速连续数据采集应用。</p><p>配置ADC使用DMA：</p><pre class="md-fences mock-cm md-end-block" lang="">HAL_ADC_Start_DMA(&amp;hadc1, adcBuffer, 10);  // 将结果存储到数组adcBuffer中
</pre><p>DMA中断服务程序：</p><pre class="md-fences mock-cm md-end-block" lang="">void DMA1_Stream1_IRQHandler(void)
{
    if (__HAL_DMA_GET_FLAG(&amp;hdma_adc1, DMA_FLAG_TCIF1_5)) {
        // DMA传输完成，处理数据
        HAL_DMA_CLEAR_FLAG(&amp;hdma_adc1, DMA_FLAG_TCIF1_5);
    }
}
</pre></li></ol><h4><a name='header-n2945' class='md-header-anchor '></a>10.2.4 ADC转换时间</h4><p>STM32的ADC转换时间由以下几个因素决定：</p><ul><li><strong>采样时间</strong>：每个通道的采样时间，可以通过设置不同的采样周期来调节，常见的采样时间为1.5、7.5、15、28等多个选项。</li><li><strong>分辨率</strong>：ADC的分辨率（例如12位、10位）决定了每个采样周期内需要多少时间来完成转换。较高的分辨率意味着更长的转换时间。</li><li><strong>时钟频率</strong>：ADC时钟频率越高，转换速度越快。STM32的ADC时钟通常是系统时钟或外部时钟的一个分频。</li></ul><p>总的来说，转换时间是由ADC的分辨率、采样时间和ADC时钟频率共同决定的。</p><pre class="md-fences mock-cm md-end-block" lang="">// 设置ADC通道的采样时间
ADC_ChannelConfig(ADC1, ADC_CHANNEL_0, ADC_SampleTime_15Cycles);
</pre><h4><a name='header-n2961' class='md-header-anchor '></a>10.2.5 ADC数据对齐</h4><p>STM32的ADC模块支持两种数据对齐方式：<strong>右对齐</strong>和<strong>左对齐</strong>。</p><ul><li><strong>右对齐</strong>：ADC转换结果的低位被丢弃，数据存储在寄存器的低位部分。例如，12位ADC的结果会存储在数据寄存器的最低12位中。</li><li><strong>左对齐</strong>：ADC转换结果的高位被丢弃，数据存储在寄存器的高位部分。</li></ul><p>左对齐可以使得读取数据时直接获取最高有效位。</p><p>选择数据对齐方式：</p><pre class="md-fences mock-cm md-end-block" lang="">// 右对齐
ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
HAL_ADC_Init(&amp;hadc1);

// 左对齐
ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Left;
HAL_ADC_Init(&amp;hadc1);
</pre><h4><a name='header-n2976' class='md-header-anchor '></a>10.2.6 ADC的转换模式</h4><p>STM32支持多种ADC转换模式，适应不同的应用需求：</p><ol start='' ><li><strong>单次转换模式（Single Conversion Mode）</strong>：每次启动一个转换，转换完成后停止。</li><li><strong>连续转换模式（Continuous Conversion Mode）</strong>：在转换完成后自动启动下一个转换，适合实时数据采集应用。</li><li><strong>扫描模式（Scan Conversion Mode）</strong>：在多个通道之间依次切换并进行转换，适合多通道采集。</li><li><strong>触发模式（Triggered Conversion Mode）</strong>：通过外部信号或内部定时器触发ADC转换。</li></ol><p>设置转换模式：</p><pre class="md-fences mock-cm md-end-block" lang="">// 设置单次转换模式
ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
HAL_ADC_Init(&amp;hadc1);

// 设置连续转换模式
ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
HAL_ADC_Init(&amp;hadc1);
</pre><h4><a name='header-n2995' class='md-header-anchor '></a>10.2.7 ADC校准</h4><p>为了提高ADC的精度和准确性，STM32提供了内置的校准功能。校准通常包括温度传感器和内部参考电压的校准。</p><ol start='' ><li><strong>ADC校准过程</strong>：在启动ADC之前，可以进行一次或多次校准，以提高测量精度。STM32通常在启动时进行内置的自校准，尤其是对于高精度应用。</li><li><strong>校准寄存器</strong>：STM32通过特定的寄存器来进行自校准。校准操作可以通过标准库函数或HAL库来触发。</li></ol><pre class="md-fences mock-cm md-end-block" lang="">// 启动ADC校准
HAL_ADCEx_Calibration_Start(&amp;hadc1, ADC_CALIB_OFFSET);
</pre><h3><a name='header-n3006' class='md-header-anchor '></a>总结</h3><ul><li><strong>引脚选择和通道配置</strong>：STM32的ADC模块支持多个模拟输入引脚和通道，灵活的通道选择和配置可以实现多种应用。</li><li><strong>中断和DMA</strong>：通过中断和DMA功能，可以实现高效的数据处理和存储，减少CPU的负担。</li><li><strong>转换时间和精度</strong>：通过配置采样时间、分辨率和时钟频率，可以调节ADC的转换时间和精度。</li><li><strong>数据对齐和转换模式</strong>：STM32支持不同的数据对齐方式和转换模式，可以根据应用需求选择最适合的模式。</li><li><strong>校准</strong>：ADC的内建校准功能可以提高精度，确保转换结果的准确性。</li></ul><h4><a name='header-n3023' class='md-header-anchor '></a>10.3 ADC标准外设库接口函数及应用</h4><p>在STM32中，ADC模块的配置和操作可以通过标准外设库（Standard Peripheral Library）来实现。标准外设库提供了一系列的接口函数，使得ADC的配置、启动和读取过程更加简便。通过这些函数，用户可以高效地进行ADC采样、转换和数据处理。</p><h4><a name='header-n3026' class='md-header-anchor '></a>10.3.1 ADC标准外设库接口函数</h4><p>标准外设库为ADC模块提供了丰富的接口函数。以下是常用的ADC相关函数及其作用：</p><ol start='' ><li><p><strong>ADC初始化</strong></p><ul><li><code>ADC_Init()</code></li><li>该函数用于初始化ADC模块的配置，包括分辨率、数据对齐方式、扫描模式、连续转换模式等。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
</pre><p>该函数的参数：</p><ul><li><code>ADCx</code>：指定ADC的实例（如<code>ADC1</code>、<code>ADC2</code>）。</li><li><code>ADC_InitStruct</code>：包含ADC配置参数的结构体。</li></ul></li><li><p><strong>ADC通道配置</strong></p><ul><li><code>ADC_RegularChannelConfig()</code></li><li>该函数配置ADC的常规通道和采样时间，通常在使用多通道扫描模式时调用。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
</pre><p>参数说明：</p><ul><li><code>ADCx</code>：指定ADC的实例。</li><li><code>ADC_Channel</code>：指定要配置的通道。</li><li><code>Rank</code>：指定通道的排名。</li><li><code>ADC_SampleTime</code>：指定采样时间。</li></ul></li><li><p><strong>ADC转换启动</strong></p><ul><li><code>ADC_SoftwareStartConv()</code></li><li>启动ADC的转换操作，适用于单次或连续转换模式。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">void ADC_SoftwareStartConv(ADC_TypeDef* ADCx);
</pre><p>该函数启动ADC的常规转换。</p></li><li><p><strong>读取ADC值</strong></p><ul><li><code>ADC_GetConversionValue()</code></li><li>获取ADC转换后的结果。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);
</pre><p>返回值：ADC转换的结果，返回一个16位值。</p></li><li><p><strong>ADC校准</strong></p><ul><li><code>ADC_StartCalibration()</code></li><li>启动ADC的校准过程。校准可以提高ADC的精度，尤其是温度传感器和参考电压的测量精度。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">void ADC_StartCalibration(ADC_TypeDef* ADCx);
</pre><p>该函数启动ADC的自校准过程。</p></li><li><p><strong>ADC中断配置</strong></p><ul><li><code>ADC_ITConfig()</code></li><li>启用或禁用ADC中断，用于在转换完成后触发中断。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);
</pre><p>该函数的参数：</p><ul><li><code>ADCx</code>：指定ADC的实例。</li><li><code>ADC_IT</code>：指定ADC中断类型。</li><li><code>NewState</code>：启用或禁用中断。</li></ul></li><li><p><strong>ADC DMA配置</strong></p><ul><li><code>ADC_DMACmd()</code></li><li>启用或禁用DMA请求。使用DMA可以将ADC的转换结果直接传输到内存中，减少CPU的负担。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
</pre><p>该函数的参数：</p><ul><li><code>ADCx</code>：指定ADC的实例。</li><li><code>NewState</code>：启用或禁用DMA请求。</li></ul></li></ol><h4><a name='header-n3158' class='md-header-anchor '></a>10.3.2 ADC标准外设库应用编程步骤</h4><p>使用ADC进行数据采集时，应用程序通常会遵循以下步骤：</p><ol start='' ><li><p><strong>ADC外设时钟使能</strong></p><ul><li>在使用ADC之前，必须首先使能ADC外设的时钟。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
</pre></li><li><p><strong>GPIO配置为模拟输入</strong></p><ul><li>配置ADC输入引脚为模拟模式，禁用输入的上拉/下拉电阻。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">GPIO_InitTypeDef GPIO_InitStruct = {0};
GPIO_InitStruct.Pin = GPIO_PIN_0; // 例如PA0
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);
</pre></li><li><p><strong>配置ADC</strong></p><ul><li>使用<code>ADC_Init()</code>函数初始化ADC参数（分辨率、数据对齐、转换模式等）。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">ADC_InitTypeDef ADC_InitStruct = {0};
ADC_InitStruct.ADC_Resolution = ADC_Resolution_12b;
ADC_InitStruct.ADC_ScanConvMode = DISABLE;  // 单通道模式
ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;
ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;
ADC_InitStruct.ADC_NbrOfConversion = 1;  // 仅一个通道
ADC_Init(ADC1, &amp;ADC_InitStruct);
</pre></li><li><p><strong>配置ADC通道</strong></p><ul><li>使用<code>ADC_RegularChannelConfig()</code>函数配置ADC通道和采样时间。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">ADC_RegularChannelConfig(ADC1, ADC_CHANNEL_0, 1, ADC_SampleTime_15Cycles);
</pre></li><li><p><strong>启动ADC转换</strong></p><ul><li>启动ADC的转换过程。可以使用软件触发启动ADC，或者使用外部触发源。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">ADC_SoftwareStartConv(ADC1);
</pre></li><li><p><strong>等待转换完成</strong></p><ul><li>在单次转换模式下，需要等待转换完成后读取转换结果。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);
</pre></li><li><p><strong>读取ADC转换结果</strong></p><ul><li>使用<code>ADC_GetConversionValue()</code>函数获取ADC转换的结果。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">uint16_t adc_value = ADC_GetConversionValue(ADC1);
</pre></li><li><p><strong>关闭ADC</strong></p><ul><li>转换完成后，可以关闭ADC以节省功耗。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">ADC_Cmd(ADC1, DISABLE);
</pre></li></ol><h4><a name='header-n3226' class='md-header-anchor '></a>10.3.3 ADC标准外设库应用实例</h4><p>以下是一个完整的ADC应用实例，演示如何使用STM32的标准外设库采集模拟信号：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include "stm32f4xx.h"

void ADC1_Config(void) {
    // 1. 使能ADC1外设时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

    // 2. 配置PA0为模拟输入
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);

    // 3. 配置ADC
    ADC_InitTypeDef ADC_InitStruct = {0};
    ADC_InitStruct.ADC_Resolution = ADC_Resolution_12b;
    ADC_InitStruct.ADC_ScanConvMode = DISABLE;  // 单通道模式
    ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;
    ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;
    ADC_InitStruct.ADC_NbrOfConversion = 1;  // 仅一个通道
    ADC_Init(ADC1, &amp;ADC_InitStruct);

    // 4. 配置ADC通道0，采样时间15个周期
    ADC_RegularChannelConfig(ADC1, ADC_CHANNEL_0, 1, ADC_SampleTime_15Cycles);

    // 5. 启动ADC转换
    ADC_SoftwareStartConv(ADC1);
}

uint16_t Read_ADC_Value(void) {
    // 6. 等待转换完成
    while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);

    // 7. 获取ADC转换值
    return ADC_GetConversionValue(ADC1);
}

int main(void) {
    // 配置ADC
    ADC1_Config();

    // 读取ADC值
    uint16_t adc_value = Read_ADC_Value();

    // ADC值可以用于控制或者显示等操作
    while (1) {
        // 无限循环
    }
}
</pre><h3><a name='header-n3230' class='md-header-anchor '></a>总结</h3><ul><li><strong>ADC标准外设库接口函数</strong>：提供了配置、启动、读取ADC转换结果等常用操作函数。</li><li><strong>编程步骤</strong>：包括使能时钟、配置引脚、初始化ADC、启动转换、等待完成、读取结果等步骤。</li><li><strong>应用实例</strong>：通过配置ADC引脚和通道、启动转换并读取结果，可以轻松实现模拟信号采集功能。</li></ul></div>
</body>
</html>