<!doctype html>
<html>
<head>
    <style>
        .watermark {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            background-repeat: repeat;
            /* background-image: linear-gradient(45deg, rgba(0, 0, 0, 0.1) 0%, rgba(0, 0, 0, 0.1) 100%); */
        }
        
        .watermark::after {
            content: "菏泽学院 23物联网工程 QQ365938188";
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-45deg);
            font-size: 24px;
            color: rgba(0, 0, 0, 0.1);
            white-space: nowrap;
            letter-spacing: 5px;
        }
        </style>
        
       
        <div class="watermark"></div>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>Python.md</title><link href='https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}#write, body { height: auto; }
#write, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write ol, #write p, #write ul { position: relative; }
#write, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
.CodeMirror, .md-fences, table { text-align: left; }
.md-reset, a:active, a:hover { outline: 0px; }
.md-reset, .md-toc-item a { text-decoration: none; }
.MathJax_SVG, .md-reset { float: none; direction: ltr; }
:root { --bg-color:#ffffff; --text-color:#333333; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; }
.in-text-selection, ::selection { background: rgb(181, 214, 252); text-shadow: none; }
#write { margin: 0px auto; word-break: normal; word-wrap: break-word; padding-bottom: 70px; white-space: pre-wrap; overflow-x: visible; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
.typora-export #write { margin: 0px auto; }
#write > blockquote:first-child, #write > div:first-child, #write > ol:first-child, #write > p:first-child, #write > pre:first-child, #write > table:first-child, #write > ul:first-child { margin-top: 30px; }
#write li > table:first-child { margin-top: -20px; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
p { -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; }
.typora-export p { white-space: normal; }
.mathjax-block { margin-top: 0px; margin-bottom: 0px; -webkit-margin-before: 0px; -webkit-margin-after: 0px; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
#write > figure:first-child { margin-top: 16px; }
figure { overflow-x: auto; margin: -8px 0px 0px -8px; max-width: calc(100% + 16px); padding: 8px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; }
.CodeMirror-line, .md-fences { break-inside: avoid; }
table.md-table td { min-width: 80px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; margin-right: 4px; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
pre { white-space: pre-wrap; }
.md-fences { font-size: 0.9rem; display: block; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
.md-fences .CodeMirror.CodeMirror-wrap { top: -1.6em; margin-bottom: -1.6em; }
.md-fences.mock-cm { white-space: pre-wrap; }
.show-fences-line-number .md-fences { padding-left: 0px; }
.show-fences-line-number .md-fences.mock-cm { padding-left: 40px; }
.footnotes { opacity: 0.8; font-size: 0.9rem; padding-top: 1em; padding-bottom: 1em; }
.footnotes + .footnotes { margin-top: -1em; }
.md-reset { margin: 0px; padding: 0px; border: 0px; vertical-align: top; background: 0px 0px; text-shadow: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; }
.md-toc-inner, a img, img a { cursor: pointer; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: nowrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  h1, h2, h3, h4, h5, h6 { break-after: avoid-page; orphans: 2; }
  p { orphans: 4; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 1cm; padding-right: 1cm; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > img:only-child { display: block; margin: auto; }
.md-line > .md-image:only-child, p > .md-image:only-child { display: inline-block; width: 100%; text-align: center; }
.mathjax-block:not(:empty)::after, .md-toc-content::after, .md-toc::after { display: none; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.mathjax-block { white-space: pre; overflow: hidden; width: 100%; }
p + .mathjax-block { margin-top: -1.143rem; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.MathJax_SVG, .mathjax-block .MathJax_SVG_Display { text-indent: 0px; max-width: none; max-height: none; min-height: 0px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-inner:hover { }
.md-toc-inner { display: inline-block; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
.md-tag { opacity: 0.5; }
code, pre, tt { font-family: var(--monospace); }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; }
h1 .md-tag, h2 .md-tag, h3 .md-tag, h4 .md-tag, h5 .md-tag, h6 .md-tag { font-weight: initial; opacity: 0.35; }
a.md-print-anchor { border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.mathjax-block .MathJax_SVG_Display { text-align: center; margin: 1em 0px; position: relative; min-width: 100%; width: auto; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: monospace; }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; min-width: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.md-diagram-panel > svg, [lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }


.CodeMirror, .CodeMirror-sizer { position: relative; }
.CodeMirror.cm-s-inner { background: inherit; }
.fences-no-line-wrapping .md-fences .CodeMirror { margin-top: -30px; }
.CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; }
.CodeMirror-lines { padding: 4px 0px; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-scroll, .cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta, .cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error, .cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.CodeMirror { height: auto; overflow: hidden; }
.CodeMirror-scroll { margin-bottom: -30px; padding-bottom: 30px; height: 100%; outline: 0px; position: relative; box-sizing: content-box; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow-x: hidden; overflow-y: scroll; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow-y: hidden; overflow-x: scroll; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; border-right: none; width: 0px; visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.CodeMirror-selected { background: rgb(217, 217, 217); }
.CodeMirror-focused .CodeMirror-selected { background: rgb(215, 212, 240); }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}
.CodeMirror-lint-markers { width: 16px; }
.CodeMirror-lint-tooltip { background-color: infobackground; border: 1px solid rgb(0, 0, 0); border-radius: 4px; color: infotext; font-family: var(--monospace); overflow: hidden; padding: 2px 5px; position: fixed; white-space: pre-wrap; z-index: 10000; max-width: 600px; opacity: 0; transition: opacity 0.4s; font-size: 0.8em; }
.CodeMirror-lint-mark-error, .CodeMirror-lint-mark-warning { background-position: left bottom; background-repeat: repeat-x; }
.CodeMirror-lint-mark-error { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg=="); }
.CodeMirror-lint-marker-error, .CodeMirror-lint-marker-warning { background-position: center center; background-repeat: no-repeat; cursor: pointer; display: inline-block; height: 16px; width: 16px; vertical-align: middle; position: relative; }
.CodeMirror-lint-message-error, .CodeMirror-lint-message-warning { padding-left: 18px; background-position: left top; background-repeat: no-repeat; }
.CodeMirror-lint-marker-error, .CodeMirror-lint-message-error { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII="); }
.CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII="); }
.CodeMirror-lint-marker-multiple { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC"); background-repeat: no-repeat; background-position: right bottom; width: 100%; height: 100%; }


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
@font-face { font-family: "Open Sans"; font-style: normal; font-weight: normal; src: local("Open Sans Regular"), url("./github/400.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: italic; font-weight: normal; src: local("Open Sans Italic"), url("./github/400i.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: normal; font-weight: bold; src: local("Open Sans Bold"), url("./github/700.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: italic; font-weight: bold; src: local("Open Sans Bold Italic"), url("./github/700i.woff") format("woff"); }
html { font-size: 16px; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 20px 30px 100px; }
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
body > :first-child { margin-top: 0px !important; }
body > :last-child { margin-bottom: 0px !important; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 4px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border-width: 0px 0px 1px; border-style: none none solid; border-top-color: initial; border-right-color: initial; border-left-color: initial; border-image: initial; overflow: hidden; box-sizing: content-box; border-bottom-color: rgb(221, 221, 221); }
body > h2:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child + h2 { margin-top: 0px; padding-top: 0px; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child { margin-top: 0px; padding-top: 0px; }
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0px; padding-top: 0px; }
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p { margin-top: 0px; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 4px solid rgb(221, 221, 221); padding: 0px 15px; color: rgb(119, 119, 119); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border-top: 1px solid rgb(204, 204, 204); margin: 0px; padding: 0px; }
table tr:nth-child(2n) { background-color: rgb(248, 248, 248); }
table tr th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; text-align: left; margin: 0px; padding: 6px 13px; }
table tr td { border: 1px solid rgb(204, 204, 204); text-align: left; margin: 0px; padding: 6px 13px; }
table tr th:first-child, table tr td:first-child { margin-top: 0px; }
table tr th:last-child, table tr td:last-child { margin-bottom: 0px; }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); }
.md-fences, code, tt { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding: 8px 1em 6px; }
.md-task-list-item > input { margin-left: -1.3em; }
@media screen and (min-width: 914px) {
}
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; color: inherit; }
.md-tag { color: inherit; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
#md-notification::before { top: 10px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }
.html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; }






</style>
</head>
<body class='typora-export' >
<div  id='write'  class = 'is-node'><h1><a name='header-n0' class='md-header-anchor '></a>Python期末复习</h1><h6><a name='header-n2' class='md-header-anchor '></a>物联网工程 2023124306</h6><hr /><h2><a name='header-n4' class='md-header-anchor '></a><strong>第2章 Python程序实例解析</strong></h2><p>本章内容通过具体实例解析Python的基本语法、功能以及应用技巧，帮助学习者深入理解Python编程的核心概念。</p><h3><a name='header-n7' class='md-header-anchor '></a><strong>2.1 实例1：温度转换</strong></h3><p>温度转换是一个经典的Python实例，用于展示如何编写一个简单的程序来转换温度单位。我们将实现从摄氏度（Celsius）到华氏度（Fahrenheit）的转换，并反过来进行。</p><h5><a name='header-n10' class='md-header-anchor '></a><strong>温度转换公式：</strong></h5><ul><li>从摄氏度转换到华氏度的公式：F=C×95+32F = C \times \frac{9}{5} + 32</li><li>从华氏度转换到摄氏度的公式：C=(F−32)×59C = (F - 32) \times \frac{5}{9}</li></ul><h5><a name='header-n18' class='md-header-anchor '></a><strong>程序示例</strong>：</h5><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">def celsius_to_fahrenheit(celsius):</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return celsius * 9 / 5 + 32</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">def fahrenheit_to_celsius(fahrenheit):</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return (fahrenheit - 32) * 5 / 9</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"># 输入温度</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">temperature = float(input("请输入温度："))</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">unit = input("请输入单位（C代表摄氏度，F代表华氏度）：")</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">if unit == 'C':</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  print(f"{temperature} 摄氏度 = {celsius_to_fahrenheit(temperature)} 华氏度")</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">elif unit == 'F':</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  print(f"{temperature} 华氏度 = {fahrenheit_to_celsius(temperature)} 摄氏度")</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">else:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  print("输入的单位无效")</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 376px;"></div><div class="CodeMirror-gutters" style="display: none; height: 406px;"></div></div></div></pre><p>在这个实例中，<code>input()</code>函数用于接受用户输入，并根据输入的单位判断转换方向，输出转换后的结果。</p><h3><a name='header-n22' class='md-header-anchor '></a> </h3><h2><a name='header-n23' class='md-header-anchor '></a><strong>2.2 Python程序语法元素分析</strong></h2><p>Python程序由各种语法元素构成，掌握这些元素是编写Python程序的基础。本节将对常见的语法元素进行详细分析。</p><h4><a name='header-n26' class='md-header-anchor '></a><strong>2.2.1 程序的格式框架</strong></h4><p>Python程序的基本格式框架通常由以下几部分构成：</p><ol start='' ><li><strong>模块导入</strong>（可选）：通过<code>import</code>语句引入外部模块或库。</li><li><strong>函数定义</strong>（可选）：使用<code>def</code>关键字定义函数。</li><li><strong>主程序</strong>：Python程序的执行从顶层开始，一般包括变量定义、语句执行等。</li></ol><p><strong>示例</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"># 导入模块</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">import math</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"># 定义函数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">def square(x):</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return x ** 2</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"># 主程序</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">print(square(5))  # 调用函数并输出结果</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 215px;"></div><div class="CodeMirror-gutters" style="display: none; height: 245px;"></div></div></div></pre><h4><a name='header-n42' class='md-header-anchor '></a><strong>2.2.2 注释</strong></h4><p>注释是程序中对代码的解释，不会被执行。Python中有两种注释方式：</p><ul><li><strong>单行注释</strong>：用<code>#</code>标记。</li><li><strong>多行注释</strong>：用三个单引号<code>&#39;&#39;&#39;</code>或三个双引号<code>&quot;&quot;&quot;</code>包围。</li></ul><p><strong>示例</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"># 这是一个单行注释</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">print("Hello World!")  # 这行代码输出文本</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">'''</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">这是一个多行注释</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">用于对复杂代码进行解释。</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">'''</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 169px;"></div><div class="CodeMirror-gutters" style="display: none; height: 199px;"></div></div></div></pre><h4><a name='header-n55' class='md-header-anchor '></a><strong>2.2.3 命名与保留字</strong></h4><ul><li><strong>命名规则</strong>：Python的标识符（变量名、函数名等）只能由字母、数字和下划线组成，且不能以数字开头。命名时应该尽量使用有意义的名称，以增强代码的可读性。</li><li><strong>保留字</strong>：Python有一组保留字，作为语言的核心结构，不能作为标识符使用。可以通过<code>import keyword</code>查看。</li></ul><p><strong>示例</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">import keyword</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">print(keyword.kwlist)  # 输出Python的保留字列表</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre><h4><a name='header-n66' class='md-header-anchor '></a><strong>2.2.4 字符串</strong></h4><p>Python中的字符串是由字符组成的不可变序列。字符串可以用单引号、双引号或三引号表示。可以使用各种方法对字符串进行操作，例如连接、切片、替换等。</p><p><strong>示例</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">str1 = "Hello"</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">str2 = 'World'</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"># 字符串连接</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">greeting = str1 + " " + str2  # 输出 'Hello World'</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"># 字符串切片</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">print(greeting[0:5])  # 输出 'Hello'</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 192px;"></div><div class="CodeMirror-gutters" style="display: none; height: 222px;"></div></div></div></pre><h4><a name='header-n72' class='md-header-anchor '></a><strong>2.2.5 赋值语句</strong></h4><p>赋值语句用于将一个值赋给一个变量。在Python中，使用等号<code>=</code>进行赋值。</p><p><strong>示例</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">x = 5  # 赋值语句</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">y = x + 2  # y 被赋值为 7</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre><h4><a name='header-n78' class='md-header-anchor '></a><strong>2.2.6 input()函数</strong></h4><p><code>input()</code>函数用于从用户获取输入。默认情况下，它接受输入并将其作为字符串返回，可以通过<code>int()</code>或<code>float()</code>函数转换为其他数据类型。</p><p><strong>示例</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">name = input("请输入你的名字：")</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">print(f"你好，{name}！")</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre><h4><a name='header-n84' class='md-header-anchor '></a><strong>2.2.7 分支语句</strong></h4><p>分支语句用于根据条件执行不同的代码块。最常用的是<code>if</code>、<code>elif</code>和<code>else</code>语句。</p><p><strong>示例</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">x = 10</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">if x &gt; 5:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  print("x大于5")</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">else:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  print("x小于等于5")</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 123px;"></div><div class="CodeMirror-gutters" style="display: none; height: 153px;"></div></div></div></pre><h4><a name='header-n90' class='md-header-anchor '></a><strong>2.2.8 eval()函数</strong></h4><p><code>eval()</code>函数用于将字符串作为Python表达式执行，并返回其计算结果。它常用于动态执行表达式，但要小心使用，因为它可能导致安全问题。</p><p><strong>示例</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">x = 3</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">result = eval("x * 2 + 5")</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">print(result)  # 输出 11</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 77px;"></div><div class="CodeMirror-gutters" style="display: none; height: 107px;"></div></div></div></pre><h4><a name='header-n96' class='md-header-anchor '></a><strong>2.2.9 print()函数</strong></h4><p><code>print()</code>函数用于将输出打印到控制台。可以打印多个内容，并且可以使用<code>sep</code>和<code>end</code>参数自定义输出格式。</p><p><strong>示例</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">print("Hello", "World", sep="*", end="!\n")</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><h4><a name='header-n102' class='md-header-anchor '></a><strong>2.2.10 循环语句</strong></h4><p>循环语句用于重复执行某些操作。常见的循环有<code>for</code>和<code>while</code>两种。</p><p><strong>示例</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"># for循环</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">for i in range(5):</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  print(i)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"># while循环</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">count = 0</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">while count &lt; 5:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  print(count)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  count += 1</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 215px;"></div><div class="CodeMirror-gutters" style="display: none; height: 245px;"></div></div></div></pre><h4><a name='header-n108' class='md-header-anchor '></a><strong>2.2.11 函数</strong></h4><p>函数是Python程序的基本构建块，使用<code>def</code>关键字定义。函数有输入（参数）和输出（返回值）。</p><p><strong>示例</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">def add(a, b):</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return a + b</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">result = add(3, 4)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">print(result)  # 输出 7</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 123px;"></div><div class="CodeMirror-gutters" style="display: none; height: 153px;"></div></div></div></pre><hr /><h3><a name='header-n115' class='md-header-anchor '></a><strong>2.3 实例2：Python蟒蛇绘制</strong></h3><p>本实例利用<code>Turtle</code>库绘制一条蟒蛇。<code>Turtle</code>是Python的一个标准绘图库，常用于教学目的。通过控制“乌龟”绘制图形，学习者可以掌握基本的编程技能。</p><p><strong>蟒蛇绘制示例</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">import turtle</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"># 设置画布</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t = turtle.Turtle()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"># 绘制蟒蛇的身体</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">for _ in range(6):</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  t.forward(100)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  t.left(60)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  t.forward(100)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  t.right(60)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">turtle.done()</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 307px;"></div><div class="CodeMirror-gutters" style="display: none; height: 337px;"></div></div></div></pre><p>在此示例中，<code>turtle</code>通过<code>forward()</code>和<code>left()</code>、<code>right()</code>等方法控制“乌龟”绘制一个形状。</p><hr /><h3><a name='header-n124' class='md-header-anchor '></a><strong>2.4 turtle库语法元素分析</strong></h3><p><code>Turtle</code>库是Python自带的一个绘图库，广泛应用于教学和图形编程。它允许我们通过控制一个&quot;乌龟&quot;在画布上绘制图形。通过简单的命令，用户可以绘制从基本图形到复杂图案的各种形状。</p><p>在这一部分，我们将详细分析<code>turtle</code>库中常见的语法元素，帮助你更好地理解如何使用它来绘制各种形状。</p><hr /><h4><a name='header-n130' class='md-header-anchor '></a><strong>2.4.1 绘图坐标体系</strong></h4><p><code>turtle</code>库使用了一个二维坐标系统来控制“乌龟”的位置。坐标系的原点（0, 0）位于画布的中心，向右为X轴正方向，向上为Y轴正方向。</p><p><strong>坐标体系总结：</strong></p><ul><li><strong>原点(0, 0)</strong>：画布的中心。</li><li><strong>正X轴方向</strong>：向右。</li><li><strong>正Y轴方向</strong>：向上。</li><li><strong>负X轴方向</strong>：向左。</li><li><strong>负Y轴方向</strong>：向下。</li></ul><p>例如，若需要将“乌龟”移动到画布的右上角，坐标将是(100, 100)；若需要向左下方移动，则坐标可以是(-100, -100)。</p><hr /><h4><a name='header-n154' class='md-header-anchor '></a><strong>2.4.2 画笔控制函数</strong></h4><p><code>turtle</code>库提供了许多用于控制画笔状态的函数，以下是常用的几个：</p><ol start='' ><li><p><strong>penup()</strong>：抬起画笔，乌龟移动时不绘制任何图形。</p><ul><li>用途：在不想绘制图形的情况下，快速移动“乌龟”到新位置。</li></ul><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.penup()  # 抬起画笔</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.forward(50)  # 移动50个单位</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre></li><li><p><strong>pendown()</strong>：放下画笔，乌龟开始绘制路径。</p><ul><li>用途：当你需要开始绘制图形时，使用此命令。</li></ul><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.pendown()  # 放下画笔</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.forward(100)  # 绘制100个单位的直线</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre></li><li><p><strong>color(colorname)</strong>：设置画笔的颜色，可以使用颜色名称（如&quot;red&quot;、&quot;blue&quot;）或RGB值。</p><ul><li>用途：设置线条的颜色。</li></ul><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.color("red")  # 设置画笔颜色为红色</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.forward(100)  # 绘制红色线条</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre></li><li><p><strong>pensize(width)</strong>：设置画笔的粗细（宽度）。</p><ul><li>用途：控制绘制图形时线条的宽度。</li></ul><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.pensize(5)  # 设置画笔宽度为5</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.forward(100)  # 绘制线条</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre></li><li><p><strong>speed(speed)</strong>：控制乌龟的移动速度。速度从1到10，1为最慢，10为最快。</p><ul><li>用途：设置画笔的绘制速度。</li></ul><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.speed(10)  # 设置速度为最快</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.forward(100)  # 快速绘制</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre></li><li><p><strong>shape(shape)</strong>：设置“乌龟”的形状。</p><ul><li>用途：改变乌龟的外观，例如<code>&quot;turtle&quot;</code>、<code>&quot;triangle&quot;</code>、<code>&quot;square&quot;</code>、<code>&quot;arrow&quot;</code>等。</li></ul><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.shape("turtle")  # 设置乌龟的形状为"turtle"</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.forward(100)  # 向前移动</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre></li></ol><hr /><h4><a name='header-n207' class='md-header-anchor '></a><strong>2.4.3 形状绘制函数</strong></h4><p><code>turtle</code>库的核心功能是绘制图形，常用的函数包括<code>forward()</code>、<code>backward()</code>、<code>left()</code>、<code>right()</code>等，下面是这些函数的详细说明。</p><ol start='' ><li><p><strong>forward(distance)</strong>：使“乌龟”向前移动指定的距离。单位通常为像素。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.forward(100)  # 向前移动100个单位</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li><li><p><strong>backward(distance)</strong>：使“乌龟”向后移动指定的距离。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.backward(100)  # 向后移动100个单位</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li><li><p><strong>left(angle)</strong>：使“乌龟”向左旋转指定的角度（单位：度）。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.left(90)  # 向左旋转90度</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.forward(100)  # 向前移动100个单位</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre></li><li><p><strong>right(angle)</strong>：使“乌龟”向右旋转指定的角度（单位：度）。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.right(90)  # 向右旋转90度</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.forward(100)  # 向前移动100个单位</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre></li><li><p><strong>setposition(x, y)</strong>：将“乌龟”移动到指定的坐标位置。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.setposition(100, 100)  # 移动到坐标(100, 100)</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li><li><p><strong>setheading(angle)</strong>：设置“乌龟”的朝向。参数<code>angle</code>为角度，0度代表朝向右边，90度代表朝向上边，180度代表朝向左边，270度代表朝向下边。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.setheading(90)  # 朝向上方</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.forward(100)  # 向上移动100个单位</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre></li><li><p><strong>circle(radius, extent=None, steps=None)</strong>：绘制一个圆。<code>radius</code>是圆的半径，<code>extent</code>是圆弧的角度（默认为完整圆），<code>steps</code>指定绘制的多边形的边数。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.circle(50)  # 绘制半径为50的圆</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li><li><p><strong>dot(size=None, color=None)</strong>：绘制一个圆点，<code>size</code>是圆点的大小，<code>color</code>是圆点的颜色。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">t.dot(20, "blue")  # 绘制蓝色的圆点，大小为20</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li></ol><hr /><h4><a name='header-n244' class='md-header-anchor '></a><strong>2.4.4 控制窗口和画布</strong></h4><p>除了控制画笔，<code>turtle</code>库还提供了控制窗口和画布的函数。</p><ol start='' ><li><p><strong>screen.bgcolor(color)</strong>：设置画布的背景颜色。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">screen = turtle.Screen()</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">screen.bgcolor("lightblue")  # 设置背景色为浅蓝色</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 54px;"></div><div class="CodeMirror-gutters" style="display: none; height: 84px;"></div></div></div></pre></li><li><p><strong>screen.setup(width, height)</strong>：设置画布的大小。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">screen.setup(800, 600)  # 设置画布为800x600像素</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li><li><p><strong>turtle.done()</strong>：结束绘图，并保持窗口打开。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">turtle.done()  # 结束绘图，保持窗口</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre></li></ol><hr /><h3><a name='header-n261' class='md-header-anchor '></a><strong>综合示例：绘制一个多边形</strong></h3><p>结合上面介绍的各种函数，可以绘制一个复杂的多边形。以下是绘制一个正六边形的代码示例：</p><pre class="md-fences mock-cm md-end-block" lang="">import turtle

# 设置画布
t = turtle.Turtle()
t.pensize(3)
t.color("blue")

# 绘制正六边形
for _ in range(6):
    t.forward(100)  # 向前移动100个单位
    t.left(60)  # 向左旋转60度

turtle.done()  # 结束绘图并保持窗口打开
</pre><p>这段代码通过循环和旋转控制画笔，绘制了一个正六边形。每条边的长度为100个单位，旋转角度为60度。</p><hr /><p>通过掌握<code>Turtle</code>库的这些基本语法元素，你可以绘制各种图形和复杂的图案，也可以根据实际需求进行更精细的控制。希望这些解释和示例能帮助你更好地理解<code>Turtle</code>库的使用！</p><h2><a name='header-n270' class='md-header-anchor '></a><strong>第3章 基本数据类型</strong></h2><p>在Python中，数据类型是基础的组成部分。所有的数据都属于某种类型，不同的数据类型提供不同的功能和操作方式。本章将介绍Python中的基本数据类型，包括数字类型、字符串、布尔类型、列表、元组、字典等。我们将重点讨论<strong>数字类型</strong>的相关内容，涵盖整数、浮点数和复数的详细讲解。</p><hr /><h3><a name='header-n274' class='md-header-anchor '></a><strong>3.1 数字类型</strong></h3><p>Python中的数字类型是用于表示数值的基本数据类型，支持常见的数学运算。Python的数字类型分为三类：<strong>整数</strong>、<strong>浮点数</strong>和<strong>复数</strong>。</p><h4><a name='header-n277' class='md-header-anchor '></a><strong>3.1.1 数字类型概述</strong></h4><p>Python的数字类型包括：</p><ul><li><strong>整数（int）</strong>：用于表示没有小数部分的数值，如<code>-2</code>、<code>0</code>、<code>123</code>等。</li><li><strong>浮点数（float）</strong>：用于表示带小数部分的数值，如<code>3.14</code>、<code>-0.001</code>、<code>2.0</code>等。</li><li><strong>复数（complex）</strong>：用于表示复数形式的数值，如<code>3 + 4j</code>，其中<code>j</code>是虚数单位，表示平方根为-1的数。</li></ul><p>Python的数字类型是非常灵活的，可以进行加、减、乘、除等常见的算术运算，支持自动类型转换（如整数与浮点数相加时会自动转换为浮点数）。</p><p>Python中的数字类型都是不区分大小的，因此我们可以直接使用它们进行计算，无需显式地声明类型。</p><hr /><h4><a name='header-n295' class='md-header-anchor '></a><strong>3.1.2 整数类型（int）</strong></h4><p>整数类型（<code>int</code>）表示没有小数部分的数字，可以是正数、负数或零。Python的整数类型没有大小限制，理论上它们可以是任意大的整数，唯一的限制是内存。</p><h5><a name='header-n298' class='md-header-anchor '></a><strong>整数的表示方式</strong>：</h5><ul><li><strong>十进制</strong>：最常见的整数表示方式，例如<code>123</code>、<code>-456</code>。</li><li><strong>二进制</strong>：以<code>0b</code>或<code>0B</code>为前缀，例如<code>0b1010</code>表示十进制的<code>10</code>。</li><li><strong>八进制</strong>：以<code>0o</code>或<code>0O</code>为前缀，例如<code>0o10</code>表示十进制的<code>8</code>。</li><li><strong>十六进制</strong>：以<code>0x</code>或<code>0X</code>为前缀，例如<code>0x10</code>表示十进制的<code>16</code>。</li></ul><h5><a name='header-n312' class='md-header-anchor '></a><strong>示例代码</strong>：</h5><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;"># 十进制整数
a = 123
b = -456
print(a)  # 输出 123
print(b)  # 输出 -456

# 二进制整数
bin_num = 0b1010
print(bin_num)  # 输出 10

# 八进制整数
oct_num = 0o10
print(oct_num)  # 输出 8

# 十六进制整数
hex_num = 0x10
print(hex_num)  # 输出 16
</pre><h5><a name='header-n314' class='md-header-anchor '></a><strong>整数运算</strong>：</h5><p>Python支持常见的整数运算，包括加法、减法、乘法、除法、取余、整数除法、幂运算等。</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">x = 10
y = 3

# 加法
print(x + y)  # 输出 13

# 减法
print(x - y)  # 输出 7

# 乘法
print(x * y)  # 输出 30

# 除法（返回浮点数）
print(x / y)  # 输出 3.3333333333333335

# 整数除法（返回整数）
print(x // y)  # 输出 3

# 取余（返回余数）
print(x % y)  # 输出 1

# 幂运算（x的y次方）
print(x ** y)  # 输出 1000
</pre><h5><a name='header-n318' class='md-header-anchor '></a><strong>整数的类型转换</strong>：</h5><p>你可以通过<code>int()</code>函数将其他数据类型转换为整数。</p><pre class="md-fences mock-cm md-end-block" lang=""># 将字符串转换为整数
s = "123"
num = int(s)
print(num)  # 输出 123

# 将浮点数转换为整数（小数部分被截断）
f = 12.56
print(int(f))  # 输出 12
</pre><hr /><h4><a name='header-n323' class='md-header-anchor '></a><strong>3.1.3 浮点数类型（float）</strong></h4><p>浮点数类型（<code>float</code>）用于表示带小数部分的数字。Python中的浮点数是基于IEEE 754标准的双精度浮点数（64位），因此它可以表示非常大的数和非常小的数。</p><h5><a name='header-n326' class='md-header-anchor '></a><strong>浮点数的表示</strong>：</h5><p>浮点数可以用标准的十进制表示法，也可以使用科学计数法表示。例如：</p><ul><li><strong>十进制表示</strong>：<code>3.14</code>、<code>-0.001</code>、<code>2.0</code>等。</li><li><strong>科学计数法表示</strong>：<code>1.23e4</code>表示<code>1.23 * 10^4</code>，即<code>12300</code>。</li></ul><h5><a name='header-n336' class='md-header-anchor '></a><strong>示例代码</strong>：</h5><pre class="md-fences mock-cm md-end-block" lang=""># 浮点数
f1 = 3.14
f2 = -0.001
f3 = 2.0
print(f1)  # 输出 3.14
print(f2)  # 输出 -0.001
print(f3)  # 输出 2.0

# 科学计数法
f4 = 1.23e4
print(f4)  # 输出 12300.0
</pre><h5><a name='header-n338' class='md-header-anchor '></a><strong>浮点数运算</strong>：</h5><p>浮点数支持与整数相同的数学运算，但需要注意的是，浮点数计算有时可能会产生精度误差，特别是涉及小数的情况。</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">a = 5.2
b = 2.0

# 加法
print(a + b)  # 输出 7.2

# 减法
print(a - b)  # 输出 3.2

# 乘法
print(a * b)  # 输出 10.4

# 除法
print(a / b)  # 输出 2.6
</pre><h5><a name='header-n342' class='md-header-anchor '></a><strong>浮点数的类型转换</strong>：</h5><p>你可以通过<code>float()</code>函数将其他数据类型转换为浮点数。</p><pre class="md-fences mock-cm md-end-block" lang=""># 将整数转换为浮点数
i = 10
print(float(i))  # 输出 10.0

# 将字符串转换为浮点数
s = "3.14"
print(float(s))  # 输出 3.14
</pre><h5><a name='header-n346' class='md-header-anchor '></a><strong>浮点数的精度问题</strong>：</h5><p>浮点数在存储和计算过程中，可能会产生精度丢失。例如，<code>0.1 + 0.2</code>的结果是<code>0.30000000000000004</code>，而不是<code>0.3</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">print(0.1 + 0.2)  # 输出 0.30000000000000004
</pre><p>为了解决浮点数的精度问题，可以使用<code>round()</code>函数对结果进行四舍五入。</p><pre class="md-fences mock-cm md-end-block" lang="">print(round(0.1 + 0.2, 1))  # 输出 0.3
</pre><hr /><h4><a name='header-n354' class='md-header-anchor '></a><strong>3.1.4 复数类型（complex）</strong></h4><p>复数类型（<code>complex</code>）用于表示复数，复数由实部和虚部组成。Python中的复数以<code>a + bj</code>的形式表示，其中<code>a</code>是实部，<code>b</code>是虚部，<code>j</code>是虚数单位。</p><h5><a name='header-n357' class='md-header-anchor '></a><strong>复数的表示</strong>：</h5><pre class="md-fences mock-cm md-end-block" lang="">z = 3 + 4j  # 复数表示，实部为3，虚部为4
</pre><ul><li><strong>实部</strong>：复数的<code>a</code>值，使用<code>real</code>属性访问。</li><li><strong>虚部</strong>：复数的<code>b</code>值，使用<code>imag</code>属性访问。</li></ul><h5><a name='header-n366' class='md-header-anchor '></a><strong>示例代码</strong>：</h5><pre class="md-fences mock-cm md-end-block" lang="">z1 = 3 + 4j  # 创建复数

# 获取复数的实部和虚部
print(z1.real)  # 输出 3.0
print(z1.imag)  # 输出 4.0
</pre><h5><a name='header-n368' class='md-header-anchor '></a><strong>复数运算</strong>：</h5><p>复数支持加法、减法、乘法、除法等常见的数学运算。Python会自动处理复数运算。</p><pre class="md-fences mock-cm md-end-block" lang="">z2 = 1 + 2j
z3 = 3 + 4j

# 复数加法
print(z1 + z2)  # 输出 (4+6j)

# 复数乘法
print(z1 * z3)  # 输出 (-5+18j)

# 复数除法
print(z1 / z2)  # 输出 (2.2+0.4j)
</pre><h5><a name='header-n372' class='md-header-anchor '></a><strong>复数的类型转换</strong>：</h5><p>Python中没有直接将浮点数或整数转换为复数的函数，但可以通过将虚部指定为零来创建复数。</p><pre class="md-fences mock-cm md-end-block" lang=""># 整数转复数
i = 5
z4 = complex(i, 0)  # 将整数转换为复数
print(z4)
</pre><h3><a name='header-n376' class='md-header-anchor '></a><strong>3.2 数字类型的操作</strong></h3><p>在Python中，数字类型不仅可以进行基本的算术运算，还提供了丰富的内置函数来执行各种数学操作。通过这些内置的操作符和函数，Python能够处理不同类型的数值计算，例如整数、浮点数和复数的加减乘除等。</p><p>本节将详细介绍数字类型的操作，包括数值运算操作符、内置的数值运算函数以及内置的数字类型转换函数。</p><hr /><h4><a name='header-n382' class='md-header-anchor '></a><strong>3.2.1 内置的数值运算操作符</strong></h4><p>Python支持多种数值运算操作符，用于对整数、浮点数以及复数等数字类型进行常见的数学计算。常见的数值运算符有加法、减法、乘法、除法等。</p><h5><a name='header-n385' class='md-header-anchor '></a><strong>常见的数值运算操作符</strong></h5><ol start='' ><li><p><strong>加法（+）</strong>：将两个数相加。</p><pre class="md-fences mock-cm md-end-block" lang="">a = 10
b = 5
result = a + b
print(result)  # 输出 15
</pre></li><li><p><strong>减法（-）</strong>：将一个数从另一个数中减去。</p><pre class="md-fences mock-cm md-end-block" lang="">a = 10
b = 5
result = a - b
print(result)  # 输出 5
</pre></li><li><p><strong>乘法（*）</strong>：将两个数相乘。</p><pre class="md-fences mock-cm md-end-block" lang="">a = 10
b = 5
result = a * b
print(result)  # 输出 50
</pre></li><li><p><strong>除法（/）</strong>：将一个数除以另一个数，返回浮点数结果。</p><pre class="md-fences mock-cm md-end-block" lang="">a = 10
b = 3
result = a / b
print(result)  # 输出 3.3333333333333335
</pre></li><li><p><strong>整数除法（//）</strong>：将一个数除以另一个数，返回整数结果（即向下取整）。</p><pre class="md-fences mock-cm md-end-block" lang="">a = 10
b = 3
result = a // b
print(result)  # 输出 3
</pre></li><li><p><strong>取余（%）</strong>：返回除法运算的余数。</p><pre class="md-fences mock-cm md-end-block" lang="">a = 10
b = 3
result = a % b
print(result)  # 输出 1
</pre></li><li><p><strong>幂运算（**）</strong>：返回一个数的幂。<code>a ** b</code>表示<code>a</code>的<code>b</code>次方。</p><pre class="md-fences mock-cm md-end-block" lang="">a = 2
b = 3
result = a ** b
print(result)  # 输出 8
</pre></li></ol><h5><a name='header-n415' class='md-header-anchor '></a><strong>复合运算符</strong></h5><p>除了基本的运算符，Python还提供了复合运算符，这些运算符可以简化代码，避免重复的赋值。</p><ol start='' ><li><p><strong>加等（+=）</strong>：将右边的值加到左边的变量中。</p><pre class="md-fences mock-cm md-end-block" lang="">a = 10
a += 5  # 相当于 a = a + 5
print(a)  # 输出 15
</pre></li><li><p><strong>减等（-=）</strong>：将右边的值从左边的变量中减去。</p><pre class="md-fences mock-cm md-end-block" lang="">a = 10
a -= 5  # 相当于 a = a - 5
print(a)  # 输出 5
</pre></li><li><p><strong>乘等（*=）</strong>：将左边的变量与右边的值相乘，并赋给左边的变量。</p><pre class="md-fences mock-cm md-end-block" lang="">a = 10
a *= 5  # 相当于 a = a * 5
print(a)  # 输出 50
</pre></li><li><p><strong>除等（/=）</strong>：将左边的变量除以右边的值，并赋给左边的变量。</p><pre class="md-fences mock-cm md-end-block" lang="">a = 10
a /= 5  # 相当于 a = a / 5
print(a)  # 输出 2.0
</pre></li></ol><hr /><h4><a name='header-n436' class='md-header-anchor '></a><strong>3.2.2 内置的数值运算函数</strong></h4><p>Python提供了许多内置的数值运算函数，支持更复杂的数学运算，如绝对值、最大最小值、四舍五入等。以下是常用的数值运算函数。</p><h5><a name='header-n439' class='md-header-anchor '></a><strong>常见的内置数值运算函数</strong></h5><ol start='' ><li><p><strong>abs(x)</strong>：返回数字<code>x</code>的绝对值。</p><pre class="md-fences mock-cm md-end-block" lang="">x = -10
print(abs(x))  # 输出 10
</pre></li><li><p><strong>round(x, n)</strong>：返回数字<code>x</code>四舍五入后的小数点后<code>n</code>位的值。如果不提供<code>n</code>，则默认四舍五入到整数。</p><pre class="md-fences mock-cm md-end-block" lang="">x = 3.14159
print(round(x, 2))  # 输出 3.14
print(round(x))  # 输出 3
</pre></li><li><p><strong>max(iterable, *args)</strong>：返回给定可迭代对象中的最大值，或者返回两个或更多参数中的最大值。</p><pre class="md-fences mock-cm md-end-block" lang="">nums = [1, 2, 3, 4, 5]
print(max(nums))  # 输出 5

print(max(10, 20, 30))  # 输出 30
</pre></li><li><p><strong>min(iterable, *args)</strong>：返回给定可迭代对象中的最小值，或者返回两个或更多参数中的最小值。</p><pre class="md-fences mock-cm md-end-block" lang="">nums = [1, 2, 3, 4, 5]
print(min(nums))  # 输出 1

print(min(10, 20, 30))  # 输出 10
</pre></li><li><p><strong>sum(iterable, start=0)</strong>：返回给定可迭代对象中所有元素的和。可以通过<code>start</code>参数指定起始值，默认为0。</p><pre class="md-fences mock-cm md-end-block" lang="">nums = [1, 2, 3, 4]
print(sum(nums))  # 输出 10

print(sum(nums, 10))  # 输出 20
</pre></li><li><p><strong>pow(x, y)</strong>：返回<code>x</code>的<code>y</code>次方，即<code>x**y</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">print(pow(2, 3))  # 输出 8
</pre></li><li><p><strong>divmod(a, b)</strong>：返回一个包含商和余数的元组。等同于<code>(a // b, a % b)</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">result = divmod(10, 3)
print(result)  # 输出 (3, 1)
</pre></li><li><p><strong>math模块中的函数</strong>：</p><ul><li><p><strong>math.sqrt(x)</strong>：返回数字<code>x</code>的平方根。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.sqrt(16))  # 输出 4.0
</pre></li><li><p><strong>math.pow(x, y)</strong>：返回<code>x</code>的<code>y</code>次方，与内置的<code>pow()</code>不同，<code>math.pow()</code>总是返回浮点数。</p><pre class="md-fences mock-cm md-end-block" lang="">print(math.pow(2, 3))  # 输出 8.0
</pre></li></ul></li></ol><hr /><h4><a name='header-n482' class='md-header-anchor '></a><strong>3.2.3 内置的数字类型转换函数</strong></h4><p>Python提供了一些内置的数字类型转换函数，用于将不同类型的数值相互转换。这些函数对于数据类型之间的转换非常有用，尤其在涉及不同类型的运算时。</p><h4><a name='header-n485' class='md-header-anchor '></a><strong>常见的数字类型转换函数</strong></h4><ol start='' ><li><p><strong>int(x, base=10)</strong>：将<code>x</code>转换为整数。可以指定<code>base</code>，该参数定义数字<code>x</code>的进制，默认为10（十进制）。</p><pre class="md-fences mock-cm md-end-block" lang=""># 将浮点数转换为整数
print(int(3.5))  # 输出 3

# 将字符串转换为整数
print(int("10"))  # 输出 10

# 将二进制字符串转换为整数
print(int("1010", 2))  # 输出 10
</pre></li><li><p><strong>float(x)</strong>：将<code>x</code>转换为浮点数。</p><pre class="md-fences mock-cm md-end-block" lang="">print(float(10))  # 输出 10.0
print(float("3.14"))  # 输出 3.14
</pre></li><li><p><strong>complex(real, imag=0)</strong>：将<code>real</code>和<code>imag</code>分别作为实部和虚部，返回一个复数。<code>real</code>和<code>imag</code>可以是整数、浮点数或字符串类型。</p><pre class="md-fences mock-cm md-end-block" lang="">print(complex(3, 4))  # 输出 (3+4j)
print(complex("3", "4"))  # 输出 (3+4j)
</pre></li><li><p><strong>bool(x)</strong>：将<code>x</code>转换为布尔值。非零数字和非空对象会转换为<code>True</code>，零和<code>None</code>会转换为<code>False</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">print(bool(0))  # 输出 False
</pre></li></ol><h3><a name='header-n503' class='md-header-anchor '></a><strong>3.3 模块1：math库的使用</strong></h3><p>Python的<code>math</code>模块提供了许多数学函数和常量，可以帮助我们执行高效的数学运算。该模块包含了基础的数学运算函数、常见的数学常量，以及其他高阶的数学计算功能。使用<code>math</code>模块能够让我们简化一些复杂的数学操作，避免自己编写底层代码。<code>math</code>模块适用于需要精确数学计算的场景，如科学计算、工程应用等。</p><hr /><h4><a name='header-n507' class='md-header-anchor '></a><strong>3.3.1 math库概述</strong></h4><p><code>math</code>模块是Python标准库的一部分，因此不需要额外安装。在导入该模块后，我们可以访问其中提供的各种数学函数和常量。</p><h5><a name='header-n510' class='md-header-anchor '></a><strong>math模块的常见功能</strong>：</h5><ul><li><strong>基本数学运算</strong>：提供基本的四则运算、幂运算、对数运算、三角函数等。</li><li><strong>常用数学常量</strong>：例如圆周率π、自然对数的底e等。</li><li><strong>特殊数学函数</strong>：如计算阶乘、最大公约数、最小公倍数等。</li><li><strong>高级数学函数</strong>：如计算平方根、正弦、余弦、正切等三角函数。</li></ul><p><code>math</code>模块的函数大多数返回的是浮点数，因此它更适合进行精确的数学计算。如果只需要进行简单的四则运算，Python内置的运算符已经足够，但对于一些复杂的数学操作，<code>math</code>模块提供了更强大的支持。</p><h5><a name='header-n526' class='md-header-anchor '></a><strong>如何使用math模块</strong>：</h5><p>在Python中，使用<code>import math</code>语句导入<code>math</code>模块。导入后，可以通过模块名访问其中的函数和常量。</p><pre class="md-fences mock-cm md-end-block" lang="">import math

# 使用math模块的常量和函数
print(math.pi)  # 输出圆周率 π
print(math.sqrt(16))  # 输出 16 的平方根
</pre><hr /><h4><a name='header-n531' class='md-header-anchor '></a><strong>3.3.2 math库解析</strong></h4><p>在本节中，我们将详细解析<code>math</code>模块中常用的函数和常量，帮助理解其使用方式。</p><h5><a name='header-n534' class='md-header-anchor '></a><strong>1. 常用数学常量</strong></h5><ul><li><p><strong>math.pi</strong>：表示圆周率π，值为3.141592653589793。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.pi)  # 输出 3.141592653589793
</pre></li><li><p><strong>math.e</strong>：表示自然对数的底e，值为2.718281828459045。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.e)  # 输出 2.718281828459045
</pre></li><li><p><strong>math.tau</strong>：表示2π，值为6.283185307179586，适用于角度和周期相关的计算。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.tau)  # 输出 6.283185307179586
</pre></li><li><p><strong>math.inf</strong>：表示正无穷大，适用于表示无穷大的情况。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.inf)  # 输出 inf
</pre></li><li><p><strong>math.nan</strong>：表示“非数字”（NaN），用于表示无效的或未定义的数学操作。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.nan)  # 输出 nan
</pre></li></ul><h5><a name='header-n556' class='md-header-anchor '></a><strong>2. 常见数学函数</strong></h5><p><code>math</code>模块提供了许多常见的数学函数，以下是一些最常用的函数：</p><ul><li><p><strong>math.sqrt(x)</strong>：返回数字<code>x</code>的平方根。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.sqrt(16))  # 输出 4.0
print(math.sqrt(25))  # 输出 5.0
</pre></li><li><p><strong>math.factorial(x)</strong>：返回<code>x</code>的阶乘。<code>x</code>必须是非负整数。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.factorial(5))  # 输出 120 (5! = 5 * 4 * 3 * 2 * 1)
</pre></li><li><p><strong>math.fabs(x)</strong>：返回<code>x</code>的绝对值，<code>x</code>可以是整数或浮点数。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.fabs(-3.14))  # 输出 3.14
print(math.fabs(7))      # 输出 7.0
</pre></li><li><p><strong>math.pow(x, y)</strong>：返回<code>x</code>的<code>y</code>次方，与内置的<code>**</code>运算符类似，但总是返回浮点数。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.pow(2, 3))  # 输出 8.0
</pre></li><li><p><strong>math.log(x, base)</strong>：返回<code>x</code>以<code>base</code>为底的对数。如果不指定<code>base</code>，默认是自然对数（以e为底）。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.log(10, 10))  # 输出 1.0 (log10(10) = 1)
print(math.log(16, 2))   # 输出 4.0 (log2(16) = 4)
print(math.log(100))     # 输出 4.605170186000001 (log自然对数)
</pre></li><li><p><strong>math.exp(x)</strong>：返回<code>e</code>的<code>x</code>次方，即<code>math.e**x</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.exp(1))  # 输出 2.718281828459045
</pre></li><li><p><strong>math.modf(x)</strong>：将<code>x</code>拆分成整数部分和小数部分，返回一个元组<code>(fractional, integer)</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.modf(3.14))  # 输出 (0.14000000000000012, 3.0)
</pre></li><li><p><strong>math.isqrt(x)</strong>：返回<code>x</code>的整数平方根，适用于大整数。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.isqrt(16))  # 输出 4
print(math.isqrt(50))  # 输出 7
</pre></li></ul><h5><a name='header-n592' class='md-header-anchor '></a><strong>3. 三角函数</strong></h5><p><code>math</code>模块还提供了多种三角函数，支持弧度和角度的计算。常见的三角函数包括正弦、余弦、正切等。</p><ul><li><p><strong>math.sin(x)</strong>：返回弧度<code>x</code>的正弦值。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.sin(math.pi / 2))  # 输出 1.0
</pre></li><li><p><strong>math.cos(x)</strong>：返回弧度<code>x</code>的余弦值。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.cos(math.pi))  # 输出 -1.0
</pre></li><li><p><strong>math.tan(x)</strong>：返回弧度<code>x</code>的正切值。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.tan(math.pi / 4))  # 输出 1.0
</pre></li><li><p><strong>math.asin(x)</strong>：返回<code>x</code>的反正弦值，结果是弧度。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.asin(1))  # 输出 1.5707963267948966 (π/2)
</pre></li><li><p><strong>math.acos(x)</strong>：返回<code>x</code>的反余弦值，结果是弧度。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.acos(-1))  # 输出 3.141592653589793 (π)
</pre></li><li><p><strong>math.atan(x)</strong>：返回<code>x</code>的反正切值，结果是弧度。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.atan(1))  # 输出 0.7853981633974483 (π/4)
</pre></li></ul><h5><a name='header-n620' class='md-header-anchor '></a><strong>4. 角度与弧度的转换</strong></h5><p>Python中的三角函数使用弧度为单位，然而在一些应用中，我们可能需要使用角度。<code>math</code>模块提供了角度与弧度之间的转换函数：</p><ul><li><p><strong>math.radians(x)</strong>：将角度<code>x</code>转换为弧度。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.radians(90))  # 输出 1.5707963267948966 (π/2)
</pre></li><li><p><strong>math.degrees(x)</strong>：将弧度<code>x</code>转换为角度。</p><pre class="md-fences mock-cm md-end-block" lang="">import math
print(math.degrees(math.pi / 2))  # 输出 90.0
</pre></li></ul><hr /><h4><a name='header-n633' class='md-header-anchor '></a><strong>总结</strong></h4><p><code>math</code>模块提供了广泛的数学运算功能，涵盖了基本的算术运算、三角函数、对数函数、数学常量等。无论是进行科学计算、图形处理，还是其他需要数学支持的应用，<code>math</code>模块都能提供强大的支持。通过掌握这些数学函数，可以让我们高效地处理各种数学问题。</p><h3><a name='header-n636' class='md-header-anchor '></a><strong>3.5 字符串类型及其操作</strong></h3><p>在Python中，字符串（<code>str</code>）是用于表示文本数据的基本数据类型之一。字符串在Python中是一个不可变的序列类型，允许存储文本数据、字符、符号、数字和空格等。通过字符串的操作，Python为我们提供了丰富的功能，便于进行文本处理、字符串拼接、查找、替换等操作。</p><p>本节将详细介绍字符串类型的表示、基本的字符串操作符、内置的字符串处理函数和方法，帮助更好地掌握字符串的各种操作。</p><hr /><h4><a name='header-n642' class='md-header-anchor '></a><strong>3.5.1 字符串类型的表示</strong></h4><p>在Python中，字符串可以使用单引号（<code>&#39;</code>）或双引号（<code>&quot;</code>）来表示。两者在功能上没有差别，选择哪种方式主要取决于字符串内容和个人偏好。</p><h5><a name='header-n645' class='md-header-anchor '></a><strong>1. 使用单引号或双引号</strong></h5><ul><li><p><strong>单引号表示字符串</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">string1 = 'Hello, World!'
</pre></li><li><p><strong>双引号表示字符串</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">string2 = "Python is awesome"
</pre></li></ul><p>如果字符串内部包含单引号，可以使用双引号表示字符串，反之亦然。</p><ul><li><p><strong>单引号包含双引号</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">string3 = "It's a sunny day."
</pre></li><li><p><strong>双引号包含单引号</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">string4 = 'She said, "Hello!"'
</pre></li></ul><h5><a name='header-n666' class='md-header-anchor '></a><strong>2. 多行字符串</strong></h5><p>如果字符串内容跨越多行，可以使用三引号（<code>&#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot;</code>）来表示多行字符串。三引号不仅适用于字符串中包含换行符的情况，还可以包括特殊字符而不需要转义。</p><ul><li><p><strong>三单引号</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">string5 = '''This is a string
that spans multiple
lines.'''
</pre></li><li><p><strong>三双引号</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">string6 = """This is another example
of a multi-line string."""
</pre></li></ul><h5><a name='header-n678' class='md-header-anchor '></a><strong>3. 字符串的转义字符</strong></h5><p>有时，我们需要在字符串中表示特殊字符，如换行、制表符等。可以使用反斜杠（<code>\</code>）作为转义字符。</p><ul><li><p><strong>换行符</strong>（<code>\n</code>）：</p><pre class="md-fences mock-cm md-end-block" lang="">string7 = "Hello,\nWorld!"
print(string7)
# 输出:
# Hello,
# World!
</pre></li><li><p><strong>制表符</strong>（<code>\t</code>）：</p><pre class="md-fences mock-cm md-end-block" lang="">string8 = "Name\tAge\nAlice\t24\nBob\t30"
print(string8)
# 输出:
# Name    Age
# Alice   24
# Bob     30
</pre></li><li><p><strong>引号转义</strong>（<code>\&#39;</code> 或 <code>\&quot;</code>）：</p><pre class="md-fences mock-cm md-end-block" lang="">string9 = "She said, \"Python is awesome!\""
print(string9)  # 输出: She said, "Python is awesome!"
</pre></li></ul><hr /><h4><a name='header-n695' class='md-header-anchor '></a>**3.5.2 基本的字符串操作符</h4><p>Python为字符串提供了多种操作符，使得字符串的操作变得非常简单。以下是常见的字符串操作符。</p><h5><a name='header-n698' class='md-header-anchor '></a><strong>1. 字符串拼接（+）</strong></h5><p>使用<code>+</code>操作符可以将两个或多个字符串拼接在一起，形成一个新的字符串。</p><pre class="md-fences mock-cm md-end-block" lang="">string10 = "Hello"
string11 = "World"
result = string10 + " " + string11
print(result)  # 输出: Hello World
</pre><h5><a name='header-n702' class='md-header-anchor '></a><strong>2. 字符串重复（*）</strong></h5><p>使用<code>*</code>操作符可以将字符串重复若干次，形成一个新的字符串。</p><pre class="md-fences mock-cm md-end-block" lang="">string12 = "Hello"
result = string12 * 3
print(result)  # 输出: HelloHelloHello
</pre><h5><a name='header-n706' class='md-header-anchor '></a><strong>3. 字符串长度（len()）</strong></h5><p>使用内置函数<code>len()</code>可以获得字符串的长度，即字符的个数。</p><pre class="md-fences mock-cm md-end-block" lang="">string13 = "Python"
length = len(string13)
print(length)  # 输出: 6
</pre><h5><a name='header-n710' class='md-header-anchor '></a><strong>4. 字符串索引和切片</strong></h5><ul><li><p><strong>索引</strong>：可以通过索引来访问字符串中的单个字符，索引从0开始。</p><pre class="md-fences mock-cm md-end-block" lang="">string14 = "Python"
print(string14[0])  # 输出: P
print(string14[2])  # 输出: t
</pre></li><li><p><strong>切片</strong>：通过切片可以提取字符串的一部分，语法为<code>string[start:end]</code>，包含<code>start</code>索引，但不包括<code>end</code>索引。</p><pre class="md-fences mock-cm md-end-block" lang="">string15 = "Python Programming"
print(string15[0:6])  # 输出: Python
print(string15[7:])   # 输出: Programming
print(string15[:6])   # 输出: Python
</pre></li></ul><h5><a name='header-n720' class='md-header-anchor '></a><strong>5. 字符串的成员关系操作符（in 和 not in）</strong></h5><ul><li><p><strong>in</strong>：检查某个字符或子字符串是否存在于字符串中。</p><pre class="md-fences mock-cm md-end-block" lang="">string16 = "Hello, World!"
print('Hello' in string16)  # 输出: True
print('Python' in string16)  # 输出: False
</pre></li><li><p><strong>not in</strong>：检查某个字符或子字符串是否不在字符串中。</p><pre class="md-fences mock-cm md-end-block" lang="">print('Python' not in string16)  # 输出: True
</pre></li></ul><hr /><h4><a name='header-n731' class='md-header-anchor '></a><strong>3.5.3 内置的字符串处理函数</strong></h4><p>Python提供了多个内置的字符串处理函数，用于执行字符串的各种常见操作。以下是一些常用的字符串函数。</p><h4><a name='header-n734' class='md-header-anchor '></a><strong>1. str.upper() 和 str.lower()</strong></h4><ul><li><p><strong>upper()</strong>：返回一个将所有字符转换为大写的新字符串。</p><pre class="md-fences mock-cm md-end-block" lang="">string17 = "python"
print(string17.upper())  # 输出: PYTHON
</pre></li><li><p><strong>lower()</strong>：返回一个将所有字符转换为小写的新字符串。</p><pre class="md-fences mock-cm md-end-block" lang="">string18 = "PYTHON"
print(string18.lower())  # 输出: python
</pre></li></ul><h4><a name='header-n744' class='md-header-anchor '></a><strong>2. str.title()</strong></h4><p>将字符串中的每个单词的首字母转换为大写，其他字母转换为小写。</p><pre class="md-fences mock-cm md-end-block" lang="">string19 = "hello world"
print(string19.title())  # 输出: Hello World
</pre><h4><a name='header-n748' class='md-header-anchor '></a><strong>3. str.strip()</strong></h4><ul><li><p><strong>strip()</strong>：返回一个移除字符串开头和结尾空白字符（包括空格、换行符、制表符等）后的新字符串。</p><pre class="md-fences mock-cm md-end-block" lang="">string20 = "  Hello World  "
print(string20.strip())  # 输出: Hello World
</pre></li><li><p><strong>lstrip()</strong>：只移除字符串开头的空白字符。</p><pre class="md-fences mock-cm md-end-block" lang="">string21 = "  Hello"
print(string21.lstrip())  # 输出: Hello
</pre></li><li><p><strong>rstrip()</strong>：只移除字符串结尾的空白字符。</p><pre class="md-fences mock-cm md-end-block" lang="">string22 = "Hello  "
print(string22.rstrip())  # 输出: Hello
</pre></li></ul><h4><a name='header-n762' class='md-header-anchor '></a><strong>4. str.replace(old, new)</strong></h4><ul><li><p><strong>replace()</strong>：返回一个新字符串，将原字符串中的所有子字符串<code>old</code>替换为<code>new</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">string23 = "Hello World"
print(string23.replace("World", "Python"))  # 输出: Hello Python
</pre></li></ul><h4><a name='header-n768' class='md-header-anchor '></a><strong>5. str.split(separator)</strong></h4><ul><li><p><strong>split()</strong>：将字符串分割为多个子字符串，并返回一个列表，默认按照空白字符进行分割。</p><pre class="md-fences mock-cm md-end-block" lang="">string24 = "Python is awesome"
print(string24.split())  # 输出: ['Python', 'is', 'awesome']
</pre><p>可以指定分隔符进行分割：</p><pre class="md-fences mock-cm md-end-block" lang="">string25 = "apple,orange,banana"
print(string25.split(','))  # 输出: ['apple', 'orange', 'banana']
</pre></li></ul><h4><a name='header-n777' class='md-header-anchor '></a><strong>6. str.find(substring)</strong></h4><ul><li><p><strong>find()</strong>：返回子字符串首次出现的索引位置，如果没有找到，返回<code>-1</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">string26 = "Hello, World"
print(string26.find("World"))  # 输出: 7
print(string26.find("Python"))  # 输出: -1
</pre></li></ul><h4><a name='header-n783' class='md-header-anchor '></a><strong>7. str.count(substring)</strong></h4><ul><li><p><strong>count()</strong>：返回子字符串在字符串中出现的次数。</p><pre class="md-fences mock-cm md-end-block" lang="">string27 = "Hello, Hello, Hello"
print(string27.count("Hello"))  # 输出: 3
</pre></li></ul><hr /><h4><a name='header-n790' class='md-header-anchor '></a><strong>3.5.4 内置的字符串处理方法</strong></h4><p>字符串对象本身提供了多种方法来进行字符串处理。这些方法常常可以直接作用于字符串对象，无需使用额外的函数。</p><h5><a name='header-n793' class='md-header-anchor '></a><strong>1. str.isdigit()</strong></h5><ul><li><p><strong>isdigit()</strong>：如果字符串只包含数字字符，则返回<code>True</code>，否则返回<code>False</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">string28 = "12345"
print(string28.isdigit())  # 输出: True
</pre></li></ul><pre class="md-fences mock-cm md-end-block" lang="">#### **2. `str.isalpha()`**

- **`isalpha()`**：如果字符串只包含字母字符，则返回`True`，否则返回`False`。

​```python
string29 = "Hello"
print(string29.isalpha())  # 输出: True
</pre><h5><a name='header-n800' class='md-header-anchor '></a><strong>3. str.islower() 和 str.isupper()</strong></h5><ul><li><p><strong>islower()</strong>：如果字符串中的所有字符都为小写，则返回<code>True</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">string30 = "hello"
print(string30.islower())  # 输出: True
</pre></li><li><p><strong>isupper()</strong>：如果字符串中的所有字符都为大写，则返回<code>True</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">string31 = "HELLO"
print(string31.isupper())  # 输出: True
</pre></li></ul><h5><a name='header-n810' class='md-header-anchor '></a><strong>4. str.startswith(prefix)</strong></h5><ul><li><p><strong>startswith()</strong>：如果字符串以指定的<code>prefix</code>开始，则返回<code>True</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">string32 = "Hello, World!"
print(string32.startswith("Hello"))  # 输出: True
</pre></li></ul><h5><a name='header-n816' class='md-header-anchor '></a><strong>5. str.endswith(suffix)</strong></h5><ul><li><p><strong>endswith()</strong>：如果字符串以指定的<code>suffix</code>结尾，则返回<code>True</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">string33 = "Hello, World!"
print(string33.endswith("World!"))  # 输出: True
</pre></li></ul><hr /><h4><a name='header-n823' class='md-header-anchor '></a><strong>总结</strong></h4><p>字符串是Python中非常常用的数据类型，Python提供了多种操作符、内置函数和方法来处理字符串，使得字符串操作变得非常简洁高效。掌握这些字符串操作可以帮助我们更好地处理文本数据，完成字符串拼接、查找、替换、格式化等任务。</p><h3><a name='header-n826' class='md-header-anchor '></a><strong>3.6 字符串类型的格式化</strong></h3><p>在Python中，字符串的格式化是一种将变量或表达式嵌入字符串中的方法。这使得我们可以动态地生成字符串，并插入特定的值。Python提供了多种方式来实现字符串的格式化，其中最常用和最强大的方式是使用<code>str.format()</code>方法。</p><p>在本节中，我们将深入探讨<code>format()</code>方法的基本使用以及如何通过格式控制来定制字符串的输出。</p><hr /><h4><a name='header-n832' class='md-header-anchor '></a><strong>3.6.1 format()方法的基本使用</strong></h4><p><code>format()</code>方法是Python中一个强大的字符串格式化工具。它通过占位符 <code>{}</code> 来表示要插入的变量或值，调用<code>format()</code>方法时，可以将变量值按顺序或名称传递进去。</p><h5><a name='header-n835' class='md-header-anchor '></a><strong>1. 基本语法</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">string = "Hello, {}!"
formatted_string = string.format("World")
print(formatted_string)  # 输出: Hello, World!
</pre><p>在这个例子中，<code>{}</code>是一个占位符，<code>&quot;World&quot;</code>通过<code>format()</code>方法填充到字符串中的占位符位置，最终形成 <code>&quot;Hello, World!&quot;</code>。</p><h5><a name='header-n839' class='md-header-anchor '></a><strong>2. 位置参数</strong></h5><p><code>format()</code>方法支持位置参数，这意味着可以通过数字来指定占位符的顺序。</p><pre class="md-fences mock-cm md-end-block" lang="">string = "Hello, {}. Welcome to {}!"
formatted_string = string.format("Alice", "Python")
print(formatted_string)  # 输出: Hello, Alice. Welcome to Python!
</pre><p>在这里，<code>{}</code>中的第一个占位符被替换为 <code>&quot;Alice&quot;</code>，第二个占位符被替换为 <code>&quot;Python&quot;</code>。如果我们改变参数的顺序，它们也会相应地改变。</p><pre class="md-fences mock-cm md-end-block" lang="">formatted_string = string.format("Python", "Alice")
print(formatted_string)  # 输出: Hello, Python. Welcome to Alice!
</pre><h5><a name='header-n846' class='md-header-anchor '></a><strong>3. 命名参数</strong></h5><p>除了位置参数外，<code>format()</code>还支持命名参数。我们可以通过指定参数的名称来填充占位符。</p><pre class="md-fences mock-cm md-end-block" lang="">string = "Hello, {name}. Welcome to {place}!"
formatted_string = string.format(name="Bob", place="Python World")
print(formatted_string)  # 输出: Hello, Bob. Welcome to Python World!
</pre><p>在这个例子中，我们使用了命名参数 <code>{name}</code> 和 <code>{place}</code>，并将对应的值传递给<code>format()</code>方法。这样使得代码更加清晰且易于理解。</p><h5><a name='header-n852' class='md-header-anchor '></a><strong>4. 混合使用位置和命名参数</strong></h5><p>我们还可以将位置参数和命名参数结合使用，但位置参数必须出现在命名参数之前。</p><pre class="md-fences mock-cm md-end-block" lang="">string = "Hello, {}. Welcome to {place}!"
formatted_string = string.format("Alice", place="Python World")
print(formatted_string)  # 输出: Hello, Alice. Welcome to Python World!
</pre><p>在这种情况下，<code>{}</code>被替换为 <code>&quot;Alice&quot;</code>，而 <code>{place}</code>则使用命名参数 <code>&quot;Python World&quot;</code> 来替换。</p><h5><a name='header-n858' class='md-header-anchor '></a><strong>5. 空字符串占位符</strong></h5><p>如果不提供格式化的值，则空占位符 <code>{}</code> 可以直接在字符串中作为占位符使用，等到<code>format()</code>方法调用时再传递实际的值。</p><pre class="md-fences mock-cm md-end-block" lang="">string = "Hello, {}!"
formatted_string = string.format("Alice")
print(formatted_string)  # 输出: Hello, Alice!
</pre><hr /><h4><a name='header-n863' class='md-header-anchor '></a><strong>3.6.2 format()方法的格式控制</strong></h4><p>除了基础的字符串替换，<code>format()</code>方法还允许我们对字符串的格式进行更多的控制。通过格式规范（format specification）来控制输出的对齐、宽度、精度等。格式控制通过冒号 <code>:</code> 来实现，格式控制通常包含字段宽度、填充字符、对齐方式、数值精度等选项。</p><h5><a name='header-n866' class='md-header-anchor '></a><strong>1. 字段宽度和对齐</strong></h5><p>我们可以指定输出字段的最小宽度，并且可以选择对齐方式（左对齐、右对齐或居中对齐）。</p><ul><li><p><strong>右对齐</strong>（默认）：数字和文本会靠右对齐。</p><pre class="md-fences mock-cm md-end-block" lang="">string = "{:10}!"
formatted_string = string.format("Hello")
print(formatted_string)  # 输出: Hello     !
</pre><p>在这个例子中，<code>{:10}</code>表示最小宽度为10个字符，<code>Hello</code>字符串将会右对齐，后面会补充空格。</p></li><li><p><strong>左对齐</strong>：使用 <code>&lt;</code> 来表示左对齐。</p><pre class="md-fences mock-cm md-end-block" lang="">string = "{:&lt;10}!"
formatted_string = string.format("Hello")
print(formatted_string)  # 输出: Hello     !
</pre></li><li><p><strong>居中对齐</strong>：使用 <code>^</code> 来表示居中对齐。</p><pre class="md-fences mock-cm md-end-block" lang="">string = "{:^10}!"
formatted_string = string.format("Hello")
print(formatted_string)  # 输出:   Hello   !
</pre></li></ul><h5><a name='header-n884' class='md-header-anchor '></a><strong>2. 填充字符</strong></h5><p>除了使用空格填充外，我们还可以使用其他字符来填充空白区域，如使用 <code>0</code> 来填充数字。</p><pre class="md-fences mock-cm md-end-block" lang="">string = "{:0&gt;5}"
formatted_string = string.format(42)
print(formatted_string)  # 输出: 00042
</pre><p>在这个例子中，<code>{:0&gt;5}</code>表示字段宽度为5，填充字符为<code>0</code>，并且数字将靠右对齐。</p><h5><a name='header-n890' class='md-header-anchor '></a><strong>3. 数字格式化</strong></h5><p><code>format()</code>方法也允许对数字进行精度控制，例如设置小数点后的位数、显示为百分比或货币格式。</p><ul><li><p><strong>浮动精度控制</strong>：使用 <code>.nf</code> 来设置浮点数的精度。</p><pre class="md-fences mock-cm md-end-block" lang="">string = "Pi is approximately {:.3f}"
formatted_string = string.format(3.14159)
print(formatted_string)  # 输出: Pi is approximately 3.142
</pre><p>在这个例子中，<code>{:.3f}</code>表示输出一个浮点数，并保留3位小数。</p></li><li><p><strong>百分比格式</strong>：通过<code>%</code>来表示百分比格式化。</p><pre class="md-fences mock-cm md-end-block" lang="">string = "The success rate is {:.2%}"
formatted_string = string.format(0.856)
print(formatted_string)  # 输出: The success rate is 85.60%
</pre><p>这里，<code>{:.2%}</code>表示将数字以百分比格式输出，保留两位小数。</p></li></ul><h5><a name='header-n906' class='md-header-anchor '></a><strong>4. 填充和对齐数字</strong></h5><p>当格式化数字时，可以使用对齐字符和填充字符。例如，使用<code>0</code>来填充数字，保证数字的输出宽度。</p><pre class="md-fences mock-cm md-end-block" lang="">string = "The number is: {:0&gt;6}"
formatted_string = string.format(42)
print(formatted_string)  # 输出: The number is: 000042
</pre><p>在这个例子中，<code>{:0&gt;6}</code>表示数字的宽度为6，空白部分用<code>0</code>填充。</p><h5><a name='header-n912' class='md-header-anchor '></a><strong>5. 使用逗号分隔千位数</strong></h5><p>如果你需要格式化大数字并显示千位分隔符，可以使用 <code>,</code> 来格式化数字。</p><pre class="md-fences mock-cm md-end-block" lang="">string = "The number is: {:,}"
formatted_string = string.format(1234567890)
print(formatted_string)  # 输出: The number is: 1,234,567,890
</pre><p>在这个例子中，<code>{:,}</code>表示数字中每三位数字之间使用逗号进行分隔。</p><h5><a name='header-n918' class='md-header-anchor '></a><strong>6. 使用日期时间格式</strong></h5><p><code>format()</code>方法也可以格式化日期和时间。日期时间格式可以通过<code>strftime()</code>样式的格式化字符串来控制输出。</p><pre class="md-fences mock-cm md-end-block" lang="">from datetime import datetime

current_time = datetime.now()
string = "The current time is: {::%Y-%m-%d %H:%M:%S}"
formatted_string = string.format(current_time)
print(formatted_string)  # 输出: The current time is: 2024-12-23 12:34:56
</pre><p>在这个例子中，<code>{:%Y-%m-%d %H:%M:%S}</code>是日期时间格式化字符串，表示输出当前时间的年、月、日、小时、分钟和秒。</p><hr /><h4><a name='header-n925' class='md-header-anchor '></a><strong>总结</strong></h4><p><code>format()</code>方法是Python中处理字符串格式化的重要工具，它提供了强大的功能和灵活的控制。通过<code>format()</code>方法，你可以方便地将变量插入字符串并对其进行各种格式控制，比如对齐、填充、精度控制、数字格式化等。这些功能可以帮助你生成格式化良好的输出，尤其在需要动态生成输出文本时非常有用。掌握这些技巧将帮助你编写更简洁、易读和灵活的代码。</p><h2><a name='header-n928' class='md-header-anchor '></a>第4章 程序的控制结构</h2><p>程序的控制结构决定了程序的执行顺序，控制结构可以根据条件、循环或分支来改变程序的执行路径。在Python中，控制结构是构建程序逻辑的核心部分，本章将详细介绍程序的基本结构、流程图以及具体实现。</p><hr /><h3><a name='header-n932' class='md-header-anchor '></a>4.1 程序的基本结构</h3><p>程序的基本结构通常包括<strong>顺序结构</strong>、<strong>选择结构</strong>（分支结构）和<strong>循环结构</strong>。通过这些基本结构，程序可以实现不同的逻辑控制，从而完成特定任务。</p><h4><a name='header-n935' class='md-header-anchor '></a>4.1.1 程序流程图</h4><p>程序流程图是一种图形化的表示方式，用来表示程序中各个操作步骤的顺序和程序控制流程。流程图中使用不同的符号来表示不同类型的操作，常见的流程图符号包括：</p><ul><li><strong>椭圆形</strong>（开始/结束）：表示程序的起始点或结束点。</li><li><strong>矩形</strong>（处理步骤）：表示一个操作或计算步骤。</li><li><strong>菱形</strong>（决策步骤）：表示判断条件或选择结构，通常包含一个条件表达式，根据条件选择不同路径。</li><li><strong>箭头</strong>：表示操作或控制流的方向。</li></ul><p>在编程过程中，编写程序之前通常会通过流程图来规划程序的逻辑结构。以下是一个简单的程序流程图示例：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">+-----------------+
|   开始          |
+-----------------+
        |
        v
+-----------------+
|   输入数据      |
+-----------------+
        |
        v
+-----------------+
|   判断条件      |
+-----------------+
        |
    +---+---+
    |       |
    v       v
+-----------------+   +-----------------+
|   条件为真      |   |   条件为假      |
|   执行操作A     |   |   执行操作B     |
+-----------------+   +-----------------+
        |
        v
+-----------------+
|   程序结束      |
+-----------------+
</pre><p>此流程图展示了一个简单的决策结构，程序通过判断条件决定是否执行不同的操作。</p><h4><a name='header-n956' class='md-header-anchor '></a>4.1.2 程序的基本结构</h4><p>Python程序的基本结构通常由以下几个部分组成：</p><ol start='' ><li><strong>程序头部</strong>：包括注释、导入模块等内容。程序开始部分可以包含注释来描述程序的功能和重要信息。</li><li><strong>变量声明与赋值</strong>：在程序中使用变量时，需要先进行声明和初始化。Python是动态类型语言，不需要显式声明变量类型。</li><li><strong>执行语句</strong>：程序的主体部分，包含计算、输入输出等操作。</li><li><strong>控制结构</strong>：包括条件判断（if语句）、循环控制（for、while语句）等，根据程序逻辑需要来选择不同的路径或反复执行某些操作。</li><li><strong>函数调用</strong>：如果程序较大，可以通过定义函数来将代码组织成更小的模块，方便管理和复用。</li><li><strong>程序结束</strong>：通过正常结束或异常退出的方式终止程序。</li></ol><p><strong>程序结构示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;"># 1. 程序头部
# 计算BMI的程序

# 2. 输入体重和身高
weight = float(input("请输入体重（公斤）："))
height = float(input("请输入身高（米）："))

# 3. 计算BMI
bmi = weight / (height ** 2)

# 4. 判断BMI类别
if bmi &lt; 18.5:
    print("体重过轻")
elif 18.5 &lt;= bmi &lt; 24.9:
    print("体重正常")
elif 25 &lt;= bmi &lt; 29.9:
    print("超重")
else:
    print("肥胖")

# 5. 程序结束
print("BMI计算结束")
</pre><p>在这个例子中，我们实现了一个计算BMI（身体质量指数）的程序。输入体重和身高后，程序会根据条件判断BMI的类别，最终输出结果。</p><hr /><h4><a name='header-n984' class='md-header-anchor '></a>4.1.3 程序的基本结构实例</h4><p>以下是一个简单的Python程序实例，演示如何使用基本的结构和控制流来解决实际问题。</p><p><strong>示例：根据输入的数字判断正负</strong></p><pre class="md-fences mock-cm md-end-block" lang=""># 输入一个整数
number = int(input("请输入一个整数："))

# 判断数字是正数、负数还是零
if number &gt; 0:
    print("正数")
elif number &lt; 0:
    print("负数")
else:
    print("零")
</pre><p><strong>分析：</strong></p><ul><li><strong>输入部分</strong>：使用<code>input()</code>函数获取用户输入，并转换为整数类型。</li><li><strong>控制结构</strong>：使用<code>if-elif-else</code>语句判断输入的数字是正数、负数还是零。</li><li><strong>输出部分</strong>：根据判断结果，打印相应的字符串。</li></ul><hr /><h3><a name='header-n1003' class='md-header-anchor '></a>总结</h3><p>本节介绍了Python程序的基本结构和程序流程图的应用。理解程序的控制结构和基本架构是编写高效且易于维护程序的关键。通过使用条件判断、循环控制等结构，可以让程序根据不同的需求进行灵活的决策和操作。而流程图则有助于在编写程序之前规划出清晰的逻辑结构。</p><h3><a name='header-n1006' class='md-header-anchor '></a>4.2 程序的分支结构</h3><p>程序的分支结构是控制程序流的一种机制，通过条件判断决定程序执行的不同路径。在Python中，分支结构主要包括<strong>单分支</strong>、<strong>二分支</strong>和<strong>多分支</strong>，它们通过<code>if</code>语句及其组合来实现条件判断。</p><p>在本节中，我们将详细介绍每种分支结构，并给出相应的代码示例。</p><hr /><h4><a name='header-n1012' class='md-header-anchor '></a>4.2.1 单分支结构：<code>if</code>语句</h4><p>单分支结构是最简单的分支结构。它根据条件判断是否执行某一段代码。当条件为<code>True</code>时，执行相关的代码块；否则跳过该代码块。</p><h4><a name='header-n1015' class='md-header-anchor '></a><strong>语法：</strong></h4><pre class="md-fences mock-cm md-end-block" lang="">if condition:
    # 执行代码
</pre><ul><li><code>condition</code> 是一个布尔表达式（即条件），如果为<code>True</code>，则执行紧随其后的代码块。</li><li>如果条件为<code>False</code>，则跳过该代码块，继续执行后面的代码。</li></ul><h4><a name='header-n1024' class='md-header-anchor '></a><strong>示例：</strong></h4><pre class="md-fences mock-cm md-end-block" lang=""># 判断一个数字是否为正数
number = int(input("请输入一个数字："))

if number &gt; 0:
    print("该数字是正数")
</pre><p>在这个例子中，程序通过<code>if</code>语句判断用户输入的数字是否大于0，如果是正数，则打印<code>&quot;该数字是正数&quot;</code>。</p><h5><a name='header-n1028' class='md-header-anchor '></a><strong>工作原理：</strong></h5><ul><li>如果<code>number</code>大于0，<code>if</code>语句中的代码会被执行，打印出&quot;该数字是正数&quot;。</li><li>如果<code>number</code>小于等于0，<code>if</code>语句中的代码不会被执行，程序会继续执行后面的代码（如果有）。</li></ul><hr /><h4><a name='header-n1037' class='md-header-anchor '></a>4.2.2 二分支结构：<code>if - else</code>语句</h4><p>二分支结构是在单分支的基础上扩展的。它通过增加<code>else</code>部分，在条件不满足时执行另一段代码。即当<code>if</code>条件为<code>True</code>时，执行<code>if</code>后的代码块；当<code>if</code>条件为<code>False</code>时，执行<code>else</code>后的代码块。</p><h5><a name='header-n1040' class='md-header-anchor '></a><strong>语法：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">if condition:
    # 执行代码
else:
    # 执行其他代码
</pre><ul><li>如果<code>condition</code>为<code>True</code>，则执行<code>if</code>代码块。</li><li>如果<code>condition</code>为<code>False</code>，则执行<code>else</code>代码块。</li></ul><h5><a name='header-n1049' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang=""># 判断一个数字是正数还是负数
number = int(input("请输入一个数字："))

if number &gt; 0:
    print("该数字是正数")
else:
    print("该数字是负数或零")
</pre><p>在这个例子中，程序判断用户输入的数字是否大于0。如果条件成立，打印出&quot;该数字是正数&quot;，否则打印出&quot;该数字是负数或零&quot;。</p><h5><a name='header-n1053' class='md-header-anchor '></a><strong>工作原理：</strong></h5><ul><li>如果<code>number</code>大于0，执行<code>if</code>部分的代码，打印&quot;该数字是正数&quot;。</li><li>如果<code>number</code>小于等于0，执行<code>else</code>部分的代码，打印&quot;该数字是负数或零&quot;。</li></ul><hr /><h4><a name='header-n1062' class='md-header-anchor '></a>4.2.3 多分支结构：<code>if - elif - else</code>语句</h4><p>多分支结构提供了更多的分支选项，通过<code>elif</code>（即<code>else if</code>）语句来处理多个条件判断。这使得我们可以在一个程序中处理多个不同的情况，而不必将多个<code>if</code>语句嵌套在一起。</p><h5><a name='header-n1065' class='md-header-anchor '></a><strong>语法：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">if condition1:
    # 执行代码1
elif condition2:
    # 执行代码2
elif condition3:
    # 执行代码3
else:
    # 执行其他代码
</pre><ul><li>当<code>condition1</code>为<code>True</code>时，执行第一个代码块。</li><li>如果<code>condition1</code>为<code>False</code>，则判断<code>condition2</code>，如果为<code>True</code>，执行第二个代码块，以此类推。</li><li>如果所有的条件都为<code>False</code>，则执行<code>else</code>部分的代码（如果有）。</li></ul><h5><a name='header-n1077' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang=""># 判断数字的范围
number = int(input("请输入一个数字："))

if number &gt; 0:
    print("该数字是正数")
elif number &lt; 0:
    print("该数字是负数")
else:
    print("该数字是零")
</pre><p>在这个例子中，程序判断用户输入的数字是正数、负数还是零。根据不同的条件，程序输出相应的结果。</p><h5><a name='header-n1081' class='md-header-anchor '></a><strong>工作原理：</strong></h5><ul><li>如果<code>number &gt; 0</code>，执行<code>if</code>部分的代码，打印&quot;该数字是正数&quot;。</li><li>如果<code>number &lt; 0</code>（<code>if</code>条件为<code>False</code>，但<code>elif</code>条件为<code>True</code>），执行<code>elif</code>部分的代码，打印&quot;该数字是负数&quot;。</li><li>如果<code>number == 0</code>（<code>if</code>和<code>elif</code>条件都为<code>False</code>），执行<code>else</code>部分的代码，打印&quot;该数字是零&quot;。</li></ul><hr /><h4><a name='header-n1093' class='md-header-anchor '></a>总结</h4><p>本节介绍了Python中三种常用的分支结构：</p><ol start='' ><li><strong>单分支结构</strong>：使用<code>if</code>语句，根据一个条件判断是否执行某个代码块。</li><li><strong>二分支结构</strong>：使用<code>if - else</code>语句，根据条件判断执行两个不同的代码块。</li><li><strong>多分支结构</strong>：使用<code>if - elif - else</code>语句，根据多个条件判断执行不同的代码块。</li></ol><p>这些分支结构是程序中常见的逻辑控制工具，帮助程序根据不同的条件执行不同的操作。掌握这些控制结构，可以编写更具逻辑性、灵活性和可维护性的代码。</p><h3><a name='header-n1108' class='md-header-anchor '></a>4.3 实例5：身体质量指数（BMI）</h3><p>身体质量指数（BMI，Body Mass Index）是衡量一个人是否超重或肥胖的指标。它的计算公式为：</p><p>BMI=体重（kg）身高（m）2BMI = \frac{{体重（kg）}}{{身高（m）^2}}</p><p>根据BMI的值，可以将一个人的体重状况分为不同的类别。通常，BMI值的分类标准如下：</p><ul><li><strong>BMI &lt; 18.5</strong>：体重过轻</li><li><strong>18.5 ≤ BMI &lt; 24.9</strong>：正常体重</li><li><strong>25 ≤ BMI &lt; 29.9</strong>：超重</li><li><strong>BMI ≥ 30</strong>：肥胖</li></ul><h5><a name='header-n1128' class='md-header-anchor '></a><strong>实例代码：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;"># 获取用户输入的体重和身高
weight = float(input("请输入体重（公斤）："))
height = float(input("请输入身高（米）："))

# 计算BMI
bmi = weight / (height ** 2)

# 根据BMI值判断体重状况
if bmi &lt; 18.5:
    print(f"你的BMI是{bmi:.2f}，属于体重过轻。")
elif 18.5 &lt;= bmi &lt; 24.9:
    print(f"你的BMI是{bmi:.2f}，属于正常体重。")
elif 25 &lt;= bmi &lt; 29.9:
    print(f"你的BMI是{bmi:.2f}，属于超重。")
else:
    print(f"你的BMI是{bmi:.2f}，属于肥胖。")
</pre><h5><a name='header-n1130' class='md-header-anchor '></a><strong>功能解释：</strong></h5><ol start='' ><li><strong>输入体重和身高</strong>：使用<code>input()</code>函数获取用户输入的体重和身高，并将其转换为浮点数。</li><li><strong>计算BMI</strong>：通过公式计算BMI值，公式为体重除以身高的平方。</li><li><strong>判断BMI范围</strong>：使用<code>if - elif - else</code>语句判断BMI值所对应的体重状况，并打印出相应的信息。</li></ol><h5><a name='header-n1141' class='md-header-anchor '></a><strong>示例输出：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">请输入体重（公斤）：70
请输入身高（米）：1.75
你的BMI是22.86，属于正常体重。
</pre><p>这个示例代码展示了如何通过输入体重和身高计算BMI值，并根据值判断并输出相应的体重状况。</p><hr /><h3><a name='header-n1146' class='md-header-anchor '></a>4.4 程序的循环结构</h3><p>程序中的循环结构是用来反复执行某段代码的机制，通常会在满足某些条件时停止。Python中常用的循环结构有<strong><code>for</code>循环</strong>和<strong><code>while</code>循环</strong>。此外，Python还提供了循环控制字<strong><code>break</code></strong>和<strong><code>continue</code></strong>，用于提前结束循环或跳过当前循环。</p><hr /><h4><a name='header-n1150' class='md-header-anchor '></a>4.4.1 遍历循环：<code>for</code>语句</h4><p><code>for</code>语句用于遍历序列（如列表、元组、字符串等）中的每个元素，执行相应的操作。<code>for</code>语句会自动处理迭代过程，不需要显式地指定索引。</p><h5><a name='header-n1153' class='md-header-anchor '></a><strong>语法：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">for variable in iterable:
    # 执行代码块
</pre><ul><li><code>variable</code>：迭代过程中的每个元素。</li><li><code>iterable</code>：可迭代对象，可以是列表、元组、字符串、字典等。</li></ul><h5><a name='header-n1162' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang=""># 遍历一个数字列表并打印每个数字
numbers = [1, 2, 3, 4, 5]

for num in numbers:
    print(num)
</pre><p><strong>输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">1
2
3
4
5
</pre><p>在这个示例中，<code>for</code>语句依次取出列表<code>numbers</code>中的每个数字并打印。</p><h5><a name='header-n1169' class='md-header-anchor '></a><strong>示例：使用for遍历字符串</strong></h5><pre class="md-fences mock-cm md-end-block" lang=""># 遍历字符串并打印每个字符
word = "Python"

for char in word:
    print(char)
</pre><p><strong>输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">P
y
t
h
o
n
</pre><hr /><h4><a name='header-n1175' class='md-header-anchor '></a>4.4.2 无限循环：<code>while</code>语句</h4><p><code>while</code>语句用于在某个条件为<code>True</code>时反复执行代码块。当条件为<code>False</code>时，循环终止。<code>while</code>语句通常用于需要不断检查条件是否成立的情况。</p><h5><a name='header-n1178' class='md-header-anchor '></a><strong>语法：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">while condition:
    # 执行代码块
</pre><ul><li><code>condition</code>：一个布尔表达式，只要条件为<code>True</code>，就会继续执行循环。</li></ul><h5><a name='header-n1184' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang=""># 使用while循环输出1到5的数字
num = 1

while num &lt;= 5:
    print(num)
    num += 1  # 更新num的值，避免死循环
</pre><p><strong>输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">1
2
3
4
5
</pre><p>在这个例子中，<code>while</code>循环会一直执行，直到<code>num</code>大于5时停止。</p><h5><a name='header-n1191' class='md-header-anchor '></a><strong>示例：无限循环</strong></h5><pre class="md-fences mock-cm md-end-block" lang=""># 无限循环，直到用户输入"exit"时才停止
while True:
    command = input("请输入命令（输入'exit'退出）：")
    if command == "exit":
        print("退出程序")
        break  # 使用break退出循环
    else:
        print(f"你输入的命令是：{command}")
</pre><p><strong>解释：</strong></p><ul><li>这段代码会不断提示用户输入命令，当用户输入&quot;exit&quot;时，程序退出。</li><li><code>while True</code>创建了一个无限循环，只有当<code>command == &quot;exit&quot;</code>时，通过<code>break</code>语句跳出循环。</li></ul><hr /><h4><a name='header-n1203' class='md-header-anchor '></a>4.4.3 循环控制字：<code>break</code>和<code>continue</code></h4><ul><li><strong>break</strong>：用来终止整个循环，跳出循环体。当循环满足特定条件时，<code>break</code>会停止执行当前的循环，跳出循环块。</li><li><strong>continue</strong>：用来跳过当前循环中的剩余部分，直接进入下一次循环。它不会终止整个循环，而是跳过当前的某次迭代。</li></ul><h5><a name='header-n1211' class='md-header-anchor '></a><strong>break示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang=""># 输出1到5，遇到3时停止
for num in range(1, 6):
    if num == 3:
        break  # 遇到3时退出循环
    print(num)
</pre><p><strong>输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">1
2
</pre><p>在这个例子中，当<code>num</code>等于3时，<code>break</code>语句终止了整个循环。</p><h5><a name='header-n1218' class='md-header-anchor '></a><strong>continue示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang=""># 输出1到5，跳过3
for num in range(1, 6):
    if num == 3:
        continue  # 跳过3
    print(num)
</pre><p><strong>输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">1
2
4
5
</pre><p>在这个例子中，当<code>num</code>等于3时，<code>continue</code>语句跳过了当前的循环步骤，直接进入下一次循环。</p><hr /><h3><a name='header-n1226' class='md-header-anchor '></a>总结</h3><ul><li><strong>for循环</strong>：用于遍历序列或可迭代对象，适用于知道迭代次数的情况。</li><li><strong>while循环</strong>：用于在某个条件为<code>True</code>时反复执行代码，适用于需要满足特定条件才能停止的情况。</li><li><strong>break</strong>：用于退出整个循环，通常用于在特定条件下提前终止循环。</li><li><strong>continue</strong>：用于跳过当前循环的剩余部分，继续下一次迭代。</li></ul><p>掌握这些循环结构和控制字，使得程序能够更加灵活地处理不同的场景和需求。</p><h3><a name='header-n1242' class='md-header-anchor '></a>4.5 模块2：<code>random</code>库的使用</h3><p><code>random</code>库是Python标准库中的一个模块，提供了生成随机数的功能。它可以生成伪随机数（即计算机生成的随机数），这些随机数适用于各种应用场景，例如模拟随机事件、游戏中的随机生成、数据处理等。</p><p>在<code>random</code>库中，常见的函数可以生成整数、浮点数、从序列中随机选择元素、打乱序列等功能。掌握这些常用函数，可以帮助你在编程中更高效地使用随机数。</p><hr /><h4><a name='header-n1248' class='md-header-anchor '></a>4.5.1 <code>random</code>库概述</h4><p><code>random</code>模块包含了一系列用于生成随机数和进行随机操作的函数。它基于伪随机数生成器（PRNG，Pseudo-Random Number Generator），这意味着它生成的“随机”数是通过特定的算法生成的，虽然看起来是随机的，但其实是确定性的。Python中的<code>random</code>模块生成的伪随机数并不适合用于加密等对安全性要求极高的场景，但在一般的应用中非常有效。</p><p>常见的用途包括：</p><ul><li>生成随机数（整数、浮点数）</li><li>从序列中随机选择元素</li><li>打乱序列</li><li>进行随机抽样</li></ul><hr /><h4><a name='header-n1267' class='md-header-anchor '></a>4.5.2 <code>random</code>库解析</h4><p><code>random</code>模块的常用函数非常丰富，下面将详细介绍一些最常用的函数。</p><h5><a name='header-n1270' class='md-header-anchor '></a>1. <strong>random.random()</strong></h5><p><code>random.random()</code>返回一个范围在[0.0, 1.0)之间的随机浮点数。</p><h5><a name='header-n1273' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">import random

# 生成一个0到1之间的随机浮点数
num = random.random()
print(num)
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">0.2763489576182442
</pre><p>该函数返回一个[0, 1)区间的随机浮点数，可以用于生成概率、模拟随机事件等。</p><h5><a name='header-n1280' class='md-header-anchor '></a>2. <strong>random.randint(a, b)</strong></h5><p><code>random.randint(a, b)</code>返回一个范围在[a, b]之间的随机整数。这个函数包括边界值<code>a</code>和<code>b</code>。</p><h5><a name='header-n1283' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">import random

# 生成一个1到10之间的随机整数
num = random.randint(1, 10)
print(num)
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">7
</pre><p>此函数常用于需要生成随机整数的场景，如随机选择编号、模拟骰子掷点等。</p><h5><a name='header-n1290' class='md-header-anchor '></a>3. <strong>random.uniform(a, b)</strong></h5><p><code>random.uniform(a, b)</code>返回一个范围在[a, b]之间的随机浮点数，<code>a</code>和<code>b</code>可以是浮点数或整数。与<code>random.random()</code>不同，<code>uniform()</code>返回的是一个在指定范围内的浮点数。</p><h5><a name='header-n1293' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">import random

# 生成一个3.0到5.0之间的随机浮点数
num = random.uniform(3.0, 5.0)
print(num)
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">4.456789123
</pre><p>这个函数适用于需要指定范围并且返回浮动值的情况，例如模拟温度、概率等。</p><h5><a name='header-n1300' class='md-header-anchor '></a>4. <strong>random.choice(seq)</strong></h5><p><code>random.choice(seq)</code>从非空序列（如列表、元组、字符串）中随机选择一个元素并返回。<code>seq</code>必须是一个可迭代对象。</p><h5><a name='header-n1303' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">import random

# 从列表中随机选择一个元素
fruits = ['apple', 'banana', 'cherry', 'date']
fruit = random.choice(fruits)
print(fruit)
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">banana
</pre><p>这个函数非常适合在一个集合中随机选择一个元素，如从选项中随机选择、模拟抽签等。</p><h4><a name='header-n1310' class='md-header-anchor '></a>5. <strong>random.shuffle(seq)</strong></h4><p><code>random.shuffle(seq)</code>用于将序列中的元素打乱，打乱是原地进行的，即修改原序列本身。该函数不返回任何值，而是直接修改传入的序列。</p><h5><a name='header-n1313' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">import random

# 打乱一个列表的顺序
cards = [1, 2, 3, 4, 5]
random.shuffle(cards)
print(cards)
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">[3, 1, 4, 2, 5]
</pre><p>这个函数广泛用于打乱牌堆、随机排列数据等场景。</p><h5><a name='header-n1320' class='md-header-anchor '></a>6. <strong>random.sample(seq, k)</strong></h5><p><code>random.sample(seq, k)</code>返回一个由<code>seq</code>中随机选出的<code>k</code>个元素组成的新列表。不同于<code>choice()</code>，<code>sample()</code>可以选择多个元素，并且不会重复选择相同的元素。</p><h5><a name='header-n1323' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">import random

# 从列表中随机选择3个元素
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
sampled = random.sample(numbers, 3)
print(sampled)
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">[4, 9, 2]
</pre><p>该函数适用于抽样调查、抽取随机数据等场景。</p><h5><a name='header-n1330' class='md-header-anchor '></a>7. <strong>random.seed(a=None)</strong></h5><p><code>random.seed(a=None)</code>用来初始化随机数生成器的种子。如果提供相同的种子值，<code>random</code>生成的随机数将是相同的，适用于测试和调试。</p><h5><a name='header-n1333' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">import random

random.seed(10)  # 设置种子
print(random.random())  # 每次运行时都会返回相同的随机数
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">0.5714025946899135
</pre><p><code>seed()</code>函数常用于希望在不同的程序运行中保持一致的随机序列，尤其是在测试和模拟中。</p><h5><a name='header-n1340' class='md-header-anchor '></a>8. <strong>random.randint()和random.randrange()</strong></h5><ul><li><code>random.randint(a, b)</code>：生成[<strong>a</strong>, <strong>b</strong>]之间的随机整数，包含边界。</li><li><code>random.randrange(start, stop[, step])</code>：返回一个范围在[start, stop)之间，且步长为<code>step</code>的随机整数，<strong>不包含</strong><code>stop</code>。</li></ul><h5><a name='header-n1348' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">import random

# randint示例
num1 = random.randint(1, 10)
print(num1)

# randrange示例
num2 = random.randrange(1, 10, 2)  # 步长为2
print(num2)
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">7
5
</pre><p><code>randrange()</code>与<code>range()</code>相似，但返回的是随机整数，适合需要指定步长的随机数生成。</p><hr /><h4><a name='header-n1356' class='md-header-anchor '></a>总结</h4><p><code>random</code>库为Python程序提供了多种生成随机数和随机操作序列的功能。常用的函数包括：</p><ul><li><code>random.random()</code>：生成0到1之间的随机浮点数。</li><li><code>random.randint(a, b)</code>：生成[a, b]之间的随机整数。</li><li><code>random.uniform(a, b)</code>：生成[a, b]之间的随机浮点数。</li><li><code>random.choice(seq)</code>：从序列中随机选择一个元素。</li><li><code>random.shuffle(seq)</code>：打乱序列中的元素。</li><li><code>random.sample(seq, k)</code>：从序列中随机选出k个元素。</li><li><code>random.seed(a=None)</code>：初始化随机数生成器的种子，确保可重复性。</li></ul><p>掌握这些函数，可以有效地在程序中进行随机数生成和随机操作，适应各种应用场景。</p><h3><a name='header-n1383' class='md-header-anchor '></a>4.6 实例6：π的计算</h3><p>在编程中，计算圆周率π是一个经典的数学问题。π的计算方法有许多，其中最著名的可能是蒙特卡洛方法和莱布尼茨级数法。</p><h5><a name='header-n1386' class='md-header-anchor '></a><strong>蒙特卡洛方法</strong></h5><p>蒙特卡洛方法是通过随机模拟来估计π值的。该方法利用概率统计原理，通常通过在一个单位正方形中随机撒点，计算落在单位圆内的点的比例，从而估计圆周率π的值。</p><h5><a name='header-n1389' class='md-header-anchor '></a><strong>蒙特卡洛方法的原理：</strong></h5><ol start='' ><li>在一个边长为1的正方形中，画一个内切圆。这个圆的半径为0.5，因此其面积为π/4。</li><li>随机生成一定数量的点，这些点的坐标在[0, 1]的范围内。</li><li>计算每个点是否在圆内，即点的坐标(x, y)满足 x2+y2≤0.25x^2 + y^2 \leq 0.25。</li><li>计算落在圆内的点占所有点的比例。这个比例大约等于圆的面积与正方形的面积之比，即π/4。</li><li>从这个比例推算π的值。</li></ol><h5><a name='header-n1406' class='md-header-anchor '></a><strong>实例代码：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">import random

def estimate_pi(num_samples):
    inside_circle = 0

    for _ in range(num_samples):
        x = random.random()  # 随机生成x坐标
        y = random.random()  # 随机生成y坐标
        if x**2 + y**2 &lt;= 1:  # 判断点是否在单位圆内
            inside_circle += 1

    # 计算π的估算值
    return (inside_circle / num_samples) * 4

# 估算π的值，使用100000次随机模拟
pi_estimate = estimate_pi(100000)
print(f"估算的π值为: {pi_estimate}")
</pre><h5><a name='header-n1408' class='md-header-anchor '></a><strong>解释：</strong></h5><ol start='' ><li><strong>生成随机点</strong>：通过<code>random.random()</code>生成0到1之间的随机数作为点的x和y坐标。</li><li><strong>判断是否在圆内</strong>：通过判断 x2+y2≤1x^2 + y^2 \leq 1 来确定点是否在单位圆内。</li><li><strong>估算π</strong>：通过计算单位圆内的点占总点的比例，来估算π的值。</li></ol><p><strong>示例输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">估算的π值为: 3.14144
</pre><p>随着模拟次数的增加，计算出来的π值会越来越接近真实值。</p><hr /><h3><a name='header-n1425' class='md-header-anchor '></a>4.7 程序的异常处理</h3><p>在编写程序时，可能会遇到一些不可预见的错误或异常。例如，除以零、文件未找到、类型不匹配等。为了防止程序崩溃，Python提供了<strong>异常处理机制</strong>，可以捕获并处理这些异常，确保程序能够优雅地应对错误情况。</p><p>Python中的异常处理主要通过<code>try</code>和<code>except</code>语句来实现。</p><hr /><h4><a name='header-n1431' class='md-header-anchor '></a>4.7.1 异常处理：<code>try</code> - <code>except</code>语句</h4><p><code>try</code>语句用于包含可能会引发异常的代码，而<code>except</code>语句用于捕获并处理这些异常。若<code>try</code>代码块中的代码抛出了异常，则会跳转到相应的<code>except</code>代码块进行处理。</p><h5><a name='header-n1434' class='md-header-anchor '></a><strong>语法：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">try:
    # 可能抛出异常的代码
except (ExceptionType1, ExceptionType2) as e:
    # 处理异常的代码
    # 可以使用e来获取异常的具体信息
else:
    # 如果没有异常发生，执行的代码
finally:
    # 无论是否发生异常，都会执行的代码
</pre><ul><li><code>try</code>块：包含可能引发异常的代码。</li><li><code>except</code>块：处理捕获到的异常。可以指定多个异常类型。</li><li><code>else</code>块：当<code>try</code>块没有抛出异常时执行的代码。</li><li><code>finally</code>块：无论是否发生异常，都会执行的代码，通常用于资源清理。</li></ul><h5><a name='header-n1449' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">try:
    num = int(input("请输入一个整数："))
    result = 10 / num
except ZeroDivisionError:
    print("错误：不能除以零！")
except ValueError:
    print("错误：请输入一个有效的整数！")
else:
    print(f"结果是：{result}")
finally:
    print("程序结束。")
</pre><p><strong>解释：</strong></p><ol start='' ><li><p><strong>try块</strong>：用户输入一个整数并计算10除以该整数的结果。</p></li><li><p><code>except</code>块</p><p>：捕获两种异常：</p><ul><li><code>ZeroDivisionError</code>：如果输入为0，避免除以零错误。</li><li><code>ValueError</code>：如果输入的不是整数，则捕获输入错误。</li></ul></li><li><p><strong>else块</strong>：如果没有异常发生，输出计算结果。</p></li><li><p><strong>finally块</strong>：无论是否有异常发生，都会执行“程序结束”这一行。</p></li></ol><p><strong>示例输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">请输入一个整数：5
结果是：2.0
程序结束。
</pre><p><strong>示例输出（输入0）：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">请输入一个整数：0
错误：不能除以零！
程序结束。
</pre><hr /><h4><a name='header-n1482' class='md-header-anchor '></a>4.7.2 异常的高级用法</h4><p>异常不仅可以处理常见的错误，还可以进行更复杂的异常链处理和自定义异常。</p><h5><a name='header-n1485' class='md-header-anchor '></a><strong>1. 捕获多个异常</strong></h5><p><code>try</code>语句可以捕获多种类型的异常。可以通过多个<code>except</code>块逐个捕获不同类型的异常，或者使用一个<code>except</code>块来捕获多个异常。</p><h5><a name='header-n1488' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">try:
    num = int(input("请输入一个整数："))
    result = 10 / num
except (ZeroDivisionError, ValueError) as e:
    print(f"发生了错误：{e}")
else:
    print(f"结果是：{result}")
finally:
    print("程序结束。")
</pre><h5><a name='header-n1490' class='md-header-anchor '></a><strong>2. 自定义异常</strong></h5><p>Python允许你定义自己的异常类。自定义异常类通常是从<code>Exception</code>类继承，并可以包含额外的信息。</p><h5><a name='header-n1493' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">class MyError(Exception):
    def __init__(self, message):
        self.message = message
        super().__init__(self.message)

try:
    raise MyError("这是一个自定义的错误！")
except MyError as e:
    print(f"捕获到自定义错误：{e}")
</pre><p><strong>解释：</strong></p><ol start='' ><li>自定义异常类<code>MyError</code>继承自<code>Exception</code>。</li><li>在<code>try</code>块中，使用<code>raise</code>关键字抛出自定义的异常。</li><li><code>except</code>块捕获并处理该自定义异常。</li></ol><p><strong>示例输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">捕获到自定义错误：这是一个自定义的错误！
</pre><h5><a name='header-n1510' class='md-header-anchor '></a><strong>3. 异常链</strong></h5><p>Python允许在处理一个异常时抛出另一个异常，这称为异常链。你可以使用<code>raise</code>语句重新抛出异常，并附带原始异常的信息。</p><h5><a name='header-n1513' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">try:
    x = 10 / 0
except ZeroDivisionError as e:
    print(f"捕获到异常：{e}")
    raise ValueError("重新抛出一个新的错误") from e
</pre><p><strong>解释：</strong></p><ul><li>在<code>except</code>块中捕获<code>ZeroDivisionError</code>异常后，使用<code>raise</code>语句抛出一个新的<code>ValueError</code>异常，并通过<code>from</code>将原始异常链接到新抛出的异常上。</li></ul><p><strong>示例输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">捕获到异常：division by zero
Traceback (most recent call last):
  File "example.py", line 5, in &lt;module&gt;
    raise ValueError("重新抛出一个新的错误") from e
ValueError: 重新抛出一个新的错误
</pre><hr /><h4><a name='header-n1525' class='md-header-anchor '></a>总结</h4><p>异常处理是编程中的一项重要技能，能够帮助程序在面对错误时仍能继续运行或给出合理的错误提示。Python提供了简单而灵活的异常处理机制：</p><ul><li><strong>try - except语句</strong>：捕获并处理异常。</li><li><strong>else块</strong>：在没有异常时执行。</li><li><strong>finally块</strong>：无论是否有异常都会执行。</li><li><strong>自定义异常</strong>：可以定义自己的异常类。</li><li><strong>异常链</strong>：可以在捕获异常后抛出新异常并附带原始异常。</li></ul><p>通过合理地使用异常处理，可以大大提高程序的稳定性和可维护性。</p><h2><a name='header-n1546' class='md-header-anchor '></a>第5章 函数和代码复用</h2><p>函数是编程中的基本构件，它允许我们将程序逻辑分解成小的、可重复使用的模块。函数不仅有助于代码的复用，还提高了代码的可读性、可维护性和组织性。本章将详细介绍Python中函数的基本使用，包括函数的定义、调用过程、以及<code>lambda</code>函数等高级用法。</p><hr /><h3><a name='header-n1550' class='md-header-anchor '></a>5.1 函数的基本使用</h3><p>函数在Python中是通过<code>def</code>关键字来定义的。一个函数可以接受输入（称为参数或形参），执行某些操作，并返回一个输出（称为返回值）。函数使得代码更具可读性、易于维护和复用。</p><h4><a name='header-n1553' class='md-header-anchor '></a>5.1.1 函数的定义</h4><p>函数的定义包括三部分：函数名、参数列表和函数体。Python通过<code>def</code>关键字定义一个函数。</p><h5><a name='header-n1556' class='md-header-anchor '></a><strong>函数的基本语法：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def function_name(parameters):
    # 函数体
    return result
</pre><ul><li><strong>def</strong>：关键字，用来定义一个函数。</li><li><strong>function_name</strong>：函数的名称，用于调用函数。</li><li><strong>parameters</strong>：输入的参数，函数接受这些参数并在函数体内使用。</li><li><strong>return</strong>：返回值。函数的计算结果将通过<code>return</code>返回给调用者。</li></ul><h5><a name='header-n1571' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def greet(name):
    """这个函数接受一个名字作为参数并返回一个问候语"""
    return f"Hello, {name}!"

# 调用函数
message = greet("Alice")
print(message)  # 输出：Hello, Alice!
</pre><p><strong>解释：</strong></p><ul><li>这个函数<code>greet</code>接受一个参数<code>name</code>，并返回一个格式化的字符串<code>&quot;Hello, {name}!&quot;</code>。</li><li>调用时，传递了参数<code>&quot;Alice&quot;</code>，所以返回的结果是<code>&quot;Hello, Alice!&quot;</code>。</li></ul><h5><a name='header-n1582' class='md-header-anchor '></a><strong>默认参数值</strong></h5><p>在函数定义时，你可以为参数指定默认值。如果在调用时没有传递该参数，函数会使用默认值。</p><h5><a name='header-n1585' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def greet(name="Guest"):
    """如果没有传入name参数，默认使用"Guest""""
    return f"Hello, {name}!"

# 调用函数
print(greet())         # 输出：Hello, Guest!
print(greet("Bob"))    # 输出：Hello, Bob!
</pre><p><strong>解释：</strong></p><ul><li>参数<code>name</code>有一个默认值<code>&quot;Guest&quot;</code>，如果调用时没有传递该参数，函数会使用这个默认值。</li></ul><h5><a name='header-n1593' class='md-header-anchor '></a><strong>关键字参数和位置参数</strong></h5><ul><li><strong>位置参数</strong>：传递给函数的参数按位置传递。</li><li><strong>关键字参数</strong>：使用<code>key=value</code>的方式传递参数，这样可以不按照参数顺序传递参数。</li></ul><h5><a name='header-n1601' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def describe_person(name, age, city):
    return f"{name} is {age} years old and lives in {city}."

# 使用位置参数
print(describe_person("Alice", 30, "New York"))

# 使用关键字参数
print(describe_person(age=30, name="Alice", city="New York"))
</pre><p><strong>输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">Alice is 30 years old and lives in New York.
Alice is 30 years old and lives in New York.
</pre><p><strong>解释：</strong></p><ul><li>位置参数要求传入参数的顺序与函数定义一致。</li><li>关键字参数允许你指定每个参数的名称，可以不按照顺序传参。</li></ul><h4><a name='header-n1615' class='md-header-anchor '></a><strong>返回值</strong></h4><p><code>return</code>语句用于返回函数的结果。一个函数可以有一个返回值，也可以没有返回值（此时默认返回<code>None</code>）。</p><h5><a name='header-n1618' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def add(a, b):
    return a + b

result = add(3, 5)
print(result)  # 输出：8
</pre><p><strong>解释：</strong></p><ul><li>函数<code>add</code>接受两个参数，返回它们的和。</li></ul><hr /><h5><a name='header-n1627' class='md-header-anchor '></a>5.1.2 函数的调用过程</h5><p>在Python中，函数的调用过程包括传递参数、执行函数体、返回结果等几个步骤。</p><h4><a name='header-n1630' class='md-header-anchor '></a><strong>函数调用的步骤：</strong></h4><ol start='' ><li><strong>传递参数</strong>：调用函数时，程序将实际参数（值）传递给函数的形参。</li><li><strong>执行函数体</strong>：函数内部的代码开始执行，使用传入的参数进行计算或操作。</li><li><strong>返回结果</strong>：执行到<code>return</code>语句时，函数将计算结果返回给调用者。如果没有<code>return</code>，函数将默认返回<code>None</code>。</li></ol><h4><a name='header-n1641' class='md-header-anchor '></a><strong>示例：</strong></h4><pre class="md-fences mock-cm md-end-block" lang="">def multiply(a, b):
    result = a * b
    return result

# 调用函数
output = multiply(4, 5)
print(output)  # 输出：20
</pre><p><strong>解释：</strong></p><ul><li>传入参数<code>4</code>和<code>5</code>，执行乘法操作，返回结果<code>20</code>。</li></ul><h5><a name='header-n1649' class='md-header-anchor '></a><strong>递归函数</strong></h5><p>递归函数是一个在定义中调用自身的函数。递归通常用于解决具有重复结构的问题，如树形结构遍历、斐波那契数列等。</p><h5><a name='header-n1652' class='md-header-anchor '></a><strong>示例：计算阶乘</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(5))  # 输出：120
</pre><p><strong>解释：</strong></p><ul><li><code>factorial</code>函数通过递归计算给定数字的阶乘。</li><li>递归调用直到<code>n == 1</code>时停止。</li></ul><hr /><h4><a name='header-n1664' class='md-header-anchor '></a>5.1.3 <code>lambda</code>函数</h4><p><code>lambda</code>函数，也称为匿名函数，是一种轻量级的函数定义方式。<code>lambda</code>函数可以在一行代码中定义，通常用于定义简单的、短小的函数。</p><h4><a name='header-n1667' class='md-header-anchor '></a><strong>lambda函数的语法：</strong></h4><pre class="md-fences mock-cm md-end-block" lang="">lambda arguments: expression
</pre><ul><li><code>arguments</code>：输入参数，可以是多个参数。</li><li><code>expression</code>：函数体，返回一个计算结果。</li></ul><h5><a name='header-n1676' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang=""># 定义一个lambda函数，计算两个数的和
add = lambda x, y: x + y
print(add(3, 5))  # 输出：8
</pre><h5><a name='header-n1678' class='md-header-anchor '></a><strong>解释：</strong></h5><ul><li><code>lambda</code>函数通过关键字<code>lambda</code>定义，<code>x</code>和<code>y</code>是输入参数，<code>x + y</code>是返回值。</li><li>该<code>lambda</code>函数等价于一个传统的函数<code>def add(x, y): return x + y</code>。</li></ul><h5><a name='header-n1686' class='md-header-anchor '></a><strong>lambda函数与内置函数结合使用</strong></h5><p><code>lambda</code>函数常常与内置函数（如<code>map()</code>, <code>filter()</code>, <code>sorted()</code>等）结合使用。</p><h5><a name='header-n1689' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang=""># 使用lambda函数对列表进行排序
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
sorted_numbers = sorted(numbers, key=lambda x: x)
print(sorted_numbers)  # 输出：[1, 1, 2, 3, 4, 5, 6, 9]
</pre><h5><a name='header-n1691' class='md-header-anchor '></a><strong>解释：</strong></h5><ul><li>使用<code>sorted()</code>函数对列表进行排序，并通过<code>lambda x: x</code>指定排序的关键字（即按值排序）。</li></ul><h5><a name='header-n1696' class='md-header-anchor '></a><strong>lambda函数作为参数传递</strong></h5><p><code>lambda</code>函数也可以作为参数传递给其他函数：</p><h5><a name='header-n1699' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang=""># 使用lambda函数与map结合，计算每个元素的平方
numbers = [1, 2, 3, 4, 5]
squares = map(lambda x: x ** 2, numbers)
print(list(squares))  # 输出：[1, 4, 9, 16, 25]
</pre><p><strong>解释：</strong></p><ul><li><code>map()</code>函数接受一个函数和一个可迭代对象，将函数应用到可迭代对象的每个元素。</li><li>在这里，<code>lambda</code>函数计算每个数字的平方。</li></ul><hr /><h5><a name='header-n1711' class='md-header-anchor '></a>总结</h5><p>本章介绍了Python中函数的基本使用，包括函数的定义、调用过程、以及<code>lambda</code>函数的应用。函数不仅是代码复用的工具，也是组织和模块化代码的基础。</p><ol start='' ><li><strong>函数定义</strong>：使用<code>def</code>关键字定义函数，支持默认参数、关键字参数等。</li><li><strong>函数调用</strong>：通过函数名调用函数，传递实际参数，执行函数体并返回结果。</li><li><strong>lambda函数</strong>：匿名函数，常用于定义简单的函数或与内置函数结合使用。</li></ol><p>掌握函数的基本使用，可以提高代码的组织性、可读性和复用性，帮助开发高效、清晰的程序。</p><h4><a name='header-n1726' class='md-header-anchor '></a>5.2 函数的高级用法</h4><p>在 Python 中，函数不仅限于接受固定数量的参数。你可以使用可选参数、可变数量的参数、关键字参数等来使函数更加灵活。了解这些高级用法能够让你更好地设计和使用函数，提高代码的灵活性和可读性。</p><hr /><h3><a name='header-n1730' class='md-header-anchor '></a>5.2.1 可选参数和可变数量参数</h3><h5><a name='header-n1731' class='md-header-anchor '></a><strong>可选参数</strong></h5><p>可选参数是指在函数定义时为某些参数提供默认值，调用函数时可以选择传递这些参数的值，也可以使用默认值。</p><h5><a name='header-n1734' class='md-header-anchor '></a><strong>语法：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def function_name(param1, param2=default_value):
    # 函数体
</pre><p>在此例中，<code>param2</code>是一个可选参数，如果调用时没有传递<code>param2</code>的值，函数会使用<code>default_value</code>作为默认值。</p><h5><a name='header-n1738' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def greet(name, message="Hello"):
    return f"{message}, {name}!"

# 调用时不传递message
print(greet("Alice"))  # 输出：Hello, Alice!

# 调用时传递message
print(greet("Bob", "Good morning"))  # 输出：Good morning, Bob!
</pre><p><strong>解释：</strong></p><ul><li><code>message</code>参数有一个默认值<code>&quot;Hello&quot;</code>，因此如果没有传递<code>message</code>，会使用默认值。</li><li>如果传递了<code>message</code>，则会使用传递的值。</li></ul><h5><a name='header-n1749' class='md-header-anchor '></a><strong>可变数量的参数</strong></h5><p>如果你希望一个函数能够接受任意数量的参数，可以使用可变参数（<code>*args</code> 和 <code>**kwargs</code>）。这两种方式可以分别接收位置参数和关键字参数的可变数量。</p><h5><a name='header-n1752' class='md-header-anchor '></a><strong>位置参数的可变数量 (*args)</strong></h5><p><code>*args</code>允许函数接受任意数量的位置参数。传递给<code>args</code>的所有参数会被包装成一个元组。</p><h5><a name='header-n1755' class='md-header-anchor '></a><strong>语法：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def function_name(*args):
    # args是一个元组，包含所有传递的位置参数
</pre><h5><a name='header-n1757' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def sum_numbers(*args):
    return sum(args)

# 传入多个位置参数
print(sum_numbers(1, 2, 3))  # 输出：6
print(sum_numbers(10, 20, 30, 40))  # 输出：100
</pre><p><strong>解释：</strong></p><ul><li><code>*args</code>将所有传递的位置参数打包成一个元组。在函数体内，你可以像使用元组一样访问这些参数。</li><li>在<code>sum_numbers</code>函数中，<code>args</code>是一个元组，<code>sum(args)</code>计算该元组的和。</li></ul><h5><a name='header-n1768' class='md-header-anchor '></a><strong>关键字参数的可变数量 (**kwargs)</strong></h5><p><code>**kwargs</code>允许函数接受任意数量的关键字参数。传递给<code>kwargs</code>的所有参数会被包装成一个字典。</p><h5><a name='header-n1771' class='md-header-anchor '></a><strong>语法：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def function_name(**kwargs):
    # kwargs是一个字典，包含所有传递的关键字参数
</pre><h5><a name='header-n1773' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def describe_person(**kwargs):
    return f"{kwargs['name']} is {kwargs['age']} years old and lives in {kwargs['city']}."

# 传入多个关键字参数
print(describe_person(name="Alice", age=30, city="New York"))  # 输出：Alice is 30 years old and lives in New York.
</pre><p><strong>解释：</strong></p><ul><li><code>**kwargs</code>将所有传递的关键字参数打包成一个字典。在函数体内，你可以像访问字典一样访问这些参数。</li><li>在<code>describe_person</code>函数中，<code>kwargs</code>是一个字典，你可以通过<code>kwargs[&#39;name&#39;]</code>来获取传递的参数值。</li></ul><h5><a name='header-n1784' class='md-header-anchor '></a><strong>结合使用 *args 和 </strong>kwargs**</h5><p>一个函数可以同时使用位置参数 (<code>*args</code>) 和关键字参数 (<code>**kwargs</code>)。它们的顺序是固定的：<code>*args</code>必须放在<code>**kwargs</code>之前。</p><h5><a name='header-n1787' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def person_info(name, *args, **kwargs):
    print(f"Name: {name}")
    print(f"Other info: {args}")
    print(f"Details: {kwargs}")

# 传递位置参数、可变位置参数和可变关键字参数
person_info("Alice", 30, "New York", gender="Female", occupation="Engineer")
</pre><p><strong>输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">Name: Alice
Other info: (30, 'New York')
Details: {'gender': 'Female', 'occupation': 'Engineer'}
</pre><p><strong>解释：</strong></p><ul><li><code>name</code>是普通的命名参数。</li><li><code>*args</code>捕获传递的可变数量的位置参数，打包成一个元组。</li><li><code>**kwargs</code>捕获传递的可变数量的关键字参数，打包成一个字典。</li></ul><hr /><h4><a name='header-n1805' class='md-header-anchor '></a>5.2.2 参数的位置和名称传递</h4><p>在 Python 中，函数的参数可以通过位置传递（positional arguments）或关键字传递（keyword arguments）。</p><h5><a name='header-n1808' class='md-header-anchor '></a><strong>位置参数</strong></h5><p>位置参数是通过按照函数定义中参数的顺序传递的参数。它们必须与函数定义中的参数顺序一致。</p><h5><a name='header-n1811' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def greet(name, message):
    return f"{message}, {name}!"

print(greet("Alice", "Good morning"))  # 输出：Good morning, Alice!
</pre><p><strong>解释：</strong></p><ul><li><code>&quot;Alice&quot;</code>被传递给<code>name</code>，<code>&quot;Good morning&quot;</code>被传递给<code>message</code>，这就是位置参数传递。</li></ul><h5><a name='header-n1819' class='md-header-anchor '></a><strong>关键字参数</strong></h5><p>关键字参数是通过<code>key=value</code>的方式传递给函数的，这样可以不依赖参数的顺序。</p><h5><a name='header-n1822' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def greet(name, message):
    return f"{message}, {name}!"

print(greet(message="Good morning", name="Alice"))  # 输出：Good morning, Alice!
</pre><p><strong>解释：</strong></p><ul><li>使用关键字参数时，<code>message=&quot;Good morning&quot;</code>和<code>name=&quot;Alice&quot;</code>可以不按照位置顺序传递。</li></ul><h4><a name='header-n1830' class='md-header-anchor '></a><strong>位置参数和关键字参数混合使用</strong></h4><p>你可以在函数调用时同时使用位置参数和关键字参数，但位置参数必须出现在关键字参数之前。</p><h5><a name='header-n1833' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def greet(name, message):
    return f"{message}, {name}!"

print(greet("Alice", message="Good morning"))  # 输出：Good morning, Alice!
</pre><p><strong>解释：</strong></p><ul><li><code>&quot;Alice&quot;</code>是位置参数，而<code>message=&quot;Good morning&quot;</code>是关键字参数。关键字参数可以不按顺序传递。</li></ul><hr /><h4><a name='header-n1842' class='md-header-anchor '></a>5.2.3 函数的返回值</h4><p>Python 中的函数通常通过 <code>return</code> 语句返回一个结果。当函数没有显式的 <code>return</code> 语句时，它会默认返回 <code>None</code>。</p><h5><a name='header-n1845' class='md-header-anchor '></a><strong>返回一个值</strong></h5><p>通过 <code>return</code> 语句，函数可以将计算的结果返回给调用者。</p><h5><a name='header-n1848' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def add(a, b):
    return a + b

result = add(3, 5)
print(result)  # 输出：8
</pre><p><strong>解释：</strong></p><ul><li>函数 <code>add</code> 返回 <code>a + b</code> 的计算结果，并将其赋值给 <code>result</code>。</li></ul><h6><a name='header-n1856' class='md-header-anchor '></a><strong>返回多个值</strong></h6><h5><a name='header-n1857' class='md-header-anchor '></a>Python 函数可以返回多个值，多个返回值会自动打包成一个元组。</h5><h5><a name='header-n1858' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def calculate(a, b):
    return a + b, a - b, a * b, a / b

result = calculate(10, 2)
print(result)  # 输出：(12, 8, 20, 5.0)
</pre><p><strong>解释：</strong></p><ul><li>函数返回了四个计算结果，它们被打包成一个元组。</li></ul><h6><a name='header-n1866' class='md-header-anchor '></a><strong>没有返回值</strong></h6><p>如果函数没有显式的 <code>return</code> 语句，则返回 <code>None</code>。</p><h5><a name='header-n1869' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def greet(name):
    print(f"Hello, {name}!")

result = greet("Alice")
print(result)  # 输出：None
</pre><p><strong>解释：</strong></p><ul><li>函数 <code>greet</code> 只有一个 <code>print</code> 语句，没有 <code>return</code>，因此它返回 <code>None</code>。</li></ul><hr /><h5><a name='header-n1878' class='md-header-anchor '></a>5.2.4 函数对变量的作用</h5><p>函数内的变量作用域受到作用域规则的影响。函数内的变量通常具有局部作用域，在函数外不可访问。了解作用域和生命周期对于函数设计至关重要。</p><h4><a name='header-n1881' class='md-header-anchor '></a><strong>局部变量和全局变量</strong></h4><ul><li><strong>局部变量</strong>：函数内部定义的变量，只能在函数内部访问。</li><li><strong>全局变量</strong>：在函数外部定义的变量，可以在整个程序中访问，但在函数内修改时需要使用 <code>global</code> 关键字。</li></ul><h5><a name='header-n1889' class='md-header-anchor '></a><strong>示例：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">x = 10  # 全局变量

def function():
    x = 20  # 局部变量
    print(f"Inside function, x = {x}")

function()
print(f"Outside function, x = {x}")
</pre><p><strong>输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">Inside function, x = 20
Outside function, x = 10
</pre><p><strong>解释：</strong></p><ul><li>在函数 <code>function</code> 中，<code>x</code> 被定义为局部变量，<strong>函数</strong></li></ul><h4><a name='header-n1900' class='md-header-anchor '></a>5.3 模块3：datetime库的使用</h4><p><code>datetime</code> 模块是 Python 标准库中用于处理日期和时间的模块。它提供了多种类和方法，可以帮助我们处理时间和日期的表示、格式化、计算以及时区等问题。</p><h4><a name='header-n1903' class='md-header-anchor '></a>5.3.1 datetime库概述</h4><p><code>datetime</code> 库提供了几个关键的类来处理日期和时间：</p><ul><li><strong>date</strong>：表示日期（年、月、日）。</li><li><strong>time</strong>：表示时间（时、分、秒、毫秒）。</li><li><strong>datetime</strong>：表示日期和时间的组合。</li><li><strong>timedelta</strong>：表示两个日期或时间之间的差值。</li><li><strong>timezone</strong>：表示时区信息。</li></ul><p>该模块还包含许多用于格式化、解析、比较和操作时间的函数。</p><h4><a name='header-n1924' class='md-header-anchor '></a>5.3.2 datetime库解析</h4><p>以下是 <code>datetime</code> 库中一些常用的功能和类的详细解析：</p><h5><a name='header-n1927' class='md-header-anchor '></a><strong>1. datetime.date 类</strong></h5><p><code>date</code> 类用于表示单独的日期。它包含年、月和日。</p><ul><li><strong>构造方法：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">from datetime import date

d = date(2024, 12, 23)  # 创建一个表示2024年12月23日的date对象
print(d)  # 输出：2024-12-23
</pre><ul><li><strong>获取当前日期：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">today = date.today()  # 获取当前日期
print(today)  # 输出：当前日期（例如：2024-12-23）
</pre><ul><li><strong>获取日期的各个部分：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">d = date(2024, 12, 23)
print(d.year)  # 输出：2024
print(d.month)  # 输出：12
print(d.day)  # 输出：23
</pre><h5><a name='header-n1945' class='md-header-anchor '></a><strong>2. datetime.time 类</strong></h5><p><code>time</code> 类用于表示时间（不包括日期）。它可以包含时、分、秒、微秒。</p><ul><li><strong>构造方法：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">from datetime import time

t = time(14, 30, 45)  # 创建一个表示14:30:45的time对象
print(t)  # 输出：14:30:45
</pre><ul><li><strong>获取时间的各个部分：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">t = time(14, 30, 45)
print(t.hour)  # 输出：14
print(t.minute)  # 输出：30
print(t.second)  # 输出：45
</pre><h5><a name='header-n1958' class='md-header-anchor '></a><strong>3. datetime.datetime 类</strong></h5><p><code>datetime</code> 类用于表示日期和时间的组合。它包含了日期部分（年、月、日）和时间部分（时、分、秒、微秒）。</p><ul><li><strong>构造方法：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">from datetime import datetime

dt = datetime(2024, 12, 23, 14, 30, 45)  # 创建一个表示2024年12月23日14:30:45的datetime对象
print(dt)  # 输出：2024-12-23 14:30:45
</pre><ul><li><strong>获取当前日期和时间：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">now = datetime.now()  # 获取当前的日期和时间
print(now)  # 输出：当前日期和时间（例如：2024-12-23 14:30:45.123456）
</pre><ul><li><strong>获取日期和时间的各个部分：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">dt = datetime(2024, 12, 23, 14, 30, 45)
print(dt.year)  # 输出：2024
print(dt.month)  # 输出：12
print(dt.day)  # 输出：23
print(dt.hour)  # 输出：14
print(dt.minute)  # 输出：30
print(dt.second)  # 输出：45
</pre><h5><a name='header-n1976' class='md-header-anchor '></a><strong>4. datetime.timedelta 类</strong></h5><p><code>timedelta</code> 类表示两个日期或时间之间的差值。它可以用于日期和时间的加减运算。</p><ul><li><strong>构造方法：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">from datetime import timedelta

td = timedelta(days=5, hours=2, minutes=30)  # 创建一个表示5天2小时30分钟的timedelta对象
print(td)  # 输出：5 days, 2:30:00
</pre><ul><li><strong>日期相加：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">from datetime import datetime, timedelta

dt = datetime(2024, 12, 23, 14, 30, 45)
new_dt = dt + timedelta(days=5)  # 当前时间加5天
print(new_dt)  # 输出：2024-12-28 14:30:45
</pre><ul><li><strong>日期相减：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">dt1 = datetime(2024, 12, 23, 14, 30, 45)
dt2 = datetime(2024, 12, 20, 14, 30, 45)
delta = dt1 - dt2  # 计算两个日期之间的差值
print(delta)  # 输出：3 days, 0:00:00
</pre><h5><a name='header-n1994' class='md-header-anchor '></a><strong>5. 日期和时间的格式化</strong></h5><p><code>datetime</code> 类的 <code>strftime()</code> 方法可以将日期和时间对象转换为指定格式的字符串。</p><ul><li><strong>格式化当前日期和时间：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">from datetime import datetime

now = datetime.now()
formatted = now.strftime("%Y-%m-%d %H:%M:%S")  # 格式化日期和时间
print(formatted)  # 输出：2024-12-23 14:30:45
</pre><p>常见的格式化代码：</p><ul><li><code>%Y</code> - 四位数年份</li><li><code>%m</code> - 两位数月份</li><li><code>%d</code> - 两位数日期</li><li><code>%H</code> - 两位数小时（24小时制）</li><li><code>%M</code> - 两位数分钟</li><li><code>%S</code> - 两位数秒</li><li><code>%A</code> - 星期几的全名（如：Monday）</li><li><code>%B</code> - 月份的全名（如：January）</li></ul><h5><a name='header-n2029' class='md-header-anchor '></a><strong>6. 字符串转日期和时间</strong></h5><p><code>datetime</code> 类的 <code>strptime()</code> 方法可以将字符串转换为日期和时间对象。</p><ul><li><strong>示例：</strong></li></ul><pre class="md-fences mock-cm md-end-block" lang="">from datetime import datetime

date_str = "2024-12-23 14:30:45"
dt = datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")  # 将字符串转为datetime对象
print(dt)  # 输出：2024-12-23 14:30:45
</pre><hr /><h3><a name='header-n2038' class='md-header-anchor '></a>5.4 实例7：七段数码管绘制</h3><p>七段数码管广泛应用于显示数字，在许多电子设备中都能看到它的身影。在 Python 中，我们可以利用图形绘图库（如 <code>turtle</code>）来绘制七段数码管。</p><h4><a name='header-n2041' class='md-header-anchor '></a><strong>七段数码管的结构</strong></h4><p>七段数码管由7个独立的发光二极管组成，这些二极管排列成数字“8”的形状，能够显示0-9的所有数字。每个数字的显示由不同的段组合成。</p><pre class="md-fences mock-cm md-end-block" lang=""> -- a --
|     |
f     b
|     |
 -- g --
|     |
e     c
|     |
 -- d --
</pre><ul><li><strong>段标识：</strong> a, b, c, d, e, f, g</li></ul><h4><a name='header-n2049' class='md-header-anchor '></a><strong>实现步骤：</strong></h4><ol start='' ><li>使用 <code>turtle</code> 绘制一个7段数码管的框架。</li><li>根据输入的数字（0-9），点亮相应的段。</li><li>可以通过输入不同的数字来查看不同的数字显示。</li></ol><h5><a name='header-n2060' class='md-header-anchor '></a><strong>示例代码：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">import turtle

# 7段数码管的绘制
def draw_digit(digit):
    segments = {
        '0': ['a', 'b', 'c', 'd', 'e', 'f'],
        '1': ['b', 'c'],
        '2': ['a', 'b', 'd', 'e', 'g'],
        '3': ['a', 'b', 'c', 'd', 'g'],
        '4': ['b', 'c', 'f', 'g'],
        '5': ['a', 'c', 'd', 'f', 'g'],
        '6': ['a', 'c', 'd', 'e', 'f', 'g'],
        '7': ['a', 'b', 'c'],
        '8': ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
        '9': ['a', 'b', 'c', 'd', 'f', 'g']
    }
    # 初始化turtle
    turtle.speed(0)
    turtle.penup()
    turtle.goto(-50, 100)
    turtle.pendown()
    
    # 根据数字绘制对应的七段数码管
    for segment in segments[digit]:
        draw_segment(segment)
    
def draw_segment(segment):
    if segment == 'a':
        # 绘制上面的横线
        pass
    # 根据其他段，添加相应的绘制代码...
    
turtle.done()
</pre><p>这个代码框架展示了如何用 <code>turtle</code> 绘制七段数码管，并根据输入的数字点亮相应的段。每个段（<code>a</code>, <code>b</code>, <code>c</code>, ...</p><h3><a name='header-n2064' class='md-header-anchor '></a>5.5 代码复用和模块化设计</h3><p>在软件开发中，代码复用和模块化设计是提高代码质量、可维护性和可扩展性的关键实践。Python 提供了多种方法来实现代码复用和模块化设计，使得程序结构更加清晰、易于维护和扩展。</p><h4><a name='header-n2067' class='md-header-anchor '></a><strong>代码复用</strong></h4><p>代码复用是指将某些功能封装在函数、类或模块中，以便在多个地方调用，而不需要重复编写相同的代码。代码复用可以减少冗余、降低错误率并提高开发效率。</p><h5><a name='header-n2070' class='md-header-anchor '></a><strong>1. 使用函数进行代码复用</strong></h5><p>将常用的代码片段封装成函数，通过调用函数来实现代码复用。这样可以避免多次编写相同的代码，提高代码的可维护性。</p><pre class="md-fences mock-cm md-end-block" lang="">def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

# 在其他地方调用这些函数
result1 = add(10, 20)
result2 = subtract(20, 10)
print(result1, result2)  # 输出：30 10
</pre><h5><a name='header-n2074' class='md-header-anchor '></a><strong>2. 使用类和对象进行代码复用</strong></h5><p>通过类和对象，您可以封装属性和方法，创建可复用的代码模块。类是一种数据和方法的组合，可以在多个实例中重复使用。</p><pre class="md-fences mock-cm md-end-block" lang="">class Calculator:
    def add(self, a, b):
        return a + b

    def subtract(self, a, b):
        return a - b

# 创建Calculator对象并复用
calc = Calculator()
print(calc.add(10, 20))  # 输出：30
print(calc.subtract(20, 10))  # 输出：10
</pre><h4><a name='header-n2078' class='md-header-anchor '></a><strong>模块化设计</strong></h4><p>模块化设计是将程序分解成相互独立、功能单一的模块，每个模块可以在不同的程序中复用。Python 提供了模块和包的概念，可以帮助开发者进行模块化设计。</p><h5><a name='header-n2081' class='md-header-anchor '></a><strong>1. 创建模块</strong></h5><p>Python 模块是包含 Python 代码的文件，它通常用于封装一些常用的功能。模块是 Python 代码的逻辑单元，可以通过 <code>import</code> 语句在其他文件中调用。</p><pre class="md-fences mock-cm md-end-block" lang=""># 创建一个模块 mymath.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

# 在其他文件中使用
import mymath
result1 = mymath.add(10, 20)
result2 = mymath.subtract(20, 10)
print(result1, result2)  # 输出：30 10
</pre><h5><a name='header-n2085' class='md-header-anchor '></a><strong>2. 使用包进行组织</strong></h5><p>包是模块的集合，它用于组织和管理多个模块。当你的项目中有多个模块时，可以通过包将它们组织在一起。</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;"># 假设有一个包 mypackage，其中包含模块 add.py 和 subtract.py
# mypackage/add.py
def add(a, b):
    return a + b

# mypackage/subtract.py
def subtract(a, b):
    return a - b

# 在主程序中使用包
from mypackage import add, subtract
result1 = add.add(10, 20)
result2 = subtract.subtract(20, 10)
print(result1, result2)  # 输出：30 10
</pre><p>通过模块和包的方式，可以实现更加灵活和高效的代码组织，从而提高代码的可重用性。</p><hr /><h3><a name='header-n2092' class='md-header-anchor '></a>5.6 函数的递归</h3><p>递归是一种编程技术，它允许函数在自己的定义中调用自己。递归通常用于解决那些可以被分解成相似子问题的问题。理解递归的基本概念对于解决很多算法问题非常重要。</p><h4><a name='header-n2095' class='md-header-anchor '></a>5.6.1 递归的定义</h4><p>递归是指一个函数直接或间接地调用自己，从而在程序中重复执行某一操作。递归函数通常包括两个主要部分：</p><ol start='' ><li><strong>基准情况（终止条件）</strong>：当问题足够简单，递归不再继续调用自身，而是返回一个结果。</li><li><strong>递归调用</strong>：函数通过调用自身来解决问题的一部分，逐步接近基准情况。</li></ol><p>递归通常通过将问题分解为更小的子问题，逐步求解并合并结果。</p><h4><a name='header-n2107' class='md-header-anchor '></a><strong>递归的工作原理</strong></h4><p>递归的工作流程可以总结为：</p><ol start='' ><li><strong>递归调用</strong>：函数调用自己，传递参数进行进一步的计算。</li><li><strong>基准情况</strong>：一旦递归达到某个终止条件，函数停止递归并返回结果。</li><li><strong>逐步返回</strong>：每次递归调用返回的结果会传递回上一层，直到最初的调用点。</li></ol><h4><a name='header-n2120' class='md-header-anchor '></a><strong>经典的递归问题：阶乘</strong></h4><p>阶乘是一个经典的递归问题，它的定义是：</p><ul><li>n! = n × (n-1) × (n-2) × ... × 1</li><li>0! = 1（基准情况）</li></ul><h5><a name='header-n2130' class='md-header-anchor '></a><strong>递归实现阶乘：</strong></h5><pre class="md-fences mock-cm md-end-block" lang="">def factorial(n):
    if n == 0:  # 基准情况：0! = 1
        return 1
    else:
        return n * factorial(n - 1)  # 递归调用

print(factorial(5))  # 输出：120
</pre><p><strong>解释：</strong></p><ul><li>基准情况：当 <code>n == 0</code> 时，返回 <code>1</code>。</li><li>递归调用：当 <code>n &gt; 0</code> 时，计算 <code>n * factorial(n-1)</code>，即将问题分解为更小的子问题。</li></ul><p>递归的计算过程如下：</p><ul><li><code>factorial(5)</code> 调用 <code>factorial(4)</code>，</li><li><code>factorial(4)</code> 调用 <code>factorial(3)</code>，</li><li><code>factorial(3)</code> 调用 <code>factorial(2)</code>，</li><li><code>factorial(2)</code> 调用 <code>factorial(1)</code>，</li><li><code>factorial(1)</code> 调用 <code>factorial(0)</code>（此时达到基准情况，返回 1），</li><li>然后递归调用逐步返回，最终计算出 <code>120</code>。</li></ul><h4><a name='header-n2162' class='md-header-anchor '></a><strong>递归的应用场景</strong></h4><p>递归广泛应用于各种算法和数据结构问题，特别是：</p><ul><li><strong>分治算法</strong>：例如归并排序和快速排序。</li><li><strong>树的遍历</strong>：例如二叉树的前序、中序和后序遍历。</li><li><strong>图的搜索</strong>：例如深度优先搜索（DFS）。</li><li><strong>动态规划</strong>：例如斐波那契数列。</li></ul><h4><a name='header-n2178' class='md-header-anchor '></a><strong>递归的优缺点</strong></h4><ul><li><p><strong>优点</strong>：</p><ul><li>递归可以将复杂问题分解成更简单的子问题，代码简洁易懂。</li><li>适合处理树结构和图结构的问题。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>递归可能导致栈溢出，特别是递归深度过大时。</li><li>每次递归调用都需要额外的内存空间。</li></ul></li></ul><h4><a name='header-n2200' class='md-header-anchor '></a><strong>递归的优化：尾递归</strong></h4><p>尾递归是指递归调用出现在函数的最后一行。在尾递归中，递归调用的返回值直接作为函数的返回值返回，这使得一些编译器或解释器能够优化递归调用，减少栈空间的使用。</p><p>Python 不支持尾递归优化，但其他语言如 Scheme、C++ 等支持尾递归优化，可以通过尾递归来避免栈溢出问题。</p><hr /><p>通过递归，我们可以更简洁地解决某些问题，但需要注意合理设置递归终止条件，避免无限递归的发生。</p><h4><a name='header-n2208' class='md-header-anchor '></a>5.6.2 递归的使用方法</h4><p>递归是一种非常强大的编程技术，它通过函数的自我调用来解决问题。递归常用于解决那些可以分解成多个子问题的问题，如树结构遍历、分治算法、回溯算法等。使用递归时，需要理解以下几个核心概念和步骤：</p><h5><a name='header-n2211' class='md-header-anchor '></a><strong>递归的基本构成</strong></h5><ol start='' ><li><p>基准情况（终止条件）</p><p>：</p><ul><li>每个递归函数必须包含一个基准情况，也就是当问题已经足够简单时，递归停止并返回结果。</li><li>基准情况是防止递归无限进行下去的关键。</li></ul></li><li><p>递归调用</p><p>：</p><ul><li>递归调用是将问题分解为更小的子问题，继续调用自身来处理更小的部分。</li><li>递归调用必须朝着基准情况发展，通常是通过减少参数的大小或改变其值。</li></ul></li></ol><h5><a name='header-n2237' class='md-header-anchor '></a><strong>递归的步骤</strong></h5><ol start='' ><li><strong>确定递归问题的边界条件</strong>：找到基准情况，即最简单的情况，可以直接求解。</li><li><strong>分解问题</strong>：将复杂的问题分解为一个或多个更小的子问题。</li><li><strong>递归调用</strong>：在函数内部调用自己，直到满足基准情况为止。</li><li><strong>合并结果</strong>：每个递归调用返回后，合并其结果或继续递归的计算。</li></ol><h5><a name='header-n2251' class='md-header-anchor '></a><strong>递归的常见示例</strong></h5><h5><a name='header-n2252' class='md-header-anchor '></a><strong>1. 斐波那契数列</strong></h5><p>斐波那契数列是一个经典的递归问题。该数列的定义为：</p><ul><li>F(0) = 0</li><li>F(1) = 1</li><li>F(n) = F(n-1) + F(n-2) （n ≥ 2）</li></ul><p>递归实现：</p><pre class="md-fences mock-cm md-end-block" lang="">def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(5))  # 输出：5
</pre><p><strong>解释：</strong></p><ul><li>基准情况：<code>fibonacci(0)</code> 返回 <code>0</code>，<code>fibonacci(1)</code> 返回 <code>1</code>。</li><li>递归调用：<code>fibonacci(n)</code> 调用 <code>fibonacci(n-1)</code> 和 <code>fibonacci(n-2)</code> 继续计算，直到达到基准情况。</li></ul><h5><a name='header-n2277' class='md-header-anchor '></a><strong>2. 计算阶乘</strong></h5><p>阶乘问题是另一个经典的递归问题，定义为：</p><ul><li>n! = n × (n-1) × (n-2) × ... × 1</li><li>0! = 1（基准情况）</li></ul><p>递归实现：</p><pre class="md-fences mock-cm md-end-block" lang="">def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

print(factorial(5))  # 输出：120
</pre><p><strong>解释：</strong></p><ul><li>基准情况：当 <code>n == 0</code> 时，返回 <code>1</code>。</li><li>递归调用：当 <code>n &gt; 0</code> 时，返回 <code>n * factorial(n - 1)</code>。</li></ul><h5><a name='header-n2299' class='md-header-anchor '></a><strong>3. 迷宫求解</strong></h5><p>递归还广泛应用于问题如迷宫的求解、回溯问题等。假设我们要在一个迷宫中找到从起点到终点的路径，可以使用递归进行逐步的探索。</p><h4><a name='header-n2302' class='md-header-anchor '></a><strong>递归的优缺点</strong></h4><ul><li><p>优点</p><p>：</p><ul><li>递归可以使问题变得更加简单和清晰，特别是当问题具有重复的子结构时（如树、图等）。</li><li>递归代码通常比迭代代码更加简洁。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>每次递归调用都会占用一定的内存，因此递归深度过深可能导致栈溢出。</li><li>递归函数有时可能比迭代效率低。</li></ul></li></ul><h5><a name='header-n2328' class='md-header-anchor '></a><strong>递归的优化：尾递归</strong></h5><p>尾递归是一种特殊的递归方式，它是指递归调用出现在函数的最后一步，且返回值直接为递归函数的调用结果。尾递归可以减少栈空间的使用，某些编程语言可以通过尾递归优化来提高性能。</p><p>然而，Python 并不支持尾递归优化，因此在 Python 中，如果递归深度过深，可能会导致 <code>RecursionError</code>。</p><hr /><h3><a name='header-n2334' class='md-header-anchor '></a>5.7 实例8：科赫曲线绘制</h3><p>科赫曲线（Koch Curve）是一个经典的分形图形，它由瑞典数学家 Helge von Koch 提出。科赫曲线是通过反复递归地细分一个线段而生成的。</p><h5><a name='header-n2337' class='md-header-anchor '></a><strong>科赫曲线的生成规则</strong></h5><ol start='' ><li>将每条线段分成3个相等的小段。</li><li>在中间段的上方（或者下方）形成一个等边三角形，然后去掉中间段。</li><li>重复这个过程，每次递归细分曲线。</li></ol><h5><a name='header-n2348' class='md-header-anchor '></a><strong>科赫曲线的绘制代码</strong></h5><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">import turtle

def koch_curve(t, order, size):
    if order == 0:
        t.forward(size)
    else:
        for angle in [60, -120, 60, 0]:
            koch_curve(t, order - 1, size / 3)
            t.left(angle)

def koch_snowflake(t, order, size):
    for _ in range(3):
        koch_curve(t, order, size)
        t.right(120)

# 设置屏幕和画笔
screen = turtle.Screen()
screen.bgcolor("white")
t = turtle.Turtle()
t.speed(0)

# 调用函数绘制科赫雪花
koch_snowflake(t, 4, 300)

# 隐藏画笔并结束
t.hideturtle()
screen.mainloop()
</pre><h5><a name='header-n2350' class='md-header-anchor '></a><strong>代码解释</strong>：</h5><ul><li><code>koch_curve(t, order, size)</code>：递归函数，绘制科赫曲线的单个边。<code>order</code> 参数控制递归的深度，<code>size</code> 参数控制线段的长度。</li><li><code>koch_snowflake(t, order, size)</code>：绘制完整的科赫雪花。科赫雪花由三个科赫曲线组成，彼此相隔 120 度。</li></ul><p>通过递归，每个线段被细分，最终形成一个非常复杂的分形图形。</p><h5><a name='header-n2360' class='md-header-anchor '></a><strong>运行结果</strong>：</h5><p>运行代码时，屏幕上将会显示出一个具有分形结构的科赫雪花。</p><hr /><h3><a name='header-n2364' class='md-header-anchor '></a>5.8 Python内置函数</h3><p>Python 提供了许多内置函数，方便开发者执行常见的操作。内置函数使得代码更加简洁高效。以下是一些常用的内置函数：</p><h5><a name='header-n2367' class='md-header-anchor '></a><strong>1. len()</strong></h5><p>返回对象（如列表、字符串、元组等）中的元素数量。</p><pre class="md-fences mock-cm md-end-block" lang="">s = "Hello, World!"
print(len(s))  # 输出：13
</pre><h5><a name='header-n2371' class='md-header-anchor '></a><strong>2. max() 和 min()</strong></h5><p>返回可迭代对象中的最大值和最小值。</p><pre class="md-fences mock-cm md-end-block" lang="">numbers = [1, 2, 3, 4, 5]
print(max(numbers))  # 输出：5
print(min(numbers))  # 输出：1
</pre><h4><a name='header-n2375' class='md-header-anchor '></a><strong>3. sum()</strong></h4><p>返回可迭代对象中所有元素的总和。</p><pre class="md-fences mock-cm md-end-block" lang="">numbers = [1, 2, 3, 4, 5]
print(sum(numbers))  # 输出：15
</pre><h5><a name='header-n2379' class='md-header-anchor '></a><strong>4. sorted()</strong></h5><p>返回一个排序后的列表，而不会改变原始列表。</p><pre class="md-fences mock-cm md-end-block" lang="">numbers = [5, 2, 3, 1, 4]
print(sorted(numbers))  # 输出：[1, 2, 3, 4, 5]
</pre><h5><a name='header-n2383' class='md-header-anchor '></a><strong>5. range()</strong></h5><p>返回一个可迭代的整数序列，通常用于循环中。</p><pre class="md-fences mock-cm md-end-block" lang="">for i in range(5):
    print(i)
# 输出：
# 0
# 1
# 2
# 3
# 4
</pre><h4><a name='header-n2387' class='md-header-anchor '></a><strong>6. map()</strong></h4><p>接受一个函数和一个可迭代对象，将该函数应用到可迭代对象的每个元素上，返回一个新的可迭代对象。</p><pre class="md-fences mock-cm md-end-block" lang="">numbers = [1, 2, 3, 4]
squared = map(lambda x: x ** 2, numbers)
print(list(squared))  # 输出：[1, 4, 9, 16]
</pre><h5><a name='header-n2391' class='md-header-anchor '></a><strong>7. filter()</strong></h5><p>返回一个由函数过滤的可迭代对象，函数为 <code>True</code> 的元素会被保留。</p><pre class="md-fences mock-cm md-end-block" lang="">numbers = [1, 2, 3, 4, 5, 6]
even_numbers = filter(lambda x: x % 2 == 0, numbers)
print(list(even_numbers))  # 输出：[2, 4, 6]
</pre><h4><a name='header-n2395' class='md-header-anchor '></a><strong>8. zip()</strong></h4><p>将多个可迭代对象“打包”成元组，返回一个元组的迭代器。</p><pre class="md-fences mock-cm md-end-block" lang="">names = ["Alice", "Bob", "Charlie"]
scores = [85, 90, 88]
paired = zip(names, scores)
print(list
</pre><p>(paired))  # 输出：[(&#39;Alice&#39;, 85), (&#39;Bob&#39;, 90), (&#39;Charlie&#39;, 88)]</p><pre class="md-fences mock-cm md-end-block" lang="">#### **9. `abs()`**

返回数字的绝对值。

​```python
print(abs(-5))  # 输出：5
</pre><p>这些内置函数极大简化了常见操作的实现，提升了编程效率。</p><h2><a name='header-n2404' class='md-header-anchor '></a>第6章 组合数据类型</h2><p>组合数据类型是 Python 中用来存储多个元素的复合数据类型。它们的作用是提供一种方式来将多个数据项组织在一起，从而更方便地进行管理和操作。在 Python 中，常见的组合数据类型包括 <strong>序列类型</strong>、<strong>集合类型</strong>和<strong>映射类型</strong>，它们各自有不同的特性和应用场景。</p><h4><a name='header-n2407' class='md-header-anchor '></a>6.1.1 序列类型通用操作符与函数</h4><h5><a name='header-n2408' class='md-header-anchor '></a>序列类型的常用操作符和函数</h5><figure><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><code>x in s</code></td><td>如果 <code>x</code> 是 <code>s</code> 的元素，返回 <code>True</code>，否则返回 <code>False</code>。用于检查元素是否存在于序列中。</td></tr><tr><td><code>x not in s</code></td><td>如果 <code>x</code> 不是 <code>s</code> 的元素，返回 <code>True</code>，否则返回 <code>False</code>。用于检查元素是否不在序列中。</td></tr><tr><td><code>s + t</code></td><td>连接序列 <code>s</code> 和序列 <code>t</code>。返回一个新序列，包含 <code>s</code> 和 <code>t</code> 的所有元素。</td></tr><tr><td><code>s * n</code> 或 <code>n * s</code></td><td>将序列 <code>s</code> 复制 <code>n</code> 次。返回一个新的序列，包含 <code>s</code> 被重复 <code>n</code> 次后的所有元素。</td></tr><tr><td><code>s[i]</code></td><td>索引操作，返回序列 <code>s</code> 中的第 <code>i</code> 个元素。索引从 0 开始。</td></tr><tr><td><code>s[i:j]</code></td><td>分片操作，返回序列 <code>s</code> 中从索引 <code>i</code> 到 <code>j</code> 的元素，<strong>不包含</strong>第 <code>j</code> 个元素。</td></tr><tr><td><code>s[i:j:k]</code></td><td>步长分片，返回序列 <code>s</code> 中从索引 <code>i</code> 到 <code>j</code>，以步长 <code>k</code> 选取的元素。</td></tr><tr><td><code>len(s)</code></td><td>返回序列 <code>s</code> 中元素的个数，即序列的长度。</td></tr><tr><td><code>min(s)</code></td><td>返回序列 <code>s</code> 中的最小元素。适用于可比较元素（如数字、字符串）。</td></tr><tr><td><code>max(s)</code></td><td>返回序列 <code>s</code> 中的最大元素。适用于可比较元素（如数字、字符串）。</td></tr><tr><td><code>s.index(x[, i, j])</code></td><td>返回元素 <code>x</code> 在序列 <code>s</code> 中第一次出现的位置（索引）。可选参数 <code>i</code> 和 <code>j</code> 指定搜索的范围。</td></tr><tr><td><code>s.count(x)</code></td><td>返回元素 <code>x</code> 在序列 <code>s</code> 中出现的次数。</td></tr></tbody></table></figure><hr /><h5><a name='header-n2450' class='md-header-anchor '></a>扩展操作和方法</h5><p>除了上述基本操作符和函数外，序列类型还支持一些扩展的操作和方法。以下是一些常用的扩展操作：</p><h5><a name='header-n2453' class='md-header-anchor '></a>1. <strong>切片与步长</strong></h5><ul><li><p>切片操作</p><p>允许我们选择序列的子集，可以指定开始、结束和步长，提供更多灵活的操作。</p><pre class="md-fences mock-cm md-end-block" lang="">s = [1, 2, 3, 4, 5, 6, 7, 8]
print(s[1:5])   # 输出 [2, 3, 4, 5]
print(s[:4])    # 输出 [1, 2, 3, 4]
print(s[2:])    # 输出 [3, 4, 5, 6, 7, 8]
print(s[::2])   # 输出 [1, 3, 5, 7]
print(s[::-1])  # 输出 [8, 7, 6, 5, 4, 3, 2, 1]（反转序列）
</pre></li></ul><h5><a name='header-n2461' class='md-header-anchor '></a>2. <strong>连接操作</strong></h5><ul><li><p>使用 </p><pre class="md-fences mock-cm md-end-block" lang="">+
</pre><p> 操作符可以连接两个序列。</p><pre class="md-fences mock-cm md-end-block" lang="">lst1 = [1, 2, 3]
lst2 = [4, 5, 6]
print(lst1 + lst2)  # 输出 [1, 2, 3, 4, 5, 6]
</pre></li></ul><h5><a name='header-n2470' class='md-header-anchor '></a>3. <strong>重复操作</strong></h5><ul><li><p>使用 </p><pre class="md-fences mock-cm md-end-block" lang="">*
</pre><p> 操作符可以重复序列的元素。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3]
print(lst * 3)  # 输出 [1, 2, 3, 1, 2, 3, 1, 2, 3]
</pre></li></ul><h5><a name='header-n2479' class='md-header-anchor '></a>4. <strong>成员操作</strong></h5><ul><li><p>使用 </p><pre class="md-fences mock-cm md-end-block" lang="">in
</pre><p> 和 </p><pre class="md-fences mock-cm md-end-block" lang="">not in
</pre><p> 来检查某个元素是否存在于序列中。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3, 4, 5]
print(3 in lst)   # 输出 True
print(6 not in lst)  # 输出 True
</pre></li></ul><hr /><h5><a name='header-n2492' class='md-header-anchor '></a>其它常用的序列方法</h5><p>除了基本的操作符外，序列类型还提供了一些常用的方法，可以帮助我们更加方便地处理序列数据。</p><h6><a name='header-n2495' class='md-header-anchor '></a>1. <strong>list.append(x)</strong></h6><ul><li><p>将元素 </p><pre class="md-fences mock-cm md-end-block" lang="">x
</pre><p> 添加到列表的末尾。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3]
lst.append(4)
print(lst)  # 输出 [1, 2, 3, 4]
</pre></li></ul><h6><a name='header-n2504' class='md-header-anchor '></a>2. <strong>list.insert(i, x)</strong></h6><ul><li><p>在指定的索引位置 </p><pre class="md-fences mock-cm md-end-block" lang="">i
</pre><p> 插入元素 </p><pre class="md-fences mock-cm md-end-block" lang="">x
</pre><p>。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3]
lst.insert(1, 10)
print(lst)  # 输出 [1, 10, 2, 3]
</pre></li></ul><h6><a name='header-n2516' class='md-header-anchor '></a>3. <strong>list.remove(x)</strong></h6><ul><li><p>移除列表中第一个出现的元素 </p><pre class="md-fences mock-cm md-end-block" lang="">x
</pre><p>。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3, 2]
lst.remove(2)
print(lst)  # 输出 [1, 3, 2]
</pre></li></ul><h6><a name='header-n2525' class='md-header-anchor '></a>4. <strong>list.pop([i])</strong></h6><ul><li><p>移除并返回索引位置 </p><pre class="md-fences mock-cm md-end-block" lang="">i
</pre><p> 的元素，默认移除并返回最后一个元素。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3]
print(lst.pop())   # 输出 3
print(lst.pop(0))  # 输出 1，列表变为 [2]
</pre></li></ul><h6><a name='header-n2534' class='md-header-anchor '></a>5. <strong>list.sort()</strong></h6><ul><li><p>对列表中的元素进行排序。默认按升序排列。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [3, 1, 4, 2]
lst.sort()
print(lst)  # 输出 [1, 2, 3, 4]
</pre></li></ul><h6><a name='header-n2540' class='md-header-anchor '></a>6. <strong>list.reverse()</strong></h6><ul><li><p>将列表中的元素顺序反转。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3]
lst.reverse()
print(lst)  # 输出 [3, 2, 1]
</pre></li></ul><h6><a name='header-n2546' class='md-header-anchor '></a>7. <strong>tuple.count(x)</strong></h6><ul><li><p>返回元组中元素 </p><pre class="md-fences mock-cm md-end-block" lang="">x
</pre><p> 的出现次数。</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2, 3, 2, 2)
print(tup.count(2))  # 输出 3

</pre></li></ul><h6><a name='header-n2555' class='md-header-anchor '></a>8. <strong>tuple.index(x)</strong></h6><ul><li><h6><a name='header-n2558' class='md-header-anchor '></a>返回元组中元素</h6><pre class="md-fences mock-cm md-end-block" lang="">x
</pre><p> 第一次出现的位置。</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2, 3, 4)
print(tup.index(3))  # 输出 2
</pre></li></ul><hr /><h4><a name='header-n2564' class='md-header-anchor '></a>总结</h4><p>在 Python 中，序列类型包括 <strong>列表（list）</strong>、<strong>元组（tuple）</strong> 和 <strong>字符串（str）</strong> 等。它们都支持强大的操作符和方法来方便地进行元素访问、修改、删除、排序和切片等操作。通过掌握这些操作，能够更加高效地处理数据结构，并提高代码的简洁性和可读性。</p><h4><a name='header-n2567' class='md-header-anchor '></a>6.1.2 集合类型（Set）</h4><p>集合是 Python 中的一种无序、不重复的数据结构，类似于数学中的集合。集合的主要特点是<strong>不允许重复的元素</strong>，并且<strong>没有顺序</strong>，所以不能通过索引访问集合中的元素。</p><h5><a name='header-n2570' class='md-header-anchor '></a>集合的特点：</h5><ul><li><strong>无序</strong>：集合中的元素没有顺序，不能使用索引访问。</li><li><strong>不重复</strong>：集合中的元素不能重复，自动去重。</li><li><strong>可变</strong>：集合是可变的，可以动态添加或删除元素。</li><li><strong>不支持索引、切片和其他序列操作</strong>。</li></ul><h5><a name='header-n2584' class='md-header-anchor '></a>创建集合</h5><p>可以通过 <code>set()</code> 函数来创建集合，或者使用 <code>{}</code> 包裹元素创建集合。</p><pre class="md-fences mock-cm md-end-block" lang=""># 创建一个空集合
s = set()

# 创建一个包含元素的集合
s = {1, 2, 3, 4, 5}

# 使用 set() 函数创建集合
s = set([1, 2, 3, 4, 5])
</pre><h5><a name='header-n2588' class='md-header-anchor '></a>访问集合</h5><p>由于集合是无序的，因此不能通过索引、切片等方式访问其元素。你可以使用 <code>for</code> 循环遍历集合中的元素：</p><pre class="md-fences mock-cm md-end-block" lang="">s = {1, 2, 3, 4, 5}
for elem in s:
    print(elem)
</pre><h5><a name='header-n2592' class='md-header-anchor '></a>常见操作</h5><ol start='' ><li><p><strong>添加元素</strong>使用 <code>add()</code> 方法向集合中添加单个元素。</p><pre class="md-fences mock-cm md-end-block" lang="">s = {1, 2, 3}
s.add(4)
print(s)  # 输出 {1, 2, 3, 4}
</pre></li><li><p><strong>删除元素</strong>使用 <code>remove()</code> 或 <code>discard()</code> 方法删除集合中的元素。<code>remove()</code> 删除元素时，如果元素不存在会抛出异常，而 <code>discard()</code> 则不会抛出异常。</p><pre class="md-fences mock-cm md-end-block" lang="">s = {1, 2, 3, 4}
s.remove(3)
print(s)  # 输出 {1, 2, 4}

s.discard(5)  # 元素5不存在，不会抛出异常
print(s)  # 输出 {1, 2, 4}
</pre></li><li><p><strong>集合的运算</strong>集合支持并集、交集、差集等数学运算：</p><ul><li><p><strong>并集</strong>：<code>union()</code> 或 <code>|</code></p><pre class="md-fences mock-cm md-end-block" lang="">s1 = {1, 2, 3}
s2 = {3, 4, 5}
print(s1 | s2)  # 输出 {1, 2, 3, 4, 5}
</pre></li><li><p><strong>交集</strong>：<code>intersection()</code> 或 <code>&amp;</code></p><pre class="md-fences mock-cm md-end-block" lang="">print(s1 &amp; s2)  # 输出 {3}
</pre></li><li><p><strong>差集</strong>：<code>difference()</code> 或 <code>-</code></p><pre class="md-fences mock-cm md-end-block" lang="">print(s1 - s2)  # 输出 {1, 2}
</pre></li><li><p><strong>对称差集</strong>：<code>symmetric_difference()</code> 或 <code>^</code></p><pre class="md-fences mock-cm md-end-block" lang="">print(s1 ^ s2)  # 输出 {1, 2, 4, 5}
</pre></li></ul></li><li><p><strong>集合的测试</strong></p><ul><li><p><strong>子集测试</strong>：使用 <code>issubset()</code> 或 <code>&lt;=</code> 检查一个集合是否是另一个集合的子集。</p><pre class="md-fences mock-cm md-end-block" lang="">s1 = {1, 2}
s2 = {1, 2, 3}
print(s1 &lt;= s2)  # 输出 True
</pre></li><li><p><strong>超集测试</strong>：使用 <code>issuperset()</code> 或 <code>&gt;=</code> 检查一个集合是否是另一个集合的超集。</p><pre class="md-fences mock-cm md-end-block" lang="">print(s2 &gt;= s1)  # 输出 True
</pre></li></ul></li><li><p><strong>集合的长度和清空</strong></p><ul><li><p><strong>长度</strong>：使用 <code>len()</code> 函数获取集合的元素个数。</p><pre class="md-fences mock-cm md-end-block" lang="">print(len(s))  # 输出集合中元素的数量
</pre></li><li><p><strong>清空集合</strong>：使用 <code>clear()</code> 方法清空集合中的所有元素。</p><pre class="md-fences mock-cm md-end-block" lang="">s.clear()
print(s)  # 输出 set()
</pre></li></ul></li></ol><h5><a name='header-n2646' class='md-header-anchor '></a>集合的应用</h5><ul><li><p>去重：集合的元素不允许重复，常用于去除列表中的重复项。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 2, 3, 3, 4]
unique_lst = list(set(lst))  # 去重后的列表
print(unique_lst)  # 输出 [1, 2, 3, 4]
</pre></li></ul><hr /><h4><a name='header-n2653' class='md-header-anchor '></a>6.1.3 映射类型（Dictionary）</h4><p>映射（字典）类型是 Python 中的一种 <strong>无序</strong> 的 <strong>键值对</strong> 数据结构。字典的每个元素由一个键（key）和一个值（value）组成，通过键来访问对应的值。字典常用于表示一些关联关系，如数据库中的记录、配置文件、对象属性等。</p><h5><a name='header-n2656' class='md-header-anchor '></a>字典的特点：</h5><ul><li><strong>无序</strong>：字典中的元素没有顺序，不能通过索引来访问。</li><li><strong>可变</strong>：字典是可变的，可以添加、删除、修改键值对。</li><li><strong>键唯一</strong>：字典中的每个键必须唯一，但值可以重复。</li><li><strong>键必须是不可变类型</strong>（如字符串、整数、元组等），而值可以是任意类型。</li></ul><h5><a name='header-n2670' class='md-header-anchor '></a>创建字典</h5><p>可以使用大括号 <code>{}</code> 或 <code>dict()</code> 函数来创建字典。</p><pre class="md-fences mock-cm md-end-block" lang=""># 使用大括号创建字典
d = {'name': 'Alice', 'age': 25, 'city': 'Beijing'}

# 使用 dict() 函数创建字典
d = dict(name='Alice', age=25, city='Beijing')
</pre><h5><a name='header-n2674' class='md-header-anchor '></a>访问字典元素</h5><p>通过键来访问字典中的值，可以使用 <code>[]</code> 或 <code>get()</code> 方法。</p><pre class="md-fences mock-cm md-end-block" lang="">print(d['name'])  # 输出 'Alice'
print(d.get('age'))  # 输出 25
</pre><h5><a name='header-n2678' class='md-header-anchor '></a>常见操作</h5><ol start='' ><li><p><strong>添加或更新键值对</strong></p><ul><li>如果键已存在，会更新值；如果键不存在，则会添加新的键值对。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">d['email'] = 'alice@example.com'  # 添加新的键值对
d['age'] = 26  # 更新键 'age' 对应的值
print(d)  # 输出 {'name': 'Alice', 'age': 26, 'city': 'Beijing', 'email': 'alice@example.com'}
</pre></li><li><p><strong>删除键值对</strong>使用 <code>del</code> 关键字删除字典中的元素，或使用 <code>pop()</code> 方法删除并返回指定键的值。</p><pre class="md-fences mock-cm md-end-block" lang="">del d['city']  # 删除键 'city' 对应的键值对
print(d)  # 输出 {'name': 'Alice', 'age': 26, 'email': 'alice@example.com'}

age = d.pop('age')  # 删除并返回 'age' 键的值
print(age)  # 输出 26
print(d)  # 输出 {'name': 'Alice', 'email': 'alice@example.com'}
</pre></li><li><p><strong>遍历字典</strong>字典的遍历可以通过 <code>keys()</code>、<code>values()</code> 或 <code>items()</code> 方法来进行。</p><ul><li><p>遍历键：</p><pre class="md-fences mock-cm md-end-block" lang="">for key in d.keys():
    print(key)
</pre></li><li><p>遍历值：</p><pre class="md-fences mock-cm md-end-block" lang="">for value in d.values():
    print(value)
</pre></li><li><p>遍历键值对：</p><pre class="md-fences mock-cm md-end-block" lang="">for key, value in d.items():
    print(f'{key}: {value}')
</pre></li></ul></li><li><p><strong>获取字典的长度</strong>使用 <code>len()</code> 函数获取字典中键值对的数量。</p><pre class="md-fences mock-cm md-end-block" lang="">print(len(d))  # 输出字典中键值对的数量
</pre></li><li><p><strong>清空字典</strong>使用 <code>clear()</code> 方法清空字典中的所有元素。</p><pre class="md-fences mock-cm md-end-block" lang="">d.clear()
print(d)  # 输出 {}
</pre></li><li><p><strong>字典的合并</strong>Python 3.9 及以上版本，使用 <code>|</code> 操作符可以合并两个字典：</p><pre class="md-fences mock-cm md-end-block" lang="">d1 = {'a': 1, 'b': 2}
d2 = {'c': 3, 'd': 4}
d3 = d1 | d2
print(d3)  # 输出 {'a': 1, 'b': 2, 'c': 3, 'd': 4}
</pre></li></ol><hr /><h4><a name='header-n2721' class='md-header-anchor '></a>总结</h4><ul><li><strong>集合</strong>（<code>set</code>）是一个无序、可变、不允许重复的元素容器，常用于去重和集合运算。</li><li><strong>字典</strong>（<code>dict</code>）是一种无序的键值对集合，常用于表示映射关系。它的键是唯一的，而值可以重复。</li></ul><p>这两种数据类型在处理数据和实现各种功能时具有重要作用，可以根据需求选择合适的类型来存储和操作数据。</p><h5><a name='header-n2731' class='md-header-anchor '></a>6.1.4 元组类型（Tuple）</h5><p>元组（<strong>Tuple</strong>）是 Python 中一种<strong>不可变的序列类型</strong>。与列表（List）非常相似，元组也是一个有序集合，允许存储多个元素，但不同的是，元组一旦创建，就不能修改它的内容。因此，元组适用于存储那些不应该改变的数据。</p><h5><a name='header-n2734' class='md-header-anchor '></a>元组的特点：</h5><ul><li><strong>有序</strong>：元组中的元素是有顺序的，且可以通过索引访问。</li><li><strong>不可变</strong>：元组一旦创建，其内容无法更改。这意味着你不能修改元组中的元素、添加新元素或删除元素。</li><li><strong>允许重复元素</strong>：与列表类似，元组也允许重复的元素。</li><li><strong>可以包含不同类型的数据</strong>：元组中的元素可以是任何数据类型，包括数字、字符串、列表、字典，甚至其他元组。</li></ul><h5><a name='header-n2748' class='md-header-anchor '></a>创建元组</h5><ol start='' ><li><p><strong>通过小括号 () 创建元组</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">tup1 = (1, 2, 3, 4, 5)
tup2 = ('a', 'b', 'c')
tup3 = (1, 'hello', 3.14, [1, 2, 3], (4, 5))
</pre></li><li><p><strong>没有元素的元组</strong>：创建空元组可以使用空的小括号：</p><pre class="md-fences mock-cm md-end-block" lang="">empty_tuple = ()
</pre><p>注意：如果要创建包含单个元素的元组，必须在元素后加一个逗号，例如 <code>(1,)</code>，否则会被视为普通的括号表达式：</p><pre class="md-fences mock-cm md-end-block" lang="">single_element_tuple = (1,)  # 正确，创建一个元组
non_tuple = (1)  # 错误，创建的是一个整数，而不是元组
</pre></li><li><p><strong>通过 tuple() 函数创建元组</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">tup_from_list = tuple([1, 2, 3, 4])  # 从列表创建元组
tup_from_str = tuple('hello')  # 从字符串创建元组
print(tup_from_list)  # 输出 (1, 2, 3, 4)
print(tup_from_str)  # 输出 ('h', 'e', 'l', 'l', 'o')
</pre></li></ol><h5><a name='header-n2765' class='md-header-anchor '></a>访问元组元素</h5><p>元组的元素可以通过索引访问，索引从 <code>0</code> 开始。如果使用负数索引，则从元组的尾部开始访问（<code>-1</code> 表示最后一个元素，<code>-2</code> 表示倒数第二个元素，依此类推）。</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2, 3, 4, 5)
print(tup[0])  # 输出 1
print(tup[-1])  # 输出 5
print(tup[1:4])  # 输出 (2, 3, 4)，从索引1到3的元素
</pre><h5><a name='header-n2769' class='md-header-anchor '></a>元组的不可变性</h5><p>由于元组是不可变的，不能修改它的内容，包括不能修改、删除或添加元素。例如：</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2, 3)
tup[0] = 100  # TypeError: 'tuple' object does not support item assignment
</pre><p>但是，可以通过重新赋值整个元组来实现&quot;间接修改&quot;（实际上是创建了一个新的元组）：</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2, 3)
tup = (100, 200, 300)  # 重新赋值，实际上是创建了一个新的元组
print(tup)  # 输出 (100, 200, 300)
</pre><h5><a name='header-n2776' class='md-header-anchor '></a>元组的常见操作</h5><p>尽管元组是不可变的，但它们仍然支持许多与列表类似的操作：</p><ol start='' ><li><p><strong>连接元组</strong>使用 <code>+</code> 运算符可以将两个元组连接成一个新元组。</p><pre class="md-fences mock-cm md-end-block" lang="">tup1 = (1, 2, 3)
tup2 = (4, 5, 6)
result = tup1 + tup2
print(result)  # 输出 (1, 2, 3, 4, 5, 6)
</pre></li><li><p><strong>重复元组</strong>使用 <code>*</code> 运算符可以将元组重复指定次数。</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2, 3)
repeated = tup * 3
print(repeated)  # 输出 (1, 2, 3, 1, 2, 3, 1, 2, 3)
</pre></li><li><p><strong>查找元素</strong>使用 <code>in</code> 关键字检查某个元素是否在元组中。</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2, 3, 4, 5)
print(3 in tup)  # 输出 True
print(6 in tup)  # 输出 False
</pre></li><li><p><strong>计算元组的长度</strong>使用 <code>len()</code> 函数获取元组中元素的个数。</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2, 3, 4, 5)
print(len(tup))  # 输出 5
</pre></li><li><p><strong>查找元素的索引</strong>使用 <code>index()</code> 方法查找元素第一次出现的位置。</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2, 3, 4, 5)
print(tup.index(3))  # 输出 2
</pre></li><li><p><strong>统计元素的出现次数</strong>使用 <code>count()</code> 方法计算某个元素在元组中出现的次数。</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2, 3, 2, 2, 4, 5)
print(tup.count(2))  # 输出 3
</pre></li></ol><h5><a name='header-n2804' class='md-header-anchor '></a>元组的解包（Tuple Unpacking）</h5><p>元组的解包是将元组的元素赋值给多个变量，按位置进行匹配。这在处理返回多个值的函数时特别有用。</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2, 3)
a, b, c = tup  # 解包元组
print(a)  # 输出 1
print(b)  # 输出 2
print(c)  # 输出 3
</pre><p>解包时，元组中的元素数量必须与变量的数量匹配。如果数量不匹配，Python 会抛出错误：</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2)
a, b, c = tup  # ValueError: not enough values to unpack
</pre><p>可以使用 <code>_</code> 来丢弃某些值：</p><pre class="md-fences mock-cm md-end-block" lang="">tup = (1, 2, 3)
a, _, c = tup  # 丢弃中间的元素
print(a, c)  # 输出 1 3
</pre><h5><a name='header-n2814' class='md-header-anchor '></a>元组的应用</h5><p>元组的不可变性使其非常适合用于存储<strong>不应改变的数据</strong>，比如：</p><ul><li><p><strong>返回多个值</strong>：函数返回多个值时，常用元组作为返回类型。</p><pre class="md-fences mock-cm md-end-block" lang="">def min_max(values):
    return (min(values), max(values))

result = min_max([1, 5, 3, 9, 2])
print(result)  # 输出 (1, 9)
</pre></li><li><p><strong>作为字典的键</strong>：由于元组是不可变的，它可以作为字典的键。而列表是可变的，不能作为字典的键。</p><pre class="md-fences mock-cm md-end-block" lang="">d = {('a', 'b'): 1, ('c', 'd'): 2}
print(d[('a', 'b')])  # 输出 1
</pre></li></ul><hr /><h4><a name='header-n2827' class='md-header-anchor '></a>总结</h4><p>元组是 Python 中一种<strong>不可变</strong>的序列类型，具有与列表类似的访问方式和操作，但不可修改其内容。元组非常适合用于存储不应被修改的数据，同时也可以用作字典的键。元组的主要优势在于其<strong>不可变性</strong>，这使得它在许多需要保证数据不被改变的场景中非常有用。</p><h3><a name='header-n2830' class='md-header-anchor '></a>6.2 列表类型和操作</h3><p>列表（<strong>List</strong>）是 Python 中最常用的一种<strong>可变序列</strong>类型，允许你存储多个元素。与元组不同，列表是<strong>可变的</strong>，这意味着列表的内容可以在创建之后进行修改。列表的元素可以是不同类型的，也可以包含其他列表等复合类型。</p><h4><a name='header-n2833' class='md-header-anchor '></a>6.2.1 列表类型的概念</h4><ul><li><strong>有序</strong>：列表中的元素是有顺序的，并且可以通过索引来访问。</li><li><strong>可变</strong>：与元组的不可变性不同，列表是可变的。你可以修改、添加或删除列表中的元素。</li><li><strong>允许重复元素</strong>：列表中的元素可以是重复的。</li><li><strong>支持不同数据类型</strong>：列表中的元素可以是不同类型的数据，包括整数、浮点数、字符串、其他列表，甚至是元组、字典等复杂类型。</li></ul><h5><a name='header-n2847' class='md-header-anchor '></a>创建列表</h5><p>列表是通过方括号 <code>[]</code> 来创建的，可以包含多个元素，元素之间用逗号 <code>,</code> 分隔。</p><pre class="md-fences mock-cm md-end-block" lang=""># 创建一个包含不同数据类型的列表
list1 = [1, 2, 3, 4, 5]  # 数字列表
list2 = ['apple', 'banana', 'cherry']  # 字符串列表
list3 = [1, 2.5, 'hello', [1, 2], {'key': 'value'}, (1, 2)]  # 混合类型列表

# 创建空列表
empty_list = []

# 创建包含单个元素的列表
single_item_list = [42]
</pre><h5><a name='header-n2851' class='md-header-anchor '></a>列表的索引和切片</h5><ul><li><strong>索引</strong>：通过索引访问列表中的元素，索引从 <code>0</code> 开始。</li><li><strong>切片</strong>：可以通过切片操作从列表中提取子列表。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">lst = [10, 20, 30, 40, 50]

# 访问第一个元素
print(lst[0])  # 输出 10

# 访问最后一个元素
print(lst[-1])  # 输出 50

# 切片操作：获取从第二个到第四个元素
print(lst[1:4])  # 输出 [20, 30, 40]

# 切片操作：从第一个元素开始，步长为2
print(lst[::2])  # 输出 [10, 30, 50]
</pre><h5><a name='header-n2860' class='md-header-anchor '></a>列表的操作</h5><h5><a name='header-n2861' class='md-header-anchor '></a>列表支持多种常用的操作符和方法，包括添加、删除、修改、查找等操作。</h5><h5><a name='header-n2862' class='md-header-anchor '></a>1. <strong>添加元素</strong></h5><ul><li><p>使用 <code>append()</code> 方法将元素添加到列表的末尾。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3]
lst.append(4)  # 添加4到列表末尾
print(lst)  # 输出 [1, 2, 3, 4]
</pre></li><li><p>使用 <code>insert()</code> 方法在指定位置插入元素。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3]
lst.insert(1, 'a')  # 在索引1处插入元素'a'
print(lst)  # 输出 [1, 'a', 2, 3]
</pre></li></ul><h5><a name='header-n2872' class='md-header-anchor '></a>2. <strong>删除元素</strong></h5><ul><li><p>使用 <code>remove()</code> 方法删除列表中的指定元素。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3, 2, 4]
lst.remove(2)  # 删除第一个出现的元素2
print(lst)  # 输出 [1, 3, 2, 4]
</pre></li><li><p>使用 <code>pop()</code> 方法删除并返回指定索引位置的元素。如果不指定索引，则删除并返回最后一个元素。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [10, 20, 30]
lst.pop(1)  # 删除索引1的元素
print(lst)  # 输出 [10, 30]

last_item = lst.pop()  # 删除并返回最后一个元素
print(last_item)  # 输出 30
print(lst)  # 输出 [10]
</pre></li><li><p>使用 <code>clear()</code> 方法删除所有元素，清空列表。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3]
lst.clear()  # 清空列表
print(lst)  # 输出 []
</pre></li></ul><h5><a name='header-n2886' class='md-header-anchor '></a>3. <strong>修改元素</strong></h5><ul><li><p>使用索引来修改列表中的元素。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [10, 20, 30]
lst[1] = 25  # 修改索引1的元素为25
print(lst)  # 输出 [10, 25, 30]
</pre></li></ul><h5><a name='header-n2892' class='md-header-anchor '></a>4. <strong>查找元素</strong></h5><ul><li><p>使用 <code>in</code> 关键字检查元素是否在列表中。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3, 4, 5]
print(3 in lst)  # 输出 True
print(6 in lst)  # 输出 False
</pre></li><li><p>使用 <code>index()</code> 方法查找元素第一次出现的位置（索引）。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [10, 20, 30, 20, 40]
print(lst.index(20))  # 输出 1
</pre></li><li><p>使用 <code>count()</code> 方法统计元素在列表中出现的次数。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [10, 20, 30, 20, 40]
print(lst.count(20))  # 输出 2
</pre></li></ul><h5><a name='header-n2906' class='md-header-anchor '></a>5. <strong>其他常用操作</strong></h5><ul><li><p><strong>连接列表</strong>：使用 <code>+</code> 运算符将两个列表连接在一起，生成一个新的列表。</p><pre class="md-fences mock-cm md-end-block" lang="">lst1 = [1, 2, 3]
lst2 = [4, 5, 6]
lst3 = lst1 + lst2
print(lst3)  # 输出 [1, 2, 3, 4, 5, 6]
</pre></li><li><p><strong>重复列表</strong>：使用 <code>*</code> 运算符重复列表元素，生成一个新的列表。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3]
repeated_lst = lst * 3
print(repeated_lst)  # 输出 [1, 2, 3, 1, 2, 3, 1, 2, 3]
</pre></li><li><p><strong>计算长度</strong>：使用 <code>len()</code> 函数获取列表的长度（即元素个数）。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3, 4, 5]
print(len(lst))  # 输出 5
</pre></li><li><p><strong>排序</strong>：使用 <code>sort()</code> 方法对列表进行排序。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [3, 1, 4, 5, 2]
lst.sort()  # 默认升序排序
print(lst)  # 输出 [1, 2, 3, 4, 5]
</pre><p>使用 <code>sorted()</code> 函数返回排序后的列表（不会修改原列表）。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [3, 1, 4, 5, 2]
new_lst = sorted(lst)  # 返回一个排序后的新列表
print(new_lst)  # 输出 [1, 2, 3, 4, 5]
print(lst)  # 原列表 lst 没有改变，输出 [3, 1, 4, 5, 2]
</pre></li><li><p><strong>反向</strong>：使用 <code>reverse()</code> 方法对列表进行反向操作。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [1, 2, 3, 4]
lst.reverse()  # 反转列表
print(lst)  # 输出 [4, 3, 2, 1]
</pre></li></ul><h4><a name='header-n2931' class='md-header-anchor '></a>6.2.2 列表类型的操作</h4><p>除了基本的操作符，列表还有一些特有的操作方法，如：</p><ul><li><p><strong>切片操作</strong>列表的切片操作非常强大，可以提取列表中的一部分：</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [10, 20, 30, 40, 50]
sub_lst = lst[1:4]  # 获取从索引1到3的元素
print(sub_lst)  # 输出 [20, 30, 40]
</pre></li><li><p><strong>列表推导式</strong>列表推导式是一种简洁的创建和操作列表的方式。它允许你通过简单的表达式创建新列表。</p><pre class="md-fences mock-cm md-end-block" lang="">lst = [x ** 2 for x in range(5)]
print(lst)  # 输出 [0, 1, 4, 9, 16]
</pre></li><li><p><strong>嵌套列表</strong>列表可以包含其他列表，称为嵌套列表。可以通过多重索引访问元素。</p><pre class="md-fences mock-cm md-end-block" lang="">nested_lst = [[1, 2], [3, 4], [5, 6]]
print(nested_lst[0][1])  # 输出 2
</pre></li></ul><hr /><h4><a name='header-n2948' class='md-header-anchor '></a>总结</h4><p>列表是 Python 中非常重要和常用的基础数据结构之一。它提供了灵活的数据存储方式，支持多种常见的操作（如索引、切片)</p><h3><a name='header-n2951' class='md-header-anchor '></a>6.3 实例9：基本统计值计算</h3><p>本节通过一个简单的实例演示如何计算基本统计值，如均值、方差、标准差等。我们使用 Python 的内建函数和库（如 <code>sum()</code>, <code>len()</code> 和 <code>math</code>）来计算数据的基本统计值。</p><h4><a name='header-n2954' class='md-header-anchor '></a>6.3.1 计算均值</h4><p>均值（Mean）是数据集的总和除以元素的个数，表示数据的集中趋势。可以使用 <code>sum()</code> 函数和 <code>len()</code> 函数计算均值。</p><pre class="md-fences mock-cm md-end-block" lang="">data = [10, 20, 30, 40, 50]

# 计算均值
mean = sum(data) / len(data)
print("均值:", mean)  # 输出均值 30.0
</pre><h4><a name='header-n2958' class='md-header-anchor '></a>6.3.2 计算方差</h4><p>方差（Variance）是每个数据点与均值的差异的平方的平均值。它度量了数据的离散程度。计算方差时，我们首先计算每个数据点与均值的差的平方，再求平均。</p><pre class="md-fences mock-cm md-end-block" lang=""># 计算方差
variance = sum((x - mean) ** 2 for x in data) / len(data)
print("方差:", variance)  # 输出方差 200.0
</pre><h4><a name='header-n2962' class='md-header-anchor '></a>6.3.3 计算标准差</h4><p>标准差（Standard Deviation）是方差的平方根，它也反映数据的离散程度，但与方差相比，标准差的单位与原数据一致。</p><pre class="md-fences mock-cm md-end-block" lang="">import math

# 计算标准差
std_dev = math.sqrt(variance)
print("标准差:", std_dev)  # 输出标准差 14.142135623730951
</pre><h4><a name='header-n2966' class='md-header-anchor '></a>6.3.4 计算中位数</h4><p>中位数（Median）是将数据从小到大排列后，位于中间位置的数值。如果数据有偶数个元素，中位数是中间两个数的平均值。</p><pre class="md-fences mock-cm md-end-block" lang=""># 计算中位数
data_sorted = sorted(data)
n = len(data_sorted)
if n % 2 == 1:
    median = data_sorted[n // 2]
else:
    median = (data_sorted[n // 2 - 1] + data_sorted[n // 2]) / 2

print("中位数:", median)  # 输出中位数 30
</pre><h4><a name='header-n2970' class='md-header-anchor '></a>6.3.5 计算众数</h4><p>众数（Mode）是数据中出现频率最高的值。如果有多个元素频率相同，则可以有多个众数。</p><pre class="md-fences mock-cm md-end-block" lang="">from collections import Counter

# 计算众数
counter = Counter(data)
mode = counter.most_common(1)[0][0]
print("众数:", mode)  # 输出众数 10, 假设数据没有重复，或者是其中频率最高的一个
</pre><hr /><h3><a name='header-n2975' class='md-header-anchor '></a>6.4 字典类型和操作</h3><p>字典（<strong>Dictionary</strong>）是 Python 中一种无序的、可变的、以键值对存储数据的数据结构。字典的键是唯一的，而值则可以是任意类型。字典通常用于存储关联数据，例如将某个人的姓名与他的电话号码关联。</p><h4><a name='header-n2978' class='md-header-anchor '></a>6.4.1 字典类型的概念</h4><p>字典是由一系列的键值对（key-value pairs）组成的，每个键值对通过冒号 <code>:</code> 分隔，键和值之间使用逗号 <code>,</code> 分隔。字典的特点包括：</p><ul><li><strong>无序</strong>：字典中的元素是无序的，从 Python 3.7 以后，字典开始保持插入顺序，但仍不支持索引操作。</li><li><strong>键是唯一的</strong>：字典中的键不能重复。</li><li><strong>可变性</strong>：字典是可变的，可以在创建后进行修改。</li></ul><h4><a name='header-n2991' class='md-header-anchor '></a>6.4.2 字典类型的操作</h4><h5><a name='header-n2992' class='md-header-anchor '></a>1. <strong>创建字典</strong></h5><p>字典可以通过大括号 <code>{}</code> 或 <code>dict()</code> 构造函数创建。</p><pre class="md-fences mock-cm md-end-block" lang=""># 使用大括号创建字典
person = {"name": "Alice", "age": 25, "city": "New York"}

# 使用 dict() 创建字典
person = dict(name="Alice", age=25, city="New York")

print(person)  # 输出 {'name': 'Alice', 'age': 25, 'city': 'New York'}
</pre><h5><a name='header-n2996' class='md-header-anchor '></a>2. <strong>访问字典中的值</strong></h5><p>可以通过字典的键访问对应的值。如果键不存在，将抛出 <code>KeyError</code> 错误。可以使用 <code>get()</code> 方法来避免错误。</p><pre class="md-fences mock-cm md-end-block" lang=""># 通过键访问值
print(person["name"])  # 输出 'Alice'

# 使用 get() 方法，避免 KeyError
print(person.get("name"))  # 输出 'Alice'
print(person.get("gender", "Unknown"))  # 如果键不存在，返回 'Unknown'
</pre><h5><a name='header-n3000' class='md-header-anchor '></a>3. <strong>修改字典中的值</strong></h5><p>可以通过指定键来修改字典中的值。</p><pre class="md-fences mock-cm md-end-block" lang=""># 修改字典中的值
person["age"] = 26
print(person)  # 输出 {'name': 'Alice', 'age': 26, 'city': 'New York'}
</pre><h5><a name='header-n3004' class='md-header-anchor '></a>4. <strong>添加键值对</strong></h5><p>使用字典的赋值语法可以向字典中添加新的键值对。</p><pre class="md-fences mock-cm md-end-block" lang=""># 向字典中添加键值对
person["gender"] = "Female"
print(person)  # 输出 {'name': 'Alice', 'age': 26, 'city': 'New York', 'gender': 'Female'}
</pre><h5><a name='header-n3008' class='md-header-anchor '></a>5. <strong>删除键值对</strong></h5><p>可以使用 <code>del</code> 语句或 <code>pop()</code> 方法删除字典中的键值对。</p><pre class="md-fences mock-cm md-end-block" lang=""># 使用 del 删除键值对
del person["gender"]
print(person)  # 输出 {'name': 'Alice', 'age': 26, 'city': 'New York'}

# 使用 pop() 删除键值对并返回对应的值
age = person.pop("age")
print(age)  # 输出 26
print(person)  # 输出 {'name': 'Alice', 'city': 'New York'}
</pre><h5><a name='header-n3012' class='md-header-anchor '></a>6. <strong>字典的常用方法</strong></h5><ul><li><code>keys()</code>：返回字典中所有键。</li><li><code>values()</code>：返回字典中所有值。</li><li><code>items()</code>：返回字典中所有键值对。</li><li><code>clear()</code>：清空字典中的所有键值对。</li><li><code>update()</code>：更新字典，将一个字典的键值对添加到另一个字典。</li></ul><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;"># 获取字典中的所有键
print(person.keys())  # 输出 dict_keys(['name', 'city'])

# 获取字典中的所有值
print(person.values())  # 输出 dict_values(['Alice', 'New York'])

# 获取字典中的所有键值对
print(person.items())  # 输出 dict_items([('name', 'Alice'), ('city', 'New York')])

# 更新字典
person.update({"age": 30, "gender": "Female"})
print(person)  # 输出 {'name': 'Alice', 'city': 'New York', 'age': 30, 'gender': 'Female'}

# 清空字典
person.clear()
print(person)  # 输出 {}
</pre><h5><a name='header-n3030' class='md-header-anchor '></a>7. <strong>字典的嵌套</strong></h5><p>字典可以嵌套其他字典或集合类型，这样可以构建更复杂的结构。</p><pre class="md-fences mock-cm md-end-block" lang=""># 字典嵌套字典
person = {
    "name": "Alice",
    "address": {
        "street": "123 Main St",
        "city": "New York"
    }
}
print(person["address"]["street"])  # 输出 '123 Main St'
</pre><hr /><h4><a name='header-n3035' class='md-header-anchor '></a>总结</h4><p>字典是一种非常灵活且常用的数据结构，适用于存储具有键值关系的数据。在 Python 中，字典的操作非常直观和便捷，可以用来处理各种数据存储和查找任务。掌握字典的基本操作对理解和编写高效的 Python 代码至关重要。</p><h3><a name='header-n3038' class='md-header-anchor '></a>6.5 模块4：jieba库的使用</h3><p><code>jieba</code> 是一个广泛使用的中文文本分词库，可以用于中文的分词、词频统计、关键词提取等任务。它在中文自然语言处理（NLP）中具有重要的地位，支持三种分词模式：精确模式、全模式和搜索引擎模式。</p><h4><a name='header-n3041' class='md-header-anchor '></a>6.5.1 jieba库概述</h4><p><code>jieba</code> 库是一款基于前缀词典的中文分词工具，它通过构建词典和使用动态规划等技术来进行高效的中文分词。使用 <code>jieba</code> 可以轻松处理中文文本的分词问题。</p><ul><li><p>支持三种模式：</p><ul><li><strong>精确模式</strong>：试图将句子最精确地切开，适用于文本分析。</li><li><strong>全模式</strong>：把句子中所有的可以成词的词语都找出，速度非常快，但无法消除歧义。</li><li><strong>搜索引擎模式</strong>：对长文本进行分词，适合用作搜索引擎分词，能提高检索召回率。</li></ul></li></ul><h4><a name='header-n3058' class='md-header-anchor '></a>6.5.2 jieba库解析</h4><h5><a name='header-n3059' class='md-header-anchor '></a>1. <strong>安装jieba库</strong></h5><p>首先，需要安装 <code>jieba</code> 库，可以通过 <code>pip</code> 来安装：</p><pre class="md-fences mock-cm md-end-block" lang="">pip install jieba
</pre><h5><a name='header-n3063' class='md-header-anchor '></a>2. <strong>基本分词操作</strong></h5><p><code>jieba</code> 提供了简单易用的分词接口。以下是几个常用方法：</p><ul><li><strong>jieba.cut()</strong>：精确模式分词，返回一个可迭代的生成器。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">import jieba

text = "我喜欢自然语言处理"
seg_list = jieba.cut(text, cut_all=False)
print("精确模式分词:", "/ ".join(seg_list))
</pre><p>输出:</p><pre class="md-fences mock-cm md-end-block" lang="">精确模式分词: 我/ 喜欢/ 自然语言处理
</pre><ul><li><strong>jieba.cut_for_search()</strong>：搜索引擎模式分词，能提高召回率。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">seg_list = jieba.cut_for_search(text)
print("搜索引擎模式分词:", "/ ".join(seg_list))
</pre><p>输出：</p><pre class="md-fences mock-cm md-end-block" lang="">搜索引擎模式分词: 我/ 喜欢/ 自然/ 语言/ 处理
</pre><ul><li><strong>jieba.lcut()</strong>：将分词结果直接返回为列表。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">seg_list = jieba.lcut(text)
print("分词结果列表:", seg_list)
</pre><p>输出：</p><pre class="md-fences mock-cm md-end-block" lang="">分词结果列表: ['我', '喜欢', '自然语言处理']
</pre><h5><a name='header-n3090' class='md-header-anchor '></a>3. <strong>自定义词典</strong></h5><p><code>jieba</code> 支持自定义词典，以便更好地识别专业词汇或一些未在原词典中出现的词汇。例如，想让 <code>jieba</code> 正确识别“自然语言处理”这个词：</p><pre class="md-fences mock-cm md-end-block" lang="">jieba.add_word("自然语言处理")
text = "我喜欢自然语言处理"
seg_list = jieba.cut(text)
print("分词结果:", "/ ".join(seg_list))
</pre><p>输出：</p><pre class="md-fences mock-cm md-end-block" lang="">分词结果: 我/ 喜欢/ 自然语言处理
</pre><h5><a name='header-n3097' class='md-header-anchor '></a>4. <strong>词频统计</strong></h5><p><code>jieba</code> 提供了 <code>jieba.analyse</code> 模块来进行关键词提取和词频统计。通过 <code>jieba.analyse.extract_tags()</code> 可以提取文本中的关键词。</p><pre class="md-fences mock-cm md-end-block" lang="">import jieba.analyse

text = "我喜欢自然语言处理，尤其是深度学习和机器学习"
tags = jieba.analyse.extract_tags(text, topK=5)
print("关键词:", tags)
</pre><p>输出：</p><pre class="md-fences mock-cm md-end-block" lang="">关键词: ['自然语言处理', '深度学习', '机器学习']
</pre><hr /><h3><a name='header-n3105' class='md-header-anchor '></a>6.6 实例10：文本词频统计</h3><h4><a name='header-n3106' class='md-header-anchor '></a>6.6.1 Hamlet英文词频统计</h4><p>在进行词频统计时，可以使用 <code>jieba</code> 库来分词并统计词语的出现频率。下面的实例展示了如何对英文文本进行词频统计。</p><p>假设我们有《哈姆雷特》的英文文本，目标是统计文本中各个单词的出现频率。</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">from collections import Counter
import jieba

# 假设有一个简单的英文文本
text = """
To be, or not to be, that is the question:
Whether 'tis nobler in the mind to suffer
The slings and arrows of outrageous fortune,
Or to take arms against a sea of troubles
And by opposing end them.
"""

# 将文本进行分词
seg_list = jieba.cut(text)

# 使用 Counter 统计词频
word_count = Counter(seg_list)

# 打印最常见的单词
print(word_count.most_common(10))
</pre><p>通过上面的代码，我们可以得到《哈姆雷特》中最常见的英文单词及其词频。你可以根据需要对英文文本进行进一步的清洗和处理，去除标点符号或停用词等。</p><h4><a name='header-n3114' class='md-header-anchor '></a>6.6.2 《三国演义》人物出场统计</h4><p>在这个实例中，我们使用 <code>jieba</code> 对《三国演义》中的人物名称进行词频统计，统计每个人物出场的次数。</p><p>假设我们有《三国演义》的文本，并且已经标记了人物的名字。下面的代码展示了如何统计每个角色的出场次数。</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">from collections import Counter
import jieba

# 假设《三国演义》人物出场文本（简化版）
text = """
刘备、关羽、张飞是桃园三结义的兄弟。刘备常常与曹操作战。关羽被称为“武圣”。张飞以勇猛著称。曹操则是三国的枭雄。
"""

# 对文本进行分词
seg_list = jieba.cut(text)

# 使用 Counter 统计人物出场频率
person_count = Counter(seg_list)

# 输出人物出场频率
for person, count in person_count.items():
    print(f"{person}: {count}")
</pre><p>输出：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">刘备: 2
、: 3
关羽: 2
张飞: 2
是: 2
桃园三结义: 1
的: 3
兄弟: 1
常常: 1
与: 1
曹操: 2
作战: 1
被称为: 1
“: 1
武圣: 1
” : 1
以: 1
勇猛: 1
著称: 1
则: 1
枭雄: 1
</pre><p>这个例子展示了如何使用 <code>jieba</code> 对文本中的人物进行统计，当然，实际的文本分析中还需要更复杂的处理，例如去除标点符号，过滤停用词等。</p><hr /><h4><a name='header-n3126' class='md-header-anchor '></a>总结</h4><p><code>jieba</code> 库是中文自然语言处理领域中非常强大的工具，适用于中文文本的分词、关键词提取以及词频统计等任务。在实际应用中，结合 <code>jieba</code> 和其他文本处理技术（如 <code>Counter</code>、<code>pandas</code> 等），可以进行更深入的文本分析，提取有价值的信息。</p><h3><a name='header-n3129' class='md-header-anchor '></a>第7章 文件和数据格式化</h3><h3><a name='header-n3130' class='md-header-anchor '></a>7.1 文件的使用</h3><p>在Python中，文件操作是一项常见的任务。无论是读取文件、写入文件，还是修改文件内容，Python都提供了非常方便的工具。文件可以是文本文件（如 <code>.txt</code>、<code>.csv</code>）或二进制文件（如 <code>.jpg</code>、<code>.exe</code>）。通过标准库中的 <code>open()</code> 函数，Python提供了对文件的读取、写入和关闭操作。</p><h4><a name='header-n3133' class='md-header-anchor '></a>7.1.1 文件概述</h4><p><strong>文件操作</strong> 是 Python 中一个非常重要的部分，文件存储了大量的数据，而读取和写入这些文件是实现数据持久化和与外部世界交互的基础。Python 提供了对文件的各种操作方法，可以处理文本文件和二进制文件。</p><p>在 Python 中，每个文件都与一个文件对象相关联。通过对文件对象的操作，我们可以执行各种文件操作，如读取、写入、追加等。文件对象通过 <code>open()</code> 函数来创建，操作完成后需要关闭文件对象。</p><h5><a name='header-n3138' class='md-header-anchor '></a>文件的类型</h5><p>Python 可以操作两种类型的文件：</p><ul><li><strong>文本文件（Text Files）</strong>：文件中的内容是以字符的形式存储的。典型的文本文件有 <code>.txt</code>、<code>.csv</code>、<code>.log</code> 等。</li><li><strong>二进制文件（Binary Files）</strong>：文件中的内容是以字节的形式存储的。典型的二进制文件有 <code>.jpg</code>、<code>.mp3</code>、<code>.pdf</code> 等。</li></ul><h5><a name='header-n3148' class='md-header-anchor '></a>文件操作的基本流程</h5><ol start='' ><li><p><strong>打开文件</strong>：</p><ul><li>使用 <code>open()</code> 函数来打开文件。</li><li><code>open()</code> 函数需要传入两个参数：文件路径和文件模式。</li></ul></li><li><p><strong>文件模式</strong>：</p><ul><li><code>r</code>：只读模式，文件指针放在文件的开头。</li><li><code>w</code>：写入模式，文件不存在则创建，存在则覆盖。</li><li><code>a</code>：追加模式，文件指针放在文件的末尾，若文件不存在，则创建新文件。</li><li><code>b</code>：二进制模式，通常与其他模式结合使用，如 <code>rb</code>（只读二进制文件）和 <code>wb</code>（写入二进制文件）。</li><li><code>x</code>：排他性创建模式，文件已存在时会引发异常。</li><li><code>t</code>：文本模式（默认），通常与其他模式结合使用，如 <code>rt</code>（读取文本文件）和 <code>wt</code>（写入文本文件）。</li></ul></li><li><p><strong>关闭文件</strong>：</p><ul><li>使用 <code>file.close()</code> 来关闭文件对象，释放系统资源。</li></ul></li></ol><h5><a name='header-n3189' class='md-header-anchor '></a>打开文件的例子</h5><ul><li><strong>打开文本文件进行读取</strong>：</li></ul><pre class="md-fences mock-cm md-end-block" lang=""># 打开文件，默认以只读模式打开
file = open('example.txt', 'r')

# 读取文件内容
content = file.read()
print(content)

# 关闭文件
file.close()
</pre><ul><li><strong>打开文本文件进行写入</strong>：</li></ul><pre class="md-fences mock-cm md-end-block" lang=""># 打开文件，若文件不存在则创建文件
file = open('output.txt', 'w')

# 写入内容
file.write("Hello, world!")

# 关闭文件
file.close()
</pre><ul><li><strong>打开文件进行追加</strong>：</li></ul><pre class="md-fences mock-cm md-end-block" lang=""># 打开文件进行追加操作
file = open('output.txt', 'a')

# 在文件末尾追加内容
file.write("\nAppended text.")

# 关闭文件
file.close()
</pre><h5><a name='header-n3205' class='md-header-anchor '></a>上下文管理器（<code>with</code> 语句）</h5><p>Python 提供了上下文管理器来简化文件的打开和关闭过程。使用 <code>with</code> 语句可以确保文件在使用完后自动关闭，无论是否发生异常，都是一种更优雅的做法。</p><pre class="md-fences mock-cm md-end-block" lang=""># 使用 with 打开文件，自动管理文件的打开与关闭
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)
# 文件会在 with 语句块结束时自动关闭
</pre><h5><a name='header-n3209' class='md-header-anchor '></a>文件的读取方法</h5><ul><li><strong>read()</strong>：读取整个文件内容。可以通过参数指定读取的字节数。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">with open('example.txt', 'r') as file:
    content = file.read(10)  # 读取前10个字符
    print(content)
</pre><ul><li><strong>readline()</strong>：逐行读取文件内容。每次调用返回文件的下一行。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">with open('example.txt', 'r') as file:
    line = file.readline()
    while line:
        print(line, end='')
        line = file.readline()
</pre><ul><li><strong>readlines()</strong>：一次性读取文件的所有行，返回一个包含每行内容的列表。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">with open('example.txt', 'r') as file:
    lines = file.readlines()
    for line in lines:
        print(line, end='')
</pre><h5><a name='header-n3225' class='md-header-anchor '></a>文件的写入方法</h5><ul><li><strong>write()</strong>：写入字符串到文件。如果文件不存在，则会创建该文件。如果文件已存在，则会覆盖原有内容。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">with open('output.txt', 'w') as file:
    file.write("Hello, world!")
</pre><ul><li><strong>writelines()</strong>：将一个可迭代对象（如列表）中的每一项写入文件。没有换行符，需要手动添加。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">lines = ['Line 1\n', 'Line 2\n', 'Line 3\n']
with open('output.txt', 'w') as file:
    file.writelines(lines)
</pre><h5><a name='header-n3236' class='md-header-anchor '></a>文件的二进制操作</h5><p>对于二进制文件（如图片、音频文件等），需要使用二进制模式（<code>rb</code> 或 <code>wb</code>）。</p><ul><li><strong>读取二进制文件</strong>：</li></ul><pre class="md-fences mock-cm md-end-block" lang="">with open('example.jpg', 'rb') as file:
    content = file.read()
    # 对二进制内容进行处理
</pre><ul><li><strong>写入二进制文件</strong>：</li></ul><pre class="md-fences mock-cm md-end-block" lang="">with open('output.jpg', 'wb') as file:
    file.write(content)
</pre><hr /><p>总结来说，Python 提供了非常简便的文件操作功能。通过 <code>open()</code> 函数打开文件，使用 <code>read()</code>、<code>write()</code> 等方法进行读取和写入操作，最后使用 <code>close()</code> 关闭文件。为了更安全和高效地进行文件操作，推荐使用 <code>with</code> 语句，它会自动帮你管理文件的打开和关闭。</p><h4><a name='header-n3252' class='md-header-anchor '></a>7.1.2 文件的打开与关闭</h4><p>在 Python 中，操作文件的第一步是打开文件，最后一步是关闭文件。打开文件时，Python 会返回一个文件对象，文件对象用于后续的文件操作。打开文件后，程序可以执行读取、写入、追加等操作。完成操作后，必须关闭文件以释放系统资源。</p><h5><a name='header-n3255' class='md-header-anchor '></a>打开文件</h5><p><code>open()</code> 函数用于打开文件，语法如下：</p><pre class="md-fences mock-cm md-end-block" lang="">file_object = open(file_name, mode)
</pre><ul><li><code>file_name</code>：要打开的文件名或路径。</li><li><code>mode</code>：文件打开模式，指定文件是用来读、写、追加、创建、二进制或文本操作。</li></ul><p>常见的文件打开模式包括：</p><ul><li><strong>r</strong>：只读模式（默认），文件必须存在。</li><li><strong>w</strong>：写入模式，如果文件存在，则覆盖文件；如果文件不存在，则创建新文件。</li><li><strong>a</strong>：追加模式，将内容写入文件的末尾。</li><li><strong>b</strong>：二进制模式，与其他模式结合使用（如 <code>rb</code> 和 <code>wb</code>）。</li><li><strong>x</strong>：排他性创建模式，文件已存在时会引发异常。</li><li><strong>t</strong>：文本模式（默认），用于文本文件。</li></ul><h5><a name='header-n3287' class='md-header-anchor '></a>示例：打开文件并读取内容</h5><pre class="md-fences mock-cm md-end-block" lang=""># 打开文件进行读取
file = open('example.txt', 'r')

# 读取文件内容
content = file.read()
print(content)

# 关闭文件
file.close()
</pre><h5><a name='header-n3289' class='md-header-anchor '></a>文件关闭</h5><p>文件操作完成后，应该关闭文件。关闭文件可以释放操作系统资源，并且确保所有缓冲区的数据都被写入到文件中。</p><p>使用 <code>close()</code> 方法来关闭文件：</p><pre class="md-fences mock-cm md-end-block" lang="">file.close()
</pre><h5><a name='header-n3295' class='md-header-anchor '></a>使用 <code>with</code> 语句自动关闭文件</h5><p>为了更安全地操作文件，避免忘记关闭文件，Python 提供了 <code>with</code> 语句。它自动处理文件的打开和关闭，即使在文件操作过程中发生异常，文件也会被正确关闭。</p><pre class="md-fences mock-cm md-end-block" lang="">with open('example.txt', 'r') as file:
    content = file.read()
    print(content)
# 文件在此处会自动关闭，不需要手动调用 file.close()
</pre><h4><a name='header-n3299' class='md-header-anchor '></a>7.1.3 文件的读写</h4><p>文件的读写操作是文件处理中的核心，Python 提供了多种方法来读取文件的内容和将数据写入文件中。</p><h5><a name='header-n3302' class='md-header-anchor '></a>文件读取操作</h5><p>在文件打开后，可以使用不同的方式读取文件内容：</p><ol start='' ><li><strong>read(size=-1)</strong>：读取整个文件的内容，返回字符串。如果指定 <code>size</code>，则读取指定字节数的内容。</li></ol><pre class="md-fences mock-cm md-end-block" lang="">with open('example.txt', 'r') as file:
    content = file.read()  # 读取整个文件内容
    print(content)
</pre><ol start='' ><li><strong>readline()</strong>：逐行读取文件，每次调用返回文件中的一行。如果到达文件末尾，返回空字符串。</li></ol><pre class="md-fences mock-cm md-end-block" lang="">with open('example.txt', 'r') as file:
    line = file.readline()  # 读取第一行
    while line:
        print(line, end='')  # 输出每一行内容
        line = file.readline()  # 继续读取下一行
</pre><ol start='' ><li><strong>readlines()</strong>：一次性读取文件中的所有行，返回一个包含每行内容的列表。</li></ol><pre class="md-fences mock-cm md-end-block" lang="">with open('example.txt', 'r') as file:
    lines = file.readlines()  # 读取所有行
    for line in lines:
        print(line, end='')  # 输出每一行内容
</pre><h4><a name='header-n3320' class='md-header-anchor '></a>文件写入操作</h4><p>写入文件时，必须指定写入模式。常见的写入模式有 <code>w</code>（写入模式）和 <code>a</code>（追加模式）。</p><ol start='' ><li><strong>write(string)</strong>：将字符串写入文件。如果文件已存在，内容会被覆盖。如果文件不存在，则会创建文件。</li></ol><pre class="md-fences mock-cm md-end-block" lang="">with open('output.txt', 'w') as file:
    file.write("Hello, world!")  # 将字符串写入文件
</pre><ol start='' ><li><strong>writelines(lines)</strong>：将一个可迭代对象（如列表或元组）中的每一项写入文件。此方法不会自动加上换行符，需要手动在字符串中添加。</li></ol><pre class="md-fences mock-cm md-end-block" lang="">lines = ["Line 1\n", "Line 2\n", "Line 3\n"]
with open('output.txt', 'w') as file:
    file.writelines(lines)  # 将列表中的每一项写入文件
</pre><h4><a name='header-n3333' class='md-header-anchor '></a>追加写入</h4><p>如果想将新内容添加到文件的末尾而不是覆盖文件，可以使用 <code>a</code> 模式（追加模式）：</p><pre class="md-fences mock-cm md-end-block" lang="">with open('output.txt', 'a') as file:
    file.write("\nThis is new content.")  # 内容追加到文件末尾
</pre><h4><a name='header-n3337' class='md-header-anchor '></a>二进制文件的读写</h4><p>对于二进制文件（如图片、音频等），需要以二进制模式打开文件。二进制文件的读取和写入与文本文件类似，但需要加上 <code>b</code> 标志。</p><ol start='' ><li><strong>读取二进制文件</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">with open('example.jpg', 'rb') as file:
    content = file.read()  # 以二进制方式读取文件
    # 对二进制内容进行处理
</pre><ol start='' ><li><strong>写入二进制文件</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">with open('output.jpg', 'wb') as file:
    file.write(content)  # 将二进制数据写入文件
</pre><h4><a name='header-n3350' class='md-header-anchor '></a>总结</h4><ul><li><strong>打开文件</strong>：使用 <code>open()</code> 函数并指定模式。</li><li><strong>读取文件</strong>：使用 <code>read()</code>、<code>readline()</code> 或 <code>readlines()</code> 方法。</li><li><strong>写入文件</strong>：使用 <code>write()</code> 或 <code>writelines()</code> 方法。</li><li><strong>关闭文件</strong>：使用 <code>close()</code> 方法或使用 <code>with</code> 语句自动管理文件关闭。</li><li><strong>二进制文件</strong>：使用 <code>rb</code> 或 <code>wb</code> 模式进行二进制文件的读取和写入。</li></ul><p>通过以上操作，Python 能够有效地读取和写入各种类型的文件，包括文本文件和二进制文件。</p></div>
</body>
</html>