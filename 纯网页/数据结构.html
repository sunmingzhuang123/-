<!doctype html>
<html>
<head>
  
        <style>
        .watermark {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            background-repeat: repeat;
            /* background-image: linear-gradient(45deg, rgba(0, 0, 0, 0.1) 0%, rgba(0, 0, 0, 0.1) 100%); */
        }
        
        .watermark::after {
            content: "菏泽学院 23物联网工程 QQ365938188";
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-45deg);
            font-size: 24px;
            color: rgba(0, 0, 0, 0.1);
            white-space: nowrap;
            letter-spacing: 5px;
        }
        </style>
        
       
        <div class="watermark"></div>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>数据结构.md</title><link href='https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}#write, body { height: auto; }
#write, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write ol, #write p, #write ul { position: relative; }
#write, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
.CodeMirror, .md-fences, table { text-align: left; }
.md-reset, a:active, a:hover { outline: 0px; }
.md-reset, .md-toc-item a { text-decoration: none; }
.MathJax_SVG, .md-reset { float: none; direction: ltr; }
:root { --bg-color:#ffffff; --text-color:#333333; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; }
.in-text-selection, ::selection { background: rgb(181, 214, 252); text-shadow: none; }
#write { margin: 0px auto; word-break: normal; word-wrap: break-word; padding-bottom: 70px; white-space: pre-wrap; overflow-x: visible; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
.typora-export #write { margin: 0px auto; }
#write > blockquote:first-child, #write > div:first-child, #write > ol:first-child, #write > p:first-child, #write > pre:first-child, #write > table:first-child, #write > ul:first-child { margin-top: 30px; }
#write li > table:first-child { margin-top: -20px; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
p { -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; }
.typora-export p { white-space: normal; }
.mathjax-block { margin-top: 0px; margin-bottom: 0px; -webkit-margin-before: 0px; -webkit-margin-after: 0px; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
#write > figure:first-child { margin-top: 16px; }
figure { overflow-x: auto; margin: -8px 0px 0px -8px; max-width: calc(100% + 16px); padding: 8px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; }
.CodeMirror-line, .md-fences { break-inside: avoid; }
table.md-table td { min-width: 80px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; margin-right: 4px; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
pre { white-space: pre-wrap; }
.md-fences { font-size: 0.9rem; display: block; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
.md-fences .CodeMirror.CodeMirror-wrap { top: -1.6em; margin-bottom: -1.6em; }
.md-fences.mock-cm { white-space: pre-wrap; }
.show-fences-line-number .md-fences { padding-left: 0px; }
.show-fences-line-number .md-fences.mock-cm { padding-left: 40px; }
.footnotes { opacity: 0.8; font-size: 0.9rem; padding-top: 1em; padding-bottom: 1em; }
.footnotes + .footnotes { margin-top: -1em; }
.md-reset { margin: 0px; padding: 0px; border: 0px; vertical-align: top; background: 0px 0px; text-shadow: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; }
.md-toc-inner, a img, img a { cursor: pointer; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: nowrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  h1, h2, h3, h4, h5, h6 { break-after: avoid-page; orphans: 2; }
  p { orphans: 4; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 1cm; padding-right: 1cm; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > img:only-child { display: block; margin: auto; }
.md-line > .md-image:only-child, p > .md-image:only-child { display: inline-block; width: 100%; text-align: center; }
.mathjax-block:not(:empty)::after, .md-toc-content::after, .md-toc::after { display: none; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.mathjax-block { white-space: pre; overflow: hidden; width: 100%; }
p + .mathjax-block { margin-top: -1.143rem; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.MathJax_SVG, .mathjax-block .MathJax_SVG_Display { text-indent: 0px; max-width: none; max-height: none; min-height: 0px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-inner:hover { }
.md-toc-inner { display: inline-block; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
.md-tag { opacity: 0.5; }
code, pre, tt { font-family: var(--monospace); }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; }
h1 .md-tag, h2 .md-tag, h3 .md-tag, h4 .md-tag, h5 .md-tag, h6 .md-tag { font-weight: initial; opacity: 0.35; }
a.md-print-anchor { border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.mathjax-block .MathJax_SVG_Display { text-align: center; margin: 1em 0px; position: relative; min-width: 100%; width: auto; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: monospace; }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; min-width: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.md-diagram-panel > svg, [lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }


.CodeMirror, .CodeMirror-sizer { position: relative; }
.CodeMirror.cm-s-inner { background: inherit; }
.fences-no-line-wrapping .md-fences .CodeMirror { margin-top: -30px; }
.CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; }
.CodeMirror-lines { padding: 4px 0px; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-scroll, .cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta, .cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error, .cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.CodeMirror { height: auto; overflow: hidden; }
.CodeMirror-scroll { margin-bottom: -30px; padding-bottom: 30px; height: 100%; outline: 0px; position: relative; box-sizing: content-box; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow-x: hidden; overflow-y: scroll; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow-y: hidden; overflow-x: scroll; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; border-right: none; width: 0px; visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.CodeMirror-selected { background: rgb(217, 217, 217); }
.CodeMirror-focused .CodeMirror-selected { background: rgb(215, 212, 240); }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}
.CodeMirror-lint-markers { width: 16px; }
.CodeMirror-lint-tooltip { background-color: infobackground; border: 1px solid rgb(0, 0, 0); border-radius: 4px; color: infotext; font-family: var(--monospace); overflow: hidden; padding: 2px 5px; position: fixed; white-space: pre-wrap; z-index: 10000; max-width: 600px; opacity: 0; transition: opacity 0.4s; font-size: 0.8em; }
.CodeMirror-lint-mark-error, .CodeMirror-lint-mark-warning { background-position: left bottom; background-repeat: repeat-x; }
.CodeMirror-lint-mark-error { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg=="); }
.CodeMirror-lint-marker-error, .CodeMirror-lint-marker-warning { background-position: center center; background-repeat: no-repeat; cursor: pointer; display: inline-block; height: 16px; width: 16px; vertical-align: middle; position: relative; }
.CodeMirror-lint-message-error, .CodeMirror-lint-message-warning { padding-left: 18px; background-position: left top; background-repeat: no-repeat; }
.CodeMirror-lint-marker-error, .CodeMirror-lint-message-error { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII="); }
.CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII="); }
.CodeMirror-lint-marker-multiple { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC"); background-repeat: no-repeat; background-position: right bottom; width: 100%; height: 100%; }


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
@font-face { font-family: "Open Sans"; font-style: normal; font-weight: normal; src: local("Open Sans Regular"), url("./github/400.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: italic; font-weight: normal; src: local("Open Sans Italic"), url("./github/400i.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: normal; font-weight: bold; src: local("Open Sans Bold"), url("./github/700.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: italic; font-weight: bold; src: local("Open Sans Bold Italic"), url("./github/700i.woff") format("woff"); }
html { font-size: 16px; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 20px 30px 100px; }
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
body > :first-child { margin-top: 0px !important; }
body > :last-child { margin-bottom: 0px !important; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 4px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border-width: 0px 0px 1px; border-style: none none solid; border-top-color: initial; border-right-color: initial; border-left-color: initial; border-image: initial; overflow: hidden; box-sizing: content-box; border-bottom-color: rgb(221, 221, 221); }
body > h2:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child + h2 { margin-top: 0px; padding-top: 0px; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child { margin-top: 0px; padding-top: 0px; }
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0px; padding-top: 0px; }
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p { margin-top: 0px; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 4px solid rgb(221, 221, 221); padding: 0px 15px; color: rgb(119, 119, 119); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border-top: 1px solid rgb(204, 204, 204); margin: 0px; padding: 0px; }
table tr:nth-child(2n) { background-color: rgb(248, 248, 248); }
table tr th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; text-align: left; margin: 0px; padding: 6px 13px; }
table tr td { border: 1px solid rgb(204, 204, 204); text-align: left; margin: 0px; padding: 6px 13px; }
table tr th:first-child, table tr td:first-child { margin-top: 0px; }
table tr th:last-child, table tr td:last-child { margin-bottom: 0px; }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); }
.md-fences, code, tt { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding: 8px 1em 6px; }
.md-task-list-item > input { margin-left: -1.3em; }
@media screen and (min-width: 914px) {
}
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; color: inherit; }
.md-tag { color: inherit; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
#md-notification::before { top: 10px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }
.html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; }






</style>
</head>
<body class='typora-export' >
<div  id='write'  class = 'is-node'><h1><a name='header-n0' class='md-header-anchor '></a>数据结构</h1><h6><a name='header-n2' class='md-header-anchor '></a>23物联网工程  2023124306</h6><h2><a name='header-n3' class='md-header-anchor '></a>第 1 章 绪论</h2><h3><a name='header-n4' class='md-header-anchor '></a>1.1 数据结构的研究内容</h3><p>数据结构是计算机科学中非常核心的内容之一，研究的是如何在计算机中组织、存储和管理数据。其核心目的是确保数据的高效访问与操作，主要包括以下几个方面：</p><ul><li><strong>数据的组织方式</strong>：数据结构定义了数据元素的存储方式以及它们之间的关系。例如，数组、链表、树、图等都是不同的数据结构，它们适应不同的应用场景。</li><li><strong>数据的操作方式</strong>：数据结构不仅仅是存储数据的容器，还是执行各种操作的基础，如插入、删除、查找、排序等操作。</li><li><strong>算法的实现</strong>：数据结构与算法密切相关，良好的数据结构设计能够让算法实现更高效。不同的操作需要选择不同的数据结构来实现，比如查找操作常用的结构有数组、链表、哈希表、二叉搜索树等。</li></ul><p>研究数据结构不仅关注数据的存储，还涉及如何利用数据结构来优化程序的执行效率。因此，数据结构是理解和解决计算机科学各类问题的基础。</p><h3><a name='header-n19' class='md-header-anchor '></a>1.2 数据结构的基本概念和术语</h3><p>在学习数据结构时，首先要掌握一些基础的概念和术语。这些基本概念为后续深入学习提供了重要的理论基础。</p><h4><a name='header-n22' class='md-header-anchor '></a>1.2.1 数据、数据元素、数据项和数据对象</h4><ul><li><strong>数据</strong>：是指一切可以被计算机处理的信息。数据不仅仅限于数字，还可以包括文字、图像、声音等信息。</li><li><strong>数据元素</strong>：是数据的最基本单位，表示一项具体的、不可再分的数据。例如，在一个学生信息表中，学生的姓名、年龄、学号等都可以看作数据元素。</li><li><strong>数据项</strong>：是数据元素的具体内容。在上述例子中，数据项包括学生的姓名“张三”、年龄“20”、学号“202101”。</li><li><strong>数据对象</strong>：是由若干数据元素按照一定的逻辑关系组合起来的整体。比如，学生信息表就是一个数据对象，它包含多个数据元素（如姓名、年龄、学号等）。</li></ul><p>这些术语帮助我们理解数据如何在计算机中表达和管理。数据对象可以看作是对数据元素的组织，它们之间通过一定的关系被关联起来。</p><h4><a name='header-n38' class='md-header-anchor '></a>1.2.2 数据结构</h4><p>数据结构是指计算机中存储、组织数据的方式。它是数据元素的集合，并且这些元素之间有特定的逻辑关系。常见的数据结构有线性数据结构和非线性数据结构两大类：</p><ul><li><p><strong>线性数据结构</strong>：每个元素有且只有一个前驱和一个后继元素，通常表示为线性序列。典型的线性数据结构有：</p><ul><li><strong>数组</strong>：一组连续的存储空间，用于存储相同类型的数据元素，支持通过索引快速访问。</li><li><strong>链表</strong>：由一系列节点组成，每个节点包含数据元素和指向下一个节点的指针，支持高效的插入和删除操作。</li><li><strong>栈</strong>：遵循后进先出（LIFO）原则的线性结构。</li><li><strong>队列</strong>：遵循先进先出（FIFO）原则的线性结构。</li></ul></li><li><p><strong>非线性数据结构</strong>：数据元素之间不呈线性关系。典型的非线性数据结构有：</p><ul><li><strong>树</strong>：由节点和边组成的结构，节点有一个父节点和零个或多个子节点。常见的树结构有二叉树、平衡树、堆等。</li><li><strong>图</strong>：由一组节点和连接节点的边组成，图中的边不一定具有方向，通常用于表示复杂关系。</li></ul></li></ul><p>数据结构的选择直接影响程序的执行效率和资源使用，因此需要根据具体应用的需求来选择合适的数据结构。</p><h4><a name='header-n70' class='md-header-anchor '></a>1.2.3 数据类型和抽象数据类型</h4><ul><li><p><strong>数据类型</strong>：是指一组具有相同性质的值的集合以及在这些值上定义的操作。数据类型可以分为<strong>基本数据类型</strong>和<strong>用户定义数据类型</strong>。</p><ul><li><strong>基本数据类型</strong>：如整型、浮点型、字符型、布尔型等，这些数据类型直接由编程语言提供。</li><li><strong>用户定义数据类型</strong>：由程序员根据实际需求定义的数据类型，如结构体、类等。</li></ul></li><li><p><strong>抽象数据类型（ADT）</strong>：抽象数据类型是数据结构的抽象表示，它定义了数据对象的操作接口，而不关心其具体实现。ADT关注的是如何进行数据操作，而非具体的实现细节。例如，栈、队列、列表等都可以看作抽象数据类型，它们通过一组操作（如入栈、出栈、插入、删除等）定义了数据的行为，但具体的存储方式可以是数组、链表或其他结构。</p></li></ul><p>抽象数据类型的概念有助于程序设计的模块化和代码复用，通过抽象出数据的操作接口，可以让代码更具可维护性和扩展性。</p><hr /><h3><a name='header-n88' class='md-header-anchor '></a>1.3 抽象数据类型的表示与实现</h3><p>抽象数据类型（Abstract Data Type, ADT）是数据结构的核心概念之一。它定义了一种数据模型以及在该模型上可以执行的操作，而不涉及具体实现的细节。具体而言，ADT包含数据和对数据的操作，而这些操作会封装在接口中。</p><h4><a name='header-n91' class='md-header-anchor '></a>抽象数据类型的表示</h4><p>抽象数据类型的表示通常有两种方式：</p><ol start='' ><li><p><strong>数学模型表示法</strong>：</p><ul><li><p>通过集合和操作的数学定义来表示ADT。例如，栈（Stack）可以表示为一个具有特定操作的集合：</p><ul><li><p>操作</p><p>：</p><ul><li><code>push(x)</code>：将元素x推入栈顶。</li><li><code>pop()</code>：移除栈顶元素。</li><li><code>top()</code>：返回栈顶元素但不移除它。</li><li><code>isEmpty()</code>：检查栈是否为空。</li></ul></li></ul></li></ul><p>在数学模型中，我们主要关心数据的性质和操作，而不关注数据如何存储。</p></li><li><p><strong>程序实现表示法</strong>：</p><ul><li>通过编程语言实现ADT。一般使用类（class）、接口（interface）等结构来封装数据和操作。例如，栈可以通过数组或链表来实现，但无论实现细节如何，栈的操作接口保持不变。这种方式关注的是如何实现这些操作的效率和细节。</li></ul></li></ol><h4><a name='header-n130' class='md-header-anchor '></a>抽象数据类型的实现</h4><p>ADT的实现方式通常依赖于具体的数据结构。比如：</p><ul><li><p>栈的实现</p><p>：可以通过数组、链表或者动态数组等结构来实现。</p><ul><li>使用<strong>数组</strong>时，栈的<code>push</code>和<code>pop</code>操作的时间复杂度为O(1)，但栈的容量固定，可能会出现溢出问题。</li><li>使用<strong>链表</strong>时，栈可以动态扩展，避免了溢出问题，但是<code>push</code>和<code>pop</code>操作仍为O(1)。</li></ul></li></ul><p>通过接口和实现分离的方式，ADT的使用者可以依赖于抽象的操作，而不需要关心具体实现的细节。</p><h3><a name='header-n148' class='md-header-anchor '></a>1.4 算法和算法分析</h3><p>在数据结构的研究中，算法的设计与分析同样重要。算法是用于解决问题的一组步骤，而算法分析则帮助我们理解和优化这些步骤的效率。</p><h4><a name='header-n151' class='md-header-anchor '></a>1.4.1 算法的定义及特性</h4><ul><li><p>算法的定义</p><p>：算法是为解决某个特定问题而设计的、有限的、明确的步骤集合。它应当具有以下特性：</p><ul><li><strong>输入</strong>：算法有零个或多个输入数据。</li><li><strong>输出</strong>：算法有一个或多个输出结果。</li><li><strong>确定性</strong>：算法的每一步都必须是明确的，不能存在歧义。</li><li><strong>有限性</strong>：算法必须在有限的时间内终止，不得进入无限循环。</li><li><strong>可行性</strong>：算法中的每个步骤都应该是可执行的。</li></ul></li></ul><p>一个好的算法不仅能够正确解决问题，还需要考虑它的执行效率，即时间复杂度和空间复杂度。</p><h4><a name='header-n176' class='md-header-anchor '></a>1.4.2 评价算法优劣的基本标准</h4><p>评价算法优劣的标准主要包括以下几个方面：</p><ul><li><strong>时间复杂度</strong>：衡量算法执行所需时间随输入规模增长的变化情况。通常用“大O符号”（如O(n)）来表示。</li><li><strong>空间复杂度</strong>：衡量算法执行过程中所需的内存空间随输入规模增长的变化情况。空间复杂度与时间复杂度密切相关，但关注的是内存使用。</li><li><strong>可维护性</strong>：一个好的算法应当易于理解和维护。代码应清晰、简洁，避免不必要的复杂性。</li><li><strong>稳定性</strong>：在处理输入数据中存在重复元素时，稳定算法能够保持相同元素的相对顺序。</li><li><strong>适应性</strong>：适应性强的算法能够处理多种不同规模和类型的输入数据。</li><li><strong>可扩展性</strong>：随着问题规模的增大，算法是否能够保持良好的性能表现。</li></ul><h4><a name='header-n198' class='md-header-anchor '></a>1.4.3 算法的时间复杂度</h4><p>时间复杂度是用来描述一个算法执行所需时间随输入规模（n）变化的规律。它是评估算法效率的一个重要指标。</p><ul><li><strong>常数时间复杂度</strong> O(1)：表示算法的执行时间不随输入规模的增加而变化。例如，访问数组中的一个元素。</li><li><strong>线性时间复杂度</strong> O(n)：表示算法的执行时间与输入规模成正比。例如，遍历一个数组。</li><li><strong>平方时间复杂度</strong> O(n²)：表示算法的执行时间与输入规模的平方成正比。例如，冒泡排序。</li><li><strong>对数时间复杂度</strong> O(log n)：表示算法的执行时间随着输入规模的增长呈对数增长。例如，二分查找。</li><li><strong>线性对数时间复杂度</strong> O(n log n)：常见于高效排序算法，如归并排序和快速排序。</li></ul><p>时间复杂度不仅关心最坏情况，还常常需要分析平均时间复杂度，以确保算法在一般情况下的性能。</p><h4><a name='header-n219' class='md-header-anchor '></a>1.4.4 算法的空间复杂度</h4><p>空间复杂度是用来描述一个算法在执行过程中所需的内存空间随着输入规模的变化而变化的规律。它与时间复杂度类似，但关注的是内存的消耗。</p><ul><li><strong>常数空间复杂度</strong> O(1)：表示算法所需的内存空间不随输入规模的变化而变化。例如，使用固定大小的变量。</li><li><strong>线性空间复杂度</strong> O(n)：表示算法的内存空间需求与输入规模成正比。例如，创建一个大小为n的数组来存储输入数据。</li></ul><p>在设计算法时，不仅要考虑时间复杂度，还需要考虑空间复杂度。在一些内存受限的环境中，空间复杂度可能比时间复杂度更重要。</p><hr /><h3><a name='header-n232' class='md-header-anchor '></a>第 2 章 线性表</h3><p>线性表是数据结构中最基础和最常见的一种类型。它是一种数据元素的集合，满足“线性”结构的要求，即每个元素都与前一个和后一个元素具有确定的顺序关系。在线性表中，元素的插入、删除、查找操作通常依赖于元素的顺序或位置。</p><h4><a name='header-n235' class='md-header-anchor '></a>2.1 线性表的定义和特点</h4><p><strong>线性表的定义</strong>：线性表（Linear List）是由若干数据元素按线性顺序排列构成的集合。在这个集合中，每个元素（除第一个元素外）都有唯一的前驱元素，每个元素（除最后一个元素外）都有唯一的后继元素。</p><p>线性表的常见实现方式包括<strong>顺序存储结构</strong>（通常使用数组）和<strong>链式存储结构</strong>（通常使用链表）。</p><p><strong>线性表的特点</strong>：</p><ol start='' ><li><p><strong>顺序性</strong>：线性表中的元素是有顺序的。每个元素都有明确的位置关系，一个元素仅有一个前驱和后继元素。</p></li><li><p><strong>插入与删除</strong>：</p><ul><li>在顺序存储结构中，插入和删除操作可能需要移动大量元素，尤其是在数组的中间部分插入或删除时，操作复杂度较高。</li><li>在链式存储结构中，插入和删除操作相对灵活，尤其是在表头或表尾进行操作时，复杂度通常为O(1)。</li></ul></li><li><p><strong>访问性</strong>：线性表支持按序号访问元素。对于顺序存储结构，访问元素的时间复杂度是O(1)，通过索引直接访问；而链式存储结构需要从头开始遍历，访问一个特定元素的时间复杂度是O(n)。</p></li><li><p><strong>结构灵活性</strong>：线性表既可以是静态的（如数组），也可以是动态的（如链表）。顺序存储结构的大小在创建时固定，而链式存储结构可以根据需要动态扩展或收缩。</p></li><li><p><strong>支持顺序操作</strong>：对线性表可以进行的基本操作包括：插入、删除、查找、修改、遍历等，这些操作大多是基于元素的顺序位置来执行。</p></li></ol><h4><a name='header-n265' class='md-header-anchor '></a>2.2 案例引入</h4><p><strong>案例：学生成绩管理系统中的线性表</strong></p><p>假设我们需要设计一个学生成绩管理系统，系统中需要记录学生的成绩信息，并能进行如下操作：</p><ul><li>查询某个学生的成绩。</li><li>按照成绩排序（升序或降序）。</li><li>插入新的成绩数据。</li><li>删除某个学生的成绩。</li></ul><p>在这个系统中，我们可以将每个学生的成绩表示为线性表。每个元素包含学生的姓名和成绩信息。线性表可以帮助我们高效地进行查询、插入和删除操作。</p><ol start='' ><li><strong>查询操作</strong>：使用顺序存储结构（如数组），可以根据学生的索引位置快速查询成绩。若采用链表结构，也可以进行查找，但需要遍历链表来找到对应节点。</li><li><strong>排序操作</strong>：如果学生成绩存储在一个线性表中，我们可以使用排序算法（如冒泡排序、快速排序等）对其进行排序。</li><li><strong>插入和删除操作</strong>：对于顺序存储结构，插入和删除操作可能需要移动元素，而对于链表，只需要改变指针即可完成插入和删除，效率较高。</li></ol><p>这个案例帮助我们理解线性表在实际应用中的作用，并让我们能根据需求选择合适的存储结构。</p><h4><a name='header-n297' class='md-header-anchor '></a>2.3 线性表的类型定义</h4><p>线性表有多种类型，常见的类型包括：<strong>顺序表</strong>（Array List）和<strong>链表</strong>（Linked List）。这两种类型的线性表在内存布局和操作效率上有所不同。</p><ol start='' ><li><p><strong>顺序表</strong>：顺序表是线性表的一种实现方式，它使用一段连续的内存空间来存储元素。在顺序表中，每个元素通过下标进行访问，具有高效的随机访问能力。</p><ul><li><p>优点</p><p>：</p><ul><li>支持O(1)时间复杂度的访问操作，能够通过索引快速访问元素。</li><li>空间利用率高（在不发生动态扩展的情况下），适合存储大小已知且变化不大的数据。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>插入和删除操作的时间复杂度为O(n)，因为在数组中间插入或删除元素时，需要移动其他元素。</li><li>如果数组的大小固定，则无法动态增长或缩小，可能会浪费空间或造成内存溢出。</li></ul></li></ul></li><li><p><strong>链表</strong>：链表是一种通过指针将多个数据元素连接起来的线性结构。链表的每个元素包含两个部分：数据域（存储数据）和指针域（指向下一个元素）。链表的长度可以动态变化，因此适合用于需要频繁插入和删除操作的场景。</p><ul><li><p>优点</p><p>：</p><ul><li>插入和删除操作非常高效，尤其是在表头或表尾进行操作时，时间复杂度为O(1)。</li><li>动态内存分配，适用于数据量不固定或变化频繁的情况。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>访问元素的时间复杂度为O(n)，因为需要从头结点开始遍历，无法实现快速的随机访问。</li><li>每个元素都需要额外的存储空间来存储指针，因此比顺序表浪费更多的内存。</li></ul></li></ul></li><li><p><strong>其他类型的线性表</strong>：除了顺序表和链表，还有一些其他类型的线性表，例如：</p><ul><li><strong>静态链表</strong>：将链表的指针域存储在一个数组中，解决了动态内存分配的问题，但插入和删除操作仍然保持O(1)。</li><li><strong>循环链表</strong>：链表的最后一个元素的指针指向第一个元素，形成一个闭环，适用于某些需要循环访问的场景。</li></ul></li></ol><hr /><h3><a name='header-n368' class='md-header-anchor '></a>2.4 线性表的顺序表示和实现</h3><p>线性表的顺序表示是一种基于数组的实现方式，它通过一段连续的内存空间来存储线性表中的元素。顺序表中的元素按顺序排列，每个元素可以通过索引直接访问。顺序表示的优点是具有快速的随机访问能力，但也存在一些限制，如插入和删除操作的效率较低。</p><h4><a name='header-n371' class='md-header-anchor '></a>2.4.1 线性表的顺序表示</h4><p>在顺序表示中，线性表中的每个元素依次存储在一个数组中，数组的索引就是元素的位置。假设我们有一个长度为n的线性表，它的顺序表示可以通过一个大小为n的数组来实现：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int arr[n]; // 数组arr用于存储n个元素</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><p>每个数组元素对应线性表中的一个数据元素。顺序表示的线性表有以下特点：</p><ul><li><strong>支持随机访问</strong>：通过下标可以直接访问任意元素，访问时间为O(1)。</li><li><strong>连续存储</strong>：数组中元素的存储位置是连续的，这使得顺序表的内存布局非常紧凑。</li><li><strong>固定大小</strong>：顺序表在创建时必须确定大小，一旦创建，大小不可改变（除非使用动态数组）。</li><li><strong>插入和删除效率低</strong>：在数组的中间插入或删除元素时，需要移动大量元素，时间复杂度为O(n)。</li></ul><p>顺序表示的线性表的基本结构通常包含以下两个要素：</p><ol start='' ><li><strong>数组</strong>：用于存储线性表的元素。</li><li><strong>长度</strong>：记录线性表当前的元素个数。</li></ol><p>例如，定义一个存储整数的顺序表结构：</p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class SeqList {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">private:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int* arr;  // 动态数组</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int length; // 当前元素个数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int capacity; // 数组容量</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  SeqList(int size) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  arr = new int[size];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  length = 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  capacity = size;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  ~SeqList() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  delete[] arr;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 其他操作...</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 445px;"></div><div class="CodeMirror-gutters" style="display: none; height: 475px;"></div></div></div></pre><h4><a name='header-n402' class='md-header-anchor '></a>2.4.2 顺序表中基本操作的实现</h4><p>顺序表中常见的基本操作包括：插入元素、删除元素、查找元素、修改元素、遍历等。下面我们将通过C++代码展示这些基本操作的实现。</p><h5><a name='header-n405' class='md-header-anchor '></a>1. 插入操作</h5><p>插入操作是将一个新元素插入到顺序表中的某个位置。插入时需要考虑以下几种情况：</p><ul><li>如果插入位置在表尾，只需要直接将元素插入。</li><li>如果插入位置在表中间，需要移动元素以腾出空间。</li></ul><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 插入操作</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void insert(int position, int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  if (position &lt; 0 || position &gt; length) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  if (length == capacity) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Sequence List is full!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 从后往前移动元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = length - 1; i &gt;= position; --i) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  arr[i + 1] = arr[i];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  arr[position] = value; // 插入新元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  length++; // 更新长度</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 468px;"></div><div class="CodeMirror-gutters" style="display: none; height: 498px;"></div></div></div></pre><ul><li><strong>时间复杂度</strong>：O(n)，最坏情况下需要移动所有元素。</li></ul><h5><a name='header-n420' class='md-header-anchor '></a>2. 删除操作</h5><p>删除操作是将顺序表中指定位置的元素删除。删除时需要考虑以下几种情况：</p><ul><li>删除元素后，表中其后的元素需要向前移动，填补空缺位置。</li></ul><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 删除操作</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void remove(int position) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  if (position &lt; 0 || position &gt;= length) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 从当前位置开始，元素依次向前移动</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = position; i &lt; length - 1; ++i) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  arr[i] = arr[i + 1];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  length--; // 更新长度</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 330px;"></div><div class="CodeMirror-gutters" style="display: none; height: 360px;"></div></div></div></pre><ul><li><strong>时间复杂度</strong>：O(n)，最坏情况下需要移动所有元素。</li></ul><h5><a name='header-n432' class='md-header-anchor '></a>3. 查找操作</h5><p>查找操作是根据值或者位置找到顺序表中的元素。根据需求可以是按值查找或按位置查找。</p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 按位置查找</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int get(int position) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  if (position &lt; 0 || position &gt;= length) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return -1;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return arr[position];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 按值查找</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int find(int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; length; ++i) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (arr[i] == value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return i; // 返回值所在位置</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return -1; // 未找到</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 422px;"></div><div class="CodeMirror-gutters" style="display: none; height: 452px;"></div></div></div></pre><ul><li><strong>时间复杂度</strong>：查找操作的时间复杂度为O(n)，最坏情况下需要遍历整个数组。</li></ul><h5><a name='header-n440' class='md-header-anchor '></a>4. 修改操作</h5><p>修改操作是根据位置修改顺序表中指定位置的元素。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 修改操作</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void modify(int position, int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  if (position &lt; 0 || position &gt;= length) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  arr[position] = value;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 215px;"></div><div class="CodeMirror-gutters" style="display: none; height: 245px;"></div></div></div></pre><ul><li><strong>时间复杂度</strong>：O(1)，只需要直接访问并修改指定位置的元素。</li></ul><h5><a name='header-n448' class='md-header-anchor '></a>5. 遍历操作</h5><p>遍历操作是依次访问顺序表中的每个元素，常用于打印输出。</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 遍历操作</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void print() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; length; ++i) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; arr[i] &lt;&lt; " ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 169px;"></div><div class="CodeMirror-gutters" style="display: none; height: 199px;"></div></div></div></pre><ul><li><strong>时间复杂度</strong>：O(n)，需要遍历整个数组。</li></ul><h3><a name='header-n456' class='md-header-anchor '></a>完整代码示例</h3><p>以下是顺序表的完整实现，包括插入、删除、查找、修改和遍历操作：</p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;iostream&gt;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">using namespace std;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class SeqList {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">private:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int* arr;  // 动态数组</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int length; // 当前元素个数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int capacity; // 数组容量</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 构造函数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  SeqList(int size) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  arr = new int[size];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  length = 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  capacity = size;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 析构函数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  ~SeqList() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  delete[] arr;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 插入操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void insert(int position, int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (position &lt; 0 || position &gt; length) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (length == capacity) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Sequence List is full!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  for (int i = length - 1; i &gt;= position; --i) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  arr[i + 1] = arr[i];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  arr[position] = value;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  length++;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 删除操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void remove(int position) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (position &lt; 0 || position &gt;= length) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  for (int i = position; i &lt; length - 1; ++i) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  arr[i] = arr[i + 1];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  length--;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 查找操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int get(int position) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (position &lt; 0 || position &gt;= length) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return -1;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return arr[position];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int find(int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  for (int i = 0; i &lt; length; ++i) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (arr[i] == value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return i;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return -1;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 修改操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void modify(int position, int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (position &lt; 0 || position &gt;= length) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  arr[position] = value;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 遍历操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void print() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  for (int i = 0; i &lt; length; ++i) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; arr[i] &lt;&lt; " ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  SeqList list(10);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 插入操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.insert(0, 10);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.insert(1, 20);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.insert(2, 30);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.print(); // 输出: 10 20 30</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 删除操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.remove(1);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.print(); // 输出: 10 30</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 查找操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "Index of 30: " &lt;&lt; list.find(30) &lt;&lt; endl; // 输出: 1</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 修改操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.modify(0, 50);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.print(); // 输出: 50 30</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 2653px;"></div><div class="CodeMirror-gutters" style="display: none; height: 2683px;"></div></div></div></pre><h3><a name='header-n460' class='md-header-anchor '></a>总结</h3><ul><li><strong>顺序表的优点</strong>：支持快速的随机访问，结构简单。</li><li><strong>顺序表的缺点</strong>：插入和删除操作的效率较低，尤其是在中间位置进行操作时需要移动大量元素。</li><li><strong>适用场景</strong>：当数据量不大且插入和删除</li></ul><h3><a name='header-n471' class='md-header-anchor '></a>2.4 线性表的顺序表示和实现</h3><p>线性表的顺序表示是指使用一段连续的内存空间来存储线性表的元素。顺序表示方法使得线性表的每个元素都可以通过下标进行直接访问，能够高效地进行查找和修改操作。然而，插入和删除操作可能需要移动元素，尤其是在中间位置插入或删除时，性能较差。</p><h4><a name='header-n474' class='md-header-anchor '></a>2.4.1 线性表的顺序表示</h4><p>顺序表（Sequence List）是线性表的顺序存储结构，其基本思想是用一段连续的内存空间来存储元素，通常使用数组来实现。顺序表的每个元素通过索引（下标）进行访问，支持高效的随机访问。</p><p>顺序表的优缺点：</p><ul><li><p>优点</p><p>：</p><ul><li>支持O(1)时间复杂度的随机访问，能够快速定位和操作元素。</li><li>内存连续存储，空间利用率高，访问速度快。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>插入和删除操作需要移动元素，尤其是在表的中间进行插入或删除时，时间复杂度为O(n)。</li><li>如果表的大小固定，且元素超过最大容量时，会导致溢出，需要重新分配内存空间。</li></ul></li></ul><p>顺序表的结构如下图所示：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">| Element 1 | Element 2 | Element 3 | ... | Element n |</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><p>每个元素的位置通过索引来确定，索引从0到n-1。</p><p><strong>顺序表的常见操作</strong>：</p><ul><li><strong>插入</strong>：在指定位置插入元素，通常需要移动插入位置之后的元素。</li><li><strong>删除</strong>：删除指定位置的元素，通常需要移动删除位置之后的元素。</li><li><strong>查找</strong>：通过索引直接访问指定位置的元素。</li><li><strong>修改</strong>：通过索引修改指定位置的元素。</li></ul><h4><a name='header-n524' class='md-header-anchor '></a>2.4.2 顺序表中基本操作的实现</h4><p>在顺序表中，常见的基本操作包括：初始化、插入、删除、查找、修改、遍历等。下面是这些操作的C++代码实现，并附有详细注释。</p><p><strong>1. 顺序表的结构定义</strong></p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;iostream&gt;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">using namespace std;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 定义顺序表类</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class SeqList {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">private:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int* arr; &nbsp; &nbsp; &nbsp; &nbsp;  // 动态数组，存储线性表的元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int capacity; &nbsp; &nbsp;  // 顺序表的最大容量</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int length; &nbsp; &nbsp; &nbsp;  // 当前顺序表中元素的个数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 构造函数：初始化顺序表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  SeqList(int cap) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  capacity = cap;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  length = 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  arr = new int[capacity]; // 动态分配内存</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 析构函数：释放动态分配的内存</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  ~SeqList() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  delete[] arr;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 打印顺序表中的所有元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void print() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  for (int i = 0; i &lt; length; i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; arr[i] &lt;&lt; " ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 插入元素，时间复杂度：O(n)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  bool insert(int index, int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  // 检查索引是否合法</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (index &lt; 0 || index &gt; length || length == capacity) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position or sequence full!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return false;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  // 从末尾开始移动元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  for (int i = length; i &gt; index; i--) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  arr[i] = arr[i - 1];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  arr[index] = value;  // 插入新元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  length++;  // 增加元素个数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return true;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 删除元素，时间复杂度：O(n)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  bool remove(int index) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  // 检查索引是否合法</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (index &lt; 0 || index &gt;= length) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return false;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  // 从删除位置后一个元素开始移动</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  for (int i = index; i &lt; length - 1; i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  arr[i] = arr[i + 1];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  length--;  // 减少元素个数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return true;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 查找元素的索引，时间复杂度：O(n)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int find(int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  for (int i = 0; i &lt; length; i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (arr[i] == value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return i;  // 找到元素，返回索引</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return -1;  // 未找到，返回-1</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 修改指定位置的元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  bool modify(int index, int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  // 检查索引是否合法</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (index &lt; 0 || index &gt;= length) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return false;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  arr[index] = value;  // 修改元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return true;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 获取顺序表的长度</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int getLength() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return length;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 测试顺序表操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  SeqList list(10);  // 创建一个容量为10的顺序表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.insert(0, 5);  // 插入元素5</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.insert(1, 10); // 插入元素10</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.insert(2, 15); // 插入元素15</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "Sequence List after insertions: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.print();  // 输出：5 10 15</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.remove(1);  // 删除位置为1的元素（元素10）</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "Sequence List after removal: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.print();  // 输出：5 15</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.modify(1, 20);  // 修改位置1的元素为20</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "Sequence List after modification: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.print();  // 输出：5 20</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int index = list.find(5);  // 查找元素5的位置</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  if (index != -1) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Element 5 found at index: " &lt;&lt; index &lt;&lt; endl;  // 输出：Element 5 found at index: 0</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 2837px;"></div><div class="CodeMirror-gutters" style="display: none; height: 2867px;"></div></div></div></pre><p><strong>代码说明</strong>：</p><ol start='' ><li><p><strong>SeqList类</strong>：</p><ul><li><code>arr</code>：动态数组，用于存储顺序表的元素。</li><li><code>capacity</code>：顺序表的最大容量。</li><li><code>length</code>：顺序表中当前元素的个数。</li><li>构造函数和析构函数分别用于初始化和释放内存。</li></ul></li><li><p><strong>insert()</strong>：</p><ul><li>插入操作，时间复杂度为O(n)。首先检查插入位置是否合法，然后从末尾开始将元素后移，最后插入新元素。</li></ul></li><li><p><strong>remove()</strong>：</p><ul><li>删除操作，时间复杂度为O(n)。首先检查删除位置是否合法，然后将删除位置后面的元素前移。</li></ul></li><li><p><strong>find()</strong>：</p><ul><li>查找操作，时间复杂度为O(n)。通过遍历顺序表，查找元素的位置，找到返回索引，找不到返回-1。</li></ul></li><li><p><strong>modify()</strong>：</p><ul><li>修改操作，时间复杂度为O(1)。根据给定的索引直接修改对应位置的元素。</li></ul></li><li><p><strong>print()</strong>：</p><ul><li>输出顺序表的所有元素。</li></ul></li></ol><h3><a name='header-n584' class='md-header-anchor '></a>总结</h3><p>顺序表示的线性表通过数组实现，适合快速访问和修改操作，但在插入和删除元素时，尤其是在表的中间进行操作时，性能较差。通过这些基本操作的实现，我们可以理解顺序表的核心思想，并在实际应用中根据需求选择合适的存储结构。</p><h3><a name='header-n587' class='md-header-anchor '></a>2.5 线性表的链式表示和实现</h3><p>链式表示是线性表的另一种实现方式，它通过指针将元素连接起来，而不是在内存中使用连续的空间。链式表示可以支持动态变化的长度，因此在插入和删除操作时相较于顺序表更加灵活。</p><p>链式表示包括单链表、双向链表和循环链表。下面我们将逐一介绍这些链表的定义、操作以及实现。</p><h4><a name='header-n592' class='md-header-anchor '></a>2.5.1 单链表的定义和表示</h4><p><strong>单链表</strong>（Singly Linked List）是由若干个节点组成的线性表，每个节点包含两部分：</p><ol start='' ><li><strong>数据域</strong>：存储数据。</li><li><strong>指针域</strong>：存储指向下一个节点的指针。</li></ol><p>单链表的特点是每个节点仅指向后继节点，因此只能单向访问。</p><p><strong>单链表的结构</strong>：</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">struct Node {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int data; &nbsp; &nbsp; &nbsp;  // 数据域，存储元素值</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node* next; &nbsp; &nbsp;  // 指针域，指向下一个节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 100px;"></div><div class="CodeMirror-gutters" style="display: none; height: 130px;"></div></div></div></pre><p><strong>单链表的基本操作</strong>：</p><ul><li><strong>插入</strong>：在指定位置插入节点。</li><li><strong>删除</strong>：删除指定位置的节点。</li><li><strong>查找</strong>：查找指定值的节点。</li><li><strong>修改</strong>：修改指定位置的节点数据。</li><li><strong>遍历</strong>：从头到尾访问所有节点。</li></ul><h4><a name='header-n625' class='md-header-anchor '></a>2.5.2 单链表基本操作的实现</h4><p>下面是实现单链表基本操作的C++代码示例，带有详细注释。</p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;iostream&gt;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">using namespace std;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 定义单链表节点结构</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">struct Node {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int data; &nbsp; &nbsp; &nbsp; // 数据域</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node* next; &nbsp; &nbsp; // 指向下一个节点的指针</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 单链表类</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class SinglyLinkedList {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">private:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node* head;  // 链表的头指针</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 构造函数：初始化链表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  SinglyLinkedList() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  head = nullptr;  // 初始化时头指针为空</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 析构函数：释放链表的所有节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  ~SinglyLinkedList() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* temp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  while (head != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  head = head-&gt;next;  // 移动头指针</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  delete temp; &nbsp; &nbsp; &nbsp;  // 删除节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 向链表尾部添加元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void append(int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* newNode = new Node{value, nullptr};  // 创建新节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (head == nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  head = newNode;  // 如果链表为空，新的节点作为头节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  } else {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Node* temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  while (temp-&gt;next != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = temp-&gt;next;  // 找到链表的尾节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp-&gt;next = newNode;  // 将新节点连接到尾节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 在指定位置插入元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void insertAt(int index, int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* newNode = new Node{value, nullptr};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (index == 0) {  // 插入到头部</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  newNode-&gt;next = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  head = newNode;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  } else {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Node* temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  for (int i = 0; i &lt; index - 1 &amp;&amp; temp != nullptr; i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = temp-&gt;next;  // 遍历到指定位置</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (temp != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  newNode-&gt;next = temp-&gt;next;  // 将新节点的next指向目标节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp-&gt;next = newNode; &nbsp; &nbsp; &nbsp;  // 将前一个节点的next指向新节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } else {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  delete newNode;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 删除指定位置的节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void deleteAt(int index) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (head == nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "List is empty!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* temp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (index == 0) {  // 删除头节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  head = head-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  delete temp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  } else {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Node* prev = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  for (int i = 0; i &lt; index - 1 &amp;&amp; prev-&gt;next != nullptr; i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  prev = prev-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (prev-&gt;next != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = prev-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  prev-&gt;next = temp-&gt;next;  // 删除节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  delete temp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } else {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Invalid position!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 查找指定值的节点并返回位置</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int find(int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  int index = 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  while (temp != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (temp-&gt;data == value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return index;  // 找到返回索引</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = temp-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  index++;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return -1;  // 未找到返回-1</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 打印链表元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void print() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  while (temp != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; temp-&gt;data &lt;&lt; " ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = temp-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 测试单链表的操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  SinglyLinkedList list;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 向链表添加元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.append(10);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.append(20);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.append(30);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "List after append: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.print();  // 输出：10 20 30</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 在指定位置插入元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.insertAt(1, 15);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "List after insert at position 1: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.print();  // 输出：10 15 20 30</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 删除指定位置的元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.deleteAt(2);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "List after delete at position 2: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list.print();  // 输出：10 15 30</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 查找元素位置</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int index = list.find(15);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  if (index != -1) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Element 15 found at index: " &lt;&lt; index &lt;&lt; endl;  // 输出：Element 15 found at index: 1</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 3389px;"></div><div class="CodeMirror-gutters" style="display: none; height: 3419px;"></div></div></div></pre><p><strong>代码说明</strong>：</p><ol start='' ><li><p><strong>Node结构</strong>：表示链表的节点，每个节点包含一个数据域和一个指向下一个节点的指针。</p></li><li><p>SinglyLinkedList类</p><p>：</p><ul><li><strong>append()</strong>：向链表尾部添加元素。</li><li><strong>insertAt()</strong>：在指定位置插入元素。如果位置为0，则插入到头部，否则遍历到指定位置插入。</li><li><strong>deleteAt()</strong>：删除指定位置的节点。如果位置为0，删除头节点，否则找到前一个节点并删除。</li><li><strong>find()</strong>：查找指定值的节点并返回索引。</li><li><strong>print()</strong>：打印链表中所有节点的值。</li></ul></li></ol><h4><a name='header-n656' class='md-header-anchor '></a>2.5.3 循环链表</h4><p><strong>循环链表</strong>是指链表的最后一个节点指向头节点，形成一个闭环。循环链表有两种形式：<strong>单向循环链表</strong>和<strong>双向循环链表</strong>。单向循环链表的每个节点只有一个指向下一个节点的指针。</p><p><strong>循环链表的优点</strong>：它的尾部指针可以直接连接到头部，因此在尾部插入和删除操作时更加高效。</p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 定义循环链表节点结构</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">struct Node {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int data;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node* next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 定义循环链表类</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class CircularLinkedList {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">private:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node* head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  CircularLinkedList() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  head = nullptr;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  ~CircularLinkedList() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (head != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Node* temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  do {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Node* next = temp-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  delete temp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } while (temp != head);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 向循环链表中添加节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void append(int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* newNode = new Node{value, nullptr};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (head == nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  head = newNode;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  newNode-&gt;next = head;  // 循环链表的尾节点指向头节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  } else {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Node* temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  while (temp-&gt;next != head) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = temp-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp-&gt;next = newNode;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  newNode-&gt;next = head;  // 新节点的next指向头节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 打印循环链表的所有元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void print() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (head == nullptr) return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  do {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; temp-&gt;data &lt;&lt; " ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = temp-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  } while (temp != head);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 测试循环链表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  CircularLinkedList clist;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  clist.append(10);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  clist.append(20);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  clist.append(30);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "Circular Linked List: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  clist.print();  // 输出：10 20 </span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 1457px;"></div><div class="CodeMirror-gutters" style="display: none; height: 1487px;"></div></div></div></pre><p>30</p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">return 0;</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><p>}</p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#### 2.5.4 双向链表</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">**双向链表**（Doubly Linked List）是每个节点除了指向下一个节点的指针外，还指向前一个节点。双向链表支持从两端进行操作，因此可以更加高效地进行插入和删除。</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">```cpp</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 定义双向链表节点结构</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">struct Node {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int data;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node* next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node* prev;  // 指向前一个节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 定义双向链表类</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class DoublyLinkedList {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">private:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node* head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node* tail;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  DoublyLinkedList() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  head = tail = nullptr;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  ~DoublyLinkedList() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  while (temp != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Node* next = temp-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  delete temp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 向双向链表尾部添加节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void append(int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* newNode = new Node{value, nullptr, nullptr};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (head == nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  head = tail = newNode;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  } else {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  tail-&gt;next = newNode;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  newNode-&gt;prev = tail;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  tail = newNode;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 打印双向链表的所有元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void print() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  while (temp != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; temp-&gt;data &lt;&lt; " ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = temp-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 测试双向链表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  DoublyLinkedList dlist;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  dlist.append(10);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  dlist.append(20);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  dlist.append(30);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "Doubly Linked List: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  dlist.print();  // 输出：10 20 30</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 1549px;"></div><div class="CodeMirror-gutters" style="display: none; height: 1579px;"></div></div></div></pre><h3><a name='header-n668' class='md-header-anchor '></a>总结</h3><ul><li><strong>单链表</strong>：每个节点只包含一个指向下一个节点的指针，插入和删除操作在链表中间时非常高效。</li><li><strong>循环链表</strong>：单向链表的尾节点指向头节点，形成一个闭环，适合需要循环遍历的应用场景。</li><li><strong>双向链表</strong>：每个节点包含指向前后节点的指针，支持从两端进行操作，插入和删除操作更为灵活。</li></ul><h3><a name='header-n679' class='md-header-anchor '></a>2.6 顺序表和链表的比较</h3><p>在数据结构的设计中，<strong>顺序表</strong>（顺序存储的线性表）和<strong>链表</strong>（链式存储的线性表）各有优缺点，它们在<strong>空间性能</strong>和<strong>时间性能</strong>上的表现有所不同。下面我们将通过这两个方面进行详细的比较。</p><h4><a name='header-n682' class='md-header-anchor '></a>2.6.1 空间性能的比较</h4><ul><li><p><strong>顺序表</strong>：</p><ul><li><p>优点</p><p>：</p><ul><li>空间上是连续的，可以通过数组的下标快速定位元素。</li><li>内存使用较为紧凑，适合较为静态的数据集合。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>需要预先分配一定大小的内存，容量固定，扩展困难。</li><li>如果实际存储的数据比预设的空间少，可能会造成内存浪费；如果数据量大于预设容量，则需要重新分配内存。</li><li>由于需要连续的内存空间，可能会出现内存分配失败的情况（尤其在数据量很大时）。</li></ul></li></ul></li><li><p><strong>链表</strong>：</p><ul><li><p>优点</p><p>：</p><ul><li>动态分配内存，链表节点的内存分配是独立的，可以根据实际需要增减节点。</li><li>不需要连续的内存空间，适合不确定大小的集合。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>每个节点除了数据外，还需要额外的空间来存储指针（对于单链表是指向下一个节点的指针，对于双向链表是指向前后两个节点的指针）。</li><li>总体内存使用比顺序表要多，因为每个节点都包含了指针。</li></ul></li></ul></li></ul><p><strong>总结</strong>：</p><ul><li>顺序表的空间性能较优，尤其在已知数据量固定时，能够充分利用内存。</li><li>链表的空间利用率较低，因为每个元素都需要额外存储指针，但是它能够动态扩展，适合数据量不确定的情况。</li></ul><h4><a name='header-n752' class='md-header-anchor '></a>2.6.2 时间性能的比较</h4><p>在时间性能方面，主要考虑以下几个操作：查找、插入、删除等。</p><ol start='' ><li><p><strong>查找操作</strong>：</p><ul><li><p>顺序表</p><p>：</p><ul><li>查找操作是通过数组下标进行的，时间复杂度为 <strong>O(1)</strong>。</li><li>对于顺序查找（无序的情况），时间复杂度为 <strong>O(n)</strong>。</li></ul></li><li><p>链表</p><p>：</p><ul><li>对于链表，查找操作需要从头节点开始遍历，直到找到目标元素。最坏情况下时间复杂度为 <strong>O(n)</strong>，即需要遍历整个链表。</li><li>对于有序链表，可以通过顺序查找或者跳跃查找，但一般依然是 <strong>O(n)</strong>。</li></ul></li></ul><p><strong>总结</strong>：</p><ul><li>顺序表的查找性能较优，能够直接通过下标访问元素。</li><li>链表的查找性能较差，需要逐个节点进行遍历。</li></ul></li><li><p><strong>插入操作</strong>：</p><ul><li><p>顺序表</p><p>：</p><ul><li>如果是在末尾插入元素，时间复杂度为 <strong>O(1)</strong>。</li><li>如果是插入到中间或前面，则需要将插入位置后的所有元素后移，时间复杂度为 <strong>O(n)</strong>。</li></ul></li><li><p>链表</p><p>：</p><ul><li>在链表中插入元素，时间复杂度为 <strong>O(1)</strong>，前提是给定插入位置的指针（例如，在头部或尾部插入）。</li><li>如果没有给定位置的指针，仍然需要遍历链表定位插入位置，时间复杂度为 <strong>O(n)</strong>。</li></ul></li></ul><p><strong>总结</strong>：</p><ul><li>链表的插入操作在已知位置时较为高效，尤其是在表头或表尾插入时。</li><li>顺序表的插入操作需要移动元素，性能较差，尤其是在中间插入时。</li></ul></li><li><p><strong>删除操作</strong>：</p><ul><li><p>顺序表</p><p>：</p><ul><li>删除操作类似于插入操作。如果是删除末尾元素，时间复杂度为 <strong>O(1)</strong>。</li><li>如果是删除中间元素，则需要将删除位置后的所有元素前移，时间复杂度为 <strong>O(n)</strong>。</li></ul></li><li><p>链表</p><p>：</p><ul><li>删除操作需要找到目标节点，并调整指针，时间复杂度为 <strong>O(1)</strong>，前提是已知目标节点。</li><li>如果需要先遍历链表找到目标节点，时间复杂度为 <strong>O(n)</strong>。</li></ul></li></ul><p><strong>总结</strong>：</p><ul><li>链表的删除操作在已知位置时也非常高效，而顺序表在删除操作时，如果涉及到中间元素，性能较差。</li></ul></li></ol><h4><a name='header-n864' class='md-header-anchor '></a>C++ 代码实现：顺序表与链表的性能比较</h4><p>为了更好地理解空间和时间性能的差异，以下是一个简单的C++实现，用于比较顺序表和链表在插入、删除和查找操作上的性能。</p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;iostream&gt;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;ctime&gt;  // 用于计算时间</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;vector&gt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">using namespace std;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 定义顺序表类</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class SeqList {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">private:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  vector&lt;int&gt; arr;  // 使用vector动态分配内存</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 插入操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void insert(int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  arr.push_back(value);  // 向尾部插入元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 查找操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int find(int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  for (int i = 0; i &lt; arr.size(); i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (arr[i] == value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return i;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return -1;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 删除操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void remove(int index) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (index &gt;= 0 &amp;&amp; index &lt; arr.size()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  arr.erase(arr.begin() + index);  // 删除指定位置的元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 获取表的大小</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int size() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return arr.size();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 定义链表节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">struct Node {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int data;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node* next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 定义链表类</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class LinkedList {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">private:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node* head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  LinkedList() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  head = nullptr;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 插入操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void insert(int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* newNode = new Node{value, head};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  head = newNode;  // 在头部插入</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 查找操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int find(int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  int index = 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  while (temp != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (temp-&gt;data == value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return index;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = temp-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  index++;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return -1;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 删除操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void remove(int value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* prev = nullptr;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  while (temp != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (temp-&gt;data == value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (prev == nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  head = temp-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } else {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  prev-&gt;next = temp-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  delete temp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  prev = temp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = temp-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 获取链表长度</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int size() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  int count = 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node* temp = head;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  while (temp != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  count++;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  temp = temp-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return count;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 测试函数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void testPerformance() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  const int N = 100000;  // 测试数据规模</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 测试顺序表性能</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  SeqList seqList;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  clock_t start = clock();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; N; i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  seqList.insert(i);  // 向顺序表插入元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; N; i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  seqList.find(i);  // 查找顺序表中的元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; N; i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  seqList.remove(0);  // 删除顺序表中的元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  clock_t end = clock();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "SeqList time: " &lt;&lt; double(end - start) / CLOCKS_PER_SEC &lt;&lt; " seconds" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 测试链表性能</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  LinkedList linkedList;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  start = clock();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; N; i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  linkedList.insert(i);  // 向链表插入元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; N; i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  linkedList.find(i);  // 查找链表中的元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; N; i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  linkedList.remove(i);  // 删除链表中的元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  end = clock();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "LinkedList time: " &lt;&lt; double(end - start) / CLOCKS_PER_SEC &lt;&lt; " seconds" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  testPerformance();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 3343px;"></div><div class="CodeMirror-gutters" style="display: none; height: 3373px;"></div></div></div></pre><h4><a name='header-n868' class='md-header-anchor '></a>代码说明：</h4><ol start='' ><li><strong>顺序表的实现</strong>：使用 <code>vector</code> 来模拟顺序表。提供插入、查找和删除操作。</li><li><strong>链表的实现</strong>：使用结构体 <code>Node</code> 来表示链表的节点，</li></ol><p>提供插入、查找和删除操作。3. <strong>性能测试</strong>：通过插入、查找和删除操作来测试顺序表和链表在大规模数据（<code>N = 100000</code>）下的性能表现。通过 <code>clock_t</code> 测量时间。</p><h4><a name='header-n878' class='md-header-anchor '></a>输出：</h4><p>代码运行后将显示顺序表和链表的操作时间，帮助我们了解它们在大数据量下的性能差异。</p><h3><a name='header-n881' class='md-header-anchor '></a>总结</h3><ul><li><strong>顺序表</strong>：由于内存是连续分配的，因此在查找操作时速度较快，但在插入和删除操作时需要移动元素，特别是在中间插入和删除时效率较低。</li><li><strong>链表</strong>：动态内存分配，不需要连续空间，适合经常插入和删除的场景，但查找操作较慢，因为需要逐个遍历节点。</li></ul><h3><a name='header-n889' class='md-header-anchor '></a>2.7 线性表的应用</h3><p>线性表作为一种常用的数据结构，在计算机科学和工程中有着广泛的应用。它不仅可以用于表示简单的线性数据集合，还可以被用来实现许多算法和解决实际问题。在线性表的应用中，<strong>合并操作</strong>是一个非常常见且重要的操作，尤其是在处理排序、集合运算等问题时。</p><h4><a name='header-n892' class='md-header-anchor '></a>2.7.1 线性表的合并</h4><p>线性表的合并指的是将两个或多个线性表合并成一个线性表，合并后的新表包含所有原表的元素。在进行合并时，通常有两种方式：</p><ol start='' ><li><strong>简单合并</strong>：直接将一个线性表的元素添加到另一个线性表的末尾。</li><li><strong>合并时去重</strong>：合并的同时去掉重复的元素，确保结果中每个元素的唯一性。</li></ol><h5><a name='header-n902' class='md-header-anchor '></a>简单合并</h5><p>简单合并线性表可以通过遍历两个表，将一个表的所有元素逐个插入到另一个表中。此操作的时间复杂度通常为 <strong>O(n)</strong>，其中 n 是两个表中元素的总数。</p><p><strong>C++代码实现：</strong></p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;iostream&gt;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;vector&gt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">using namespace std;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 合并两个线性表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void mergeLists(vector&lt;int&gt;&amp; list1, vector&lt;int&gt;&amp; list2) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 将list2的元素添加到list1中</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; list2.size(); i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  list1.push_back(list2[i]);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 打印线性表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void printList(const vector&lt;int&gt;&amp; list) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; list.size(); i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; list[i] &lt;&lt; " ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 初始化两个线性表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  vector&lt;int&gt; list1 = {1, 2, 3, 4};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  vector&lt;int&gt; list2 = {5, 6, 7, 8};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 打印原始线性表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "List1: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  printList(list1);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "List2: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  printList(list2);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 合并两个线性表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  mergeLists(list1, list2);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 打印合并后的线性表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "Merged List: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  printList(list1);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 928px;"></div><div class="CodeMirror-gutters" style="display: none; height: 958px;"></div></div></div></pre><p><strong>代码说明：</strong></p><ul><li><code>mergeLists</code> 函数用于合并两个线性表，将 <code>list2</code> 的元素依次加入到 <code>list1</code> 中。</li><li><code>printList</code> 用于打印线性表的元素。</li></ul><p><strong>输出示例：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">List1: 1 2 3 4 </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">List2: 5 6 7 8 </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Merged List: 1 2 3 4 5 6 7 8 </span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 77px;"></div><div class="CodeMirror-gutters" style="display: none; height: 107px;"></div></div></div></pre><h5><a name='header-n920' class='md-header-anchor '></a>合并时去重</h5><p>当合并两个线性表时，如果我们要求合并后的结果中没有重复的元素，则需要在合并时去除重复元素。我们可以使用哈希表或排序后去重的方式来实现。</p><p><strong>C++代码实现（合并并去重）：</strong></p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;iostream&gt;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;vector&gt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;unordered_set&gt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">using namespace std;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 合并两个线性表并去重</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void mergeAndRemoveDuplicates(vector&lt;int&gt;&amp; list1, vector&lt;int&gt;&amp; list2) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  unordered_set&lt;int&gt; uniqueSet;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 将list1的元素插入到集合中，自动去重</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; list1.size(); i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  uniqueSet.insert(list1[i]);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 将list2的元素插入到集合中，自动去重</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; list2.size(); i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  uniqueSet.insert(list2[i]);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 清空list1，并将去重后的元素按顺序添加回list1</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  list1.clear();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (const auto&amp; elem : uniqueSet) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  list1.push_back(elem);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 打印线性表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void printList(const vector&lt;int&gt;&amp; list) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; list.size(); i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; list[i] &lt;&lt; " ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 初始化两个线性表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  vector&lt;int&gt; list1 = {1, 2, 3, 4};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  vector&lt;int&gt; list2 = {3, 4, 5, 6};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 打印原始线性表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "List1: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  printList(list1);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "List2: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  printList(list2);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 合并并去重</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  mergeAndRemoveDuplicates(list1, list2);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 打印合并后的线性表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "Merged and Unique List: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  printList(list1);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 1250px;"></div><div class="CodeMirror-gutters" style="display: none; height: 1280px;"></div></div></div></pre><p><strong>代码说明：</strong></p><ul><li><code>mergeAndRemoveDuplicates</code> 函数利用 <code>unordered_set</code> 来去重，因为 <code>unordered_set</code> 在插入元素时会自动排除重复的元素。</li><li>合并后的结果将元素从 <code>unordered_set</code> 中提取，并按顺序放回 <code>list1</code> 中。</li></ul><p><strong>输出示例：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">List1: 1 2 3 4 </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">List2: 3 4 5 6 </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Merged and Unique List: 1 2 3 4 5 6 </span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 77px;"></div><div class="CodeMirror-gutters" style="display: none; height: 107px;"></div></div></div></pre><h4><a name='header-n938' class='md-header-anchor '></a>2.7.2 有序表的合并</h4><p>如果合并的两个线性表已经是<strong>有序的</strong>，我们可以通过一种更高效的方式来合并它们，而不需要像简单合并那样依次插入每个元素。对于两个有序的线性表，我们可以采用<strong>双指针法</strong>（类似于归并排序中的合并操作）来进行合并。这个方法的时间复杂度为 <strong>O(n)</strong>，其中 n 是两个表中元素的总数。</p><p><strong>C++代码实现（有序表合并）：</strong></p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;iostream&gt;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;vector&gt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">using namespace std;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 有序表合并</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void mergeSortedLists(const vector&lt;int&gt;&amp; list1, const vector&lt;int&gt;&amp; list2, vector&lt;int&gt;&amp; result) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int i = 0, j = 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 合并过程</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  while (i &lt; list1.size() &amp;&amp; j &lt; list2.size()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (list1[i] &lt; list2[j]) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  result.push_back(list1[i]);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  i++;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  } else {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  result.push_back(list2[j]);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  j++;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 将剩余的元素添加到结果中</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  while (i &lt; list1.size()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  result.push_back(list1[i]);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  i++;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  while (j &lt; list2.size()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  result.push_back(list2[j]);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  j++;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 打印线性表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">void printList(const vector&lt;int&gt;&amp; list) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (int i = 0; i &lt; list.size(); i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; list[i] &lt;&lt; " ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 初始化两个有序表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  vector&lt;int&gt; list1 = {1, 3, 5, 7};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  vector&lt;int&gt; list2 = {2, 4, 6, 8};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  vector&lt;int&gt; result;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 打印原始有序表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "List1: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  printList(list1);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "List2: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  printList(list2);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 合并有序表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  mergeSortedLists(list1, list2, result);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 打印合并后的有序表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "Merged Sorted List: ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  printList(result);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 1388px;"></div><div class="CodeMirror-gutters" style="display: none; height: 1418px;"></div></div></div></pre><p><strong>代码说明：</strong></p><ul><li><code>mergeSortedLists</code> 函数使用两个指针 <code>i</code> 和 <code>j</code> 分别指向两个有序线性表的当前元素。</li><li>比较两个元素的大小，将较小的元素加入到结果表 <code>result</code> 中，然后移动对应的指针。</li><li>最后，将未遍历完的表中的剩余元素加入到结果表中。</li></ul><p><strong>输出示例：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">List1: 1 3 5 7 </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">List2: 2 4 6 8 </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Merged Sorted List: 1 2 3 4 5 6 7 8 </span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 77px;"></div><div class="CodeMirror-gutters" style="display: none; height: 107px;"></div></div></div></pre><h3><a name='header-n959' class='md-header-anchor '></a>总结</h3><ul><li><strong>线性表的合并</strong>：简单合并和去重合并是合并操作的常见应用。简单合并直接将一个表的元素插入到另一个表中；去重合并可以通过哈希表或排序后去重来实现。</li><li><strong>有序表的合并</strong>：对于已排序的表，使用双指针法进行合并，时间复杂度为 <strong>O(n)</strong>，比直接合并更高效。</li></ul><h3><a name='header-n967' class='md-header-anchor '></a>第 3 章 栈和队列</h3><p>栈（Stack）和队列（Queue）是两种常见的数据结构，它们都属于线性表结构，但在操作方式上有所不同。栈遵循的是“后进先出”（LIFO，Last In First Out）的原则，而队列遵循的是“先进先出”（FIFO，First In First Out）的原则。栈和队列广泛应用于计算机科学中的各种算法和问题求解中。</p><h4><a name='header-n970' class='md-header-anchor '></a>3.1 栈和队列的定义和特点</h4><h5><a name='header-n971' class='md-header-anchor '></a>3.1.1 栈的定义和特点</h5><p>栈（Stack）是一种只允许在一端进行插入和删除操作的数据结构，这一端叫做栈顶（Top）。栈的操作遵循“后进先出”（LIFO）原则，即最后插入的元素最先被删除。</p><p><strong>栈的基本操作：</strong></p><ol start='' ><li><strong>Push</strong>：将一个元素压入栈顶。</li><li><strong>Pop</strong>：从栈顶移除一个元素。</li><li><strong>Peek</strong> 或 <strong>Top</strong>：查看栈顶元素，但不移除它。</li><li><strong>isEmpty</strong>：检查栈是否为空。</li></ol><p><strong>栈的特点：</strong></p><ul><li><strong>后进先出</strong>：最新插入的元素会最先被删除。</li><li>只能从栈顶进行操作，不能直接访问栈底的元素。</li><li>常用于解决递归问题、表达式求值、括号匹配等场景。</li></ul><p><strong>栈的应用：</strong></p><ul><li><strong>函数调用管理</strong>：程序的函数调用是通过栈来实现的，函数调用压栈，函数返回弹栈。</li><li><strong>括号匹配问题</strong>：可以利用栈来判断表达式中的括号是否匹配。</li></ul><h5><a name='header-n1010' class='md-header-anchor '></a>3.1.2 队列的定义和特点</h5><p>队列（Queue）是一种允许从一端插入元素，从另一端删除元素的数据结构。队列的操作遵循“先进先出”（FIFO）原则，即最早插入的元素最先被删除。</p><p><strong>队列的基本操作：</strong></p><ol start='' ><li><strong>Enqueue</strong>：将一个元素加入到队列的尾部。</li><li><strong>Dequeue</strong>：从队列的头部移除一个元素。</li><li><strong>Front</strong>：查看队列头部的元素，但不移除它。</li><li><strong>isEmpty</strong>：检查队列是否为空。</li></ol><p><strong>队列的特点：</strong></p><ul><li><strong>先进先出</strong>：最先插入的元素会最先被删除。</li><li>只能从队尾插入元素，从队头删除元素。</li><li>常用于任务调度、数据流控制、广度优先搜索等场景。</li></ul><p><strong>队列的应用：</strong></p><ul><li><strong>任务调度</strong>：操作系统中使用队列来管理任务的调度，确保任务按照顺序执行。</li><li><strong>广度优先搜索（BFS）</strong>：BFS 算法通常使用队列来实现，确保节点按层次顺序访问。</li></ul><h4><a name='header-n1049' class='md-header-anchor '></a>3.2 案例引入</h4><p>为了更好地理解栈和队列的应用，下面通过两个经典的编程问题来引入和应用栈与队列。</p><ol start='' ><li><strong>栈的应用案例：括号匹配</strong>给定一个包含括号的表达式，判断括号是否匹配。我们可以使用栈来解决这个问题，遇到开括号时将其压栈，遇到闭括号时弹栈，如果弹栈时括号不匹配，则说明不合法。</li><li><strong>队列的应用案例：打印队列中的元素</strong>假设我们有一个任务调度系统，任务按照队列的顺序执行。可以使用队列来模拟任务的添加与执行，保证任务按顺序完成。</li></ol><p>接下来将通过 C++ 示例代码来实现这些应用案例。</p><hr /><h3><a name='header-n1062' class='md-header-anchor '></a>C++ 代码实现：</h3><h4><a name='header-n1063' class='md-header-anchor '></a>1. 栈的应用：括号匹配</h4><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;iostream&gt;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;stack&gt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;string&gt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">using namespace std;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 判断括号是否匹配</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">bool isValidParentheses(const string&amp; s) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack&lt;char&gt; st;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for (char ch : s) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (ch == '(' || ch == '[' || ch == '{') {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  st.push(ch);  // 遇到开括号，压栈</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  } else if (ch == ')' || ch == ']' || ch == '}') {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (st.empty()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return false;  // 遇到闭括号但栈为空，不匹配</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  char top = st.top();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  st.pop();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 检查是否匹配</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if ((ch == ')' &amp;&amp; top != '(') || </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (ch == ']' &amp;&amp; top != '[') || </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (ch == '}' &amp;&amp; top != '{')) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return false;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return st.empty();  // 栈空则匹配成功，栈不空则有未匹配的括号</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  string expression = "{[()]}";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  if (isValidParentheses(expression)) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "The parentheses are valid!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  } else {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "The parentheses are invalid!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 905px;"></div><div class="CodeMirror-gutters" style="display: none; height: 935px;"></div></div></div></pre><p><strong>代码说明：</strong></p><ul><li>使用 <code>stack&lt;char&gt;</code> 来模拟栈操作。</li><li>遍历输入的字符串，当遇到开括号时将其压栈，遇到闭括号时弹栈并检查是否匹配。</li></ul><p><strong>输出示例：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">The parentheses are valid!</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 31px;"></div><div class="CodeMirror-gutters" style="display: none; height: 61px;"></div></div></div></pre><h4><a name='header-n1077' class='md-header-anchor '></a>2. 队列的应用：任务调度</h4><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;iostream&gt;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;queue&gt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">using namespace std;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 创建队列</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  queue&lt;string&gt; tasks;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 模拟任务调度</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  tasks.push("Task 1");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  tasks.push("Task 2");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  tasks.push("Task 3");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "Executing tasks..." &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 执行任务</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  while (!tasks.empty()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Executing: " &lt;&lt; tasks.front() &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  tasks.pop();  // 执行完任务后移除</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 537px;"></div><div class="CodeMirror-gutters" style="display: none; height: 567px;"></div></div></div></pre><p><strong>代码说明：</strong></p><ul><li>使用 <code>queue&lt;string&gt;</code> 来模拟任务队列。</li><li><code>push()</code> 用于将任务添加到队列的尾部，<code>pop()</code> 用于从队列头部移除任务。</li></ul><p><strong>输出示例：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Executing tasks...</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Executing: Task 1</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Executing: Task 2</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Executing: Task 3</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 100px;"></div><div class="CodeMirror-gutters" style="display: none; height: 130px;"></div></div></div></pre><hr /><h3><a name='header-n1092' class='md-header-anchor '></a>总结</h3><ul><li><strong>栈</strong>：后进先出（LIFO），主要应用于函数调用管理、表达式求值、括号匹配等场景。</li><li><strong>队列</strong>：先进先出（FIFO），主要应用于任务调度、广度优先搜索等场景。</li><li>栈和队列在数据结构和算法中具有广泛的应用，通过实际案例可以帮助更好地理解它们的特性和应用场景。</li></ul><p>在实际问题中，栈和队列的选择取决于问题的性质，栈适合处理递归、回溯等问题，队列适合处理顺序或并行执行的任务。</p><h3><a name='header-n1105' class='md-header-anchor '></a>3.3 栈的表示和操作的实现</h3><p>栈作为一种线性数据结构，有两种常见的实现方式：顺序栈和链栈。顺序栈是通过数组来表示栈，而链栈则是通过链表来表示栈。在这部分，我们将详细介绍栈的类型定义、顺序栈和链栈的实现，并提供相关的 C++ 代码。</p><h4><a name='header-n1108' class='md-header-anchor '></a>3.3.1 栈的类型定义</h4><p>栈可以通过两种方式来实现：顺序栈和链栈。</p><ul><li><strong>顺序栈</strong>：通过数组实现，栈的大小固定，元素存储在连续的内存空间中。</li><li><strong>链栈</strong>：通过链表实现，栈的大小可以动态变化，栈顶指针指向链表的头部。</li></ul><p>对于栈的基本类型定义，我们首先需要定义栈的数据结构。栈的一般定义包括栈的大小、栈顶指针以及用于存储栈元素的数组或链表。</p><p><strong>栈的类型定义：</strong></p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 栈的结构体定义</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">template &lt;typename T&gt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">struct Stack {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  T* data;  // 栈存储元素的数组或链表</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int top; &nbsp; // 栈顶指针</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int capacity; // 栈的容量</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 构造函数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Stack(int size) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  data = new T[size];  // 为数组分配内存</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  top = -1;  // 初始化栈顶指针</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  capacity = size;  // 设置栈的容量</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 析构函数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  ~Stack() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  delete[] data;  // 释放栈的内存</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 栈的基本操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  bool isEmpty() { return top == -1; }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  bool isFull() { return top == capacity - 1; }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void push(const T&amp; value);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  T pop();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  T peek();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 606px;"></div><div class="CodeMirror-gutters" style="display: none; height: 636px;"></div></div></div></pre><p>在这个定义中，栈包含了 <code>data</code>（用于存储栈元素的数组）、<code>top</code>（栈顶指针）和 <code>capacity</code>（栈的容量）。接下来我们将分别介绍顺序栈和链栈的具体实现。</p><hr /><h4><a name='header-n1126' class='md-header-anchor '></a>3.3.2 顺序栈的表示和实现</h4><p>顺序栈是通过数组来实现的，因此需要事先确定栈的大小。在顺序栈中，栈顶元素的插入和删除操作都发生在数组的末尾。</p><p><strong>顺序栈的实现：</strong></p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;iostream&gt;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">using namespace std;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">template &lt;typename T&gt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class SeqStack {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">private:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  T* data; &nbsp; // 存储栈元素的数组</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int top; &nbsp;  // 栈顶指针</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int capacity;  // 栈的容量</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 构造函数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  SeqStack(int size) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  data = new T[size];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  top = -1;  // 栈空时栈顶指针为 -1</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  capacity = size;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 析构函数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  ~SeqStack() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  delete[] data;  // 释放栈的内存</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 判断栈是否为空</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  bool isEmpty() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return top == -1;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 判断栈是否已满</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  bool isFull() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return top == capacity - 1;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 入栈操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void push(const T&amp; value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (isFull()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Stack is full!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  data[++top] = value;  // 将元素压入栈顶</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 出栈操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  T pop() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (isEmpty()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return T();  // 返回默认值</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return data[top--];  // 弹出栈顶元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 获取栈顶元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  T peek() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (isEmpty()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return T();  // 返回默认值</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return data[top];  // 返回栈顶元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 打印栈中的所有元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void print() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (isEmpty()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  for (int i = 0; i &lt;= top; i++) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; data[i] &lt;&lt; " ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  SeqStack&lt;int&gt; stack(5);  // 创建一个容量为 5 的栈</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.push(10);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.push(20);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.push(30);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.push(40);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.push(50);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.print();  // 打印栈中的所有元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "Top element: " &lt;&lt; stack.peek() &lt;&lt; endl;  // 获取栈顶元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.pop();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.print();  // 弹出栈顶元素并打印栈中元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 2101px;"></div><div class="CodeMirror-gutters" style="display: none; height: 2131px;"></div></div></div></pre><p><strong>代码说明：</strong></p><ul><li><code>push()</code>：将元素压入栈顶，如果栈已满则输出提示信息。</li><li><code>pop()</code>：从栈顶弹出元素，如果栈为空则输出提示信息。</li><li><code>peek()</code>：返回栈顶元素，但不删除。</li><li><code>print()</code>：打印栈中的所有元素。</li></ul><p><strong>输出示例：</strong></p><pre class="md-fences md-end-block" lang=""> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">10 20 30 40 50 </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Top element: 50</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">10 20 30 40 </span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 77px;"></div><div class="CodeMirror-gutters" style="display: none; height: 107px;"></div></div></div></pre><hr /><h4><a name='header-n1151' class='md-header-anchor '></a>3.3.3 链栈的表示和实现</h4><p>链栈是一种使用链表实现的栈，它不需要预先定义容量，栈的大小可以动态扩展。每次入栈时，栈顶元素都会作为新节点加入链表。</p><p><strong>链栈的实现：</strong></p><pre class="md-fences md-end-block" lang="" style="break-inside: unset;"> <div class="CodeMirror cm-s-inner CodeMirror-wrap"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 4px; left: 4px;"></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 30px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include &lt;iostream&gt;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">using namespace std;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">template &lt;typename T&gt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">struct Node {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  T data; &nbsp; &nbsp; &nbsp; &nbsp; // 存储栈元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node* next; &nbsp; &nbsp; // 指向下一个节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">template &lt;typename T&gt;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class LinkStack {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">private:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  Node&lt;T&gt;* top; &nbsp; // 栈顶指针</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 构造函数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  LinkStack() : top(nullptr) {}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 析构函数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  ~LinkStack() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  while (!isEmpty()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  pop();  // 弹出栈中的所有元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 判断栈是否为空</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  bool isEmpty() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return top == nullptr;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 入栈操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void push(const T&amp; value) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node&lt;T&gt;* newNode = new Node&lt;T&gt;{value, top};  // 创建新节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  top = newNode;  // 更新栈顶指针</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 出栈操作</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  T pop() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (isEmpty()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return T();  // 返回默认值</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node&lt;T&gt;* temp = top;  // 保存栈顶节点</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  T value = top-&gt;data;  // 获取栈顶元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  top = top-&gt;next;  // 更新栈顶指针</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  delete temp;  // 释放栈顶节点的内存</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return value;  // 返回栈顶元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 获取栈顶元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  T peek() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (isEmpty()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return T();  // 返回默认值</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return top-&gt;data;  // 返回栈顶元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // 打印栈中的所有元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  void print() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  if (isEmpty()) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Node&lt;T&gt;* current = top;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  while (current != nullptr) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cout &lt;&lt; current-&gt;data &lt;&lt; " ";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  current = current-&gt;next;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  cout &lt;&lt; endl;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int main() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  LinkStack&lt;int&gt; stack;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.push(10);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.push(20);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.push(30);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.push(40);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.push(50);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.print();  // 打印栈中的所有元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  cout &lt;&lt; "Top element: " &lt;&lt; stack.peek() &lt;&lt; endl;  // 获取栈顶元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.pop();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  stack.print();  // 弹出栈顶元素并打印栈中元素</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px; border-bottom: 0px solid transparent; top: 2101px;"></div><div class="CodeMirror-gutters" style="display: none; height: 2131px;"></div></div></div></pre><p><strong>代码说明：</strong></p><ul><li>链栈使用一个链表节点 <code>Node</code> 来表示栈中的元素。每个节点包含数据和指向下一个节点的指针。</li><li><code>push()</code>：将新节点压入栈顶，更新栈顶指针。</li><li><code>pop()</code>：删除栈顶节点，并返回其数据。</li><li><code>peek()</code>：返回栈顶节点的数据，但不删除。</li><li><code>print()</code>：打印栈中的所有元素。</li></ul><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">50 40 30 20 10 
Top element: 50
40 30 20 10 
</pre><hr /><h3><a name='header-n1179' class='md-header-anchor '></a>总结</h3><ul><li><strong>顺序栈</strong>：通过数组</li></ul><p>实现，栈的大小固定。适合用于容量已知且固定的情况。操作简单但可能浪费空间。</p><ul><li><strong>链栈</strong>：通过链表实现，栈的大小动态变化。适合用于容量不确定的情况，不会浪费空间，但实现上相对复杂。</li></ul><p>栈的应用广泛，包括函数调用管理、表达式求值、括号匹配、深度优先搜索等。顺序栈和链栈的选择依据具体应用场景而定。</p><h3><a name='header-n1192' class='md-header-anchor '></a>3.4 栈与递归</h3><p>递归是程序设计中的一种常见方法，它通过函数调用自身来解决问题。栈在递归过程中扮演了至关重要的角色，因为递归本质上就是一个栈操作过程。每一次递归调用都将当前函数的状态保存在栈中，并在递归结束时恢复这些状态。</p><p>在这一部分，我们将讨论递归与栈的关系，包括递归算法的应用、递归工作栈的作用、递归算法的效率分析以及如何通过栈将递归算法转换为非递归算法。</p><h4><a name='header-n1197' class='md-header-anchor '></a>3.4.1 采用递归算法解决的问题</h4><p>递归算法通过函数调用自身来简化问题的求解。许多经典问题都可以通过递归算法来高效解决。例如，计算阶乘、斐波那契数列、树的遍历、图的深度优先搜索等。</p><p><strong>典型的递归问题：</strong></p><ol start='' ><li><p><strong>阶乘问题：</strong>阶乘问题是递归算法的经典例子。<code>n! = n * (n-1)!</code>，递归的基本思想是将大问题拆解为小问题，直到问题达到最小的边界条件。</p><p><strong>阶乘递归算法的实现：</strong></p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 计算阶乘的递归函数
int factorial(int n) {
    if (n == 0 || n == 1) {
        return 1;  // 递归的边界条件
    }
    return n * factorial(n - 1);  // 递归调用
}

int main() {
    int num = 5;
    cout &lt;&lt; num &lt;&lt; "! = " &lt;&lt; factorial(num) &lt;&lt; endl;
    return 0;
}
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">5! = 120
</pre></li><li><p><strong>斐波那契数列：</strong>斐波那契数列的定义是：<code>F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2)</code>。这个问题也可以通过递归来解决。</p><p><strong>斐波那契数列的递归实现：</strong></p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 计算斐波那契数列的递归函数
int fibonacci(int n) {
    if (n == 0) {
        return 0;  // 递归的边界条件
    }
    if (n == 1) {
        return 1;  // 递归的边界条件
    }
    return fibonacci(n - 1) + fibonacci(n - 2);  // 递归调用
}

int main() {
    int n = 6;
    cout &lt;&lt; "Fibonacci of " &lt;&lt; n &lt;&lt; " is " &lt;&lt; fibonacci(n) &lt;&lt; endl;
    return 0;
}
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">Fibonacci of 6 is 8
</pre></li></ol><hr /><h4><a name='header-n1222' class='md-header-anchor '></a>3.4.2 递归过程与递归工作栈</h4><p>递归函数的调用过程本质上是一个栈操作。每次递归调用时，程序会将当前函数的参数、局部变量以及执行状态（包括程序计数器等）压入栈中。当递归的某一层返回时，程序会从栈中弹出状态，并恢复到上一层。</p><p><strong>递归过程中的栈：</strong></p><ol start='' ><li>每当函数调用自身时，新的函数调用会被压入栈。</li><li>当递归到达边界条件时，开始弹出栈，逐层返回结果。</li><li>在递归过程中，每一层的状态都会被保存在栈中，直到递归调用结束。</li></ol><p>以下是一个更具体的例子来说明递归过程中的栈操作：</p><p><strong>递归过程中的栈演示：</strong></p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

void recursiveFunction(int n) {
    cout &lt;&lt; "Entering recursion with n = " &lt;&lt; n &lt;&lt; endl;
    
    // 递归终止条件
    if (n &lt;= 0) {
        cout &lt;&lt; "Base case reached" &lt;&lt; endl;
        return;
    }
    
    // 递归调用
    recursiveFunction(n - 1);
    cout &lt;&lt; "Returning from recursion with n = " &lt;&lt; n &lt;&lt; endl;
}

int main() {
    recursiveFunction(3);
    return 0;
}
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">Entering recursion with n = 3
Entering recursion with n = 2
Entering recursion with n = 1
Entering recursion with n = 0
Base case reached
Returning from recursion with n = 1
Returning from recursion with n = 2
Returning from recursion with n = 3
</pre><p>在上面的程序中，<code>recursiveFunction</code> 递归地调用自己，直到 <code>n == 0</code> 时停止。在每次递归调用时，当前函数的状态（即栈帧）会被压入栈，直到返回。</p><hr /><h4><a name='header-n1248' class='md-header-anchor '></a>3.4.3 递归算法的效率分析</h4><p>递归算法的效率往往依赖于递归调用的深度和每一层的工作量。递归过程的时间复杂度通常由递归公式决定。递归算法可能会导致大量的重复计算，尤其是存在重叠子问题时。</p><p><strong>递归算法的效率分析：</strong></p><ol start='' ><li><strong>时间复杂度：</strong>时间复杂度通常由递归调用的次数和每次调用的工作量决定。例如，在斐波那契数列的递归实现中，由于每个数值会被计算多次，因此效率非常低。递归树的大小和层数决定了算法的时间复杂度。</li><li><strong>空间复杂度：</strong>递归的空间复杂度通常是栈的深度。例如，深度为 <code>n</code> 的递归会占用 <code>O(n)</code> 的空间。</li></ol><p><strong>示例：斐波那契数列的递归时间复杂度：</strong></p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 计算斐波那契数列的递归函数
int fibonacci(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);  // 递归调用
}

int main() {
    int n = 40;  // 输入较大的值，效率较低
    cout &lt;&lt; "Fibonacci of " &lt;&lt; n &lt;&lt; " is " &lt;&lt; fibonacci(n) &lt;&lt; endl;
    return 0;
}
</pre><p><strong>递归的时间复杂度为 O(2^n)</strong>，因为每个函数调用都会产生两个子函数调用。递归算法可以通过动态规划（记忆化递归）进行优化，减少重复计算。</p><hr /><h4><a name='header-n1266' class='md-header-anchor '></a>3.4.4 利用栈将递归转换为非递归的方法</h4><p>递归调用的栈实际上可以用显式的栈来模拟。在将递归算法转化为非递归算法时，可以使用栈来模拟递归调用的过程。例如，深度优先搜索（DFS）和树的遍历等问题可以通过显式栈来实现。</p><p><strong>递归转非递归的示例：计算阶乘</strong></p><p>递归的阶乘算法可以用栈来实现。我们通过显式栈来模拟函数调用的过程。</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;

// 非递归计算阶乘的函数
int factorial(int n) {
    stack&lt;int&gt; st;  // 用栈来模拟递归过程
    int result = 1;

    // 将所有数字从 n 依次推入栈中
    while (n &gt; 1) {
        st.push(n);
        n--;
    }

    // 从栈中逐个弹出，并进行乘法运算
    while (!st.empty()) {
        result *= st.top();  // 栈顶元素
        st.pop();  // 弹出栈顶元素
    }

    return result;
}

int main() {
    int num = 5;
    cout &lt;&lt; num &lt;&lt; "! = " &lt;&lt; factorial(num) &lt;&lt; endl;
    return 0;
}
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">5! = 120
</pre><p>在这个非递归实现中，我们用一个栈来存储每次的计算，并通过循环模拟递归的过程。这避免了递归调用时栈溢出的风险，同时提高了程序的可控性。</p><hr /><h3><a name='header-n1280' class='md-header-anchor '></a>总结</h3><ul><li><strong>递归算法</strong>：通过函数自调用来分解问题，通常适合处理具有自相似结构的问题。</li><li><strong>递归工作栈</strong>：递归调用时，函数的状态会被压入栈，返回时恢复状态。栈的深度决定了递归的空间复杂度。</li><li><strong>递归效率分析</strong>：递归算法可能会存在重复计算，特别是在没有优化时。时间复杂度通常与递归的深度和分支数相关。</li><li><strong>递归转非递归</strong>：通过显式栈来模拟递归</li></ul><p>调用的过程，从而避免栈溢出和提高控制力。</p><p>理解递归与栈的关系，以及如何将递归转换为非递归算法，对于解决复杂问题至关重要。</p><h3><a name='header-n1298' class='md-header-anchor '></a>3.5 队列的表示和操作的实现</h3><p>队列（Queue）是一种典型的线性数据结构，其遵循先进先出（FIFO, First In First Out）原则。队列有两种常见的表示方式：顺序表示和链式表示。顺序表示常通过数组实现，而链式表示则通过链表实现。</p><p>在本节中，我们将介绍队列的类型定义、顺序表示的循环队列实现，以及链式表示的链队列实现。</p><hr /><h4><a name='header-n1304' class='md-header-anchor '></a>3.5.1 队列的类型定义</h4><p>队列的基本操作包括：</p><ol start='' ><li><strong>入队（Enqueue）</strong>：将元素添加到队列的尾部。</li><li><strong>出队（Dequeue）</strong>：从队列的头部移除元素。</li><li><strong>获取队头元素（Front/Peek）</strong>：查看队列头部的元素，但不移除它。</li><li><strong>判断队列是否为空（isEmpty）</strong>：检查队列是否有元素。</li><li><strong>判断队列是否已满（isFull）</strong>：检查队列是否已达到最大容量。</li></ol><p>队列可以通过两种方式表示：顺序表示和链式表示。下面是队列的基本类型定义。</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">template &lt;typename T&gt;
struct Queue {
    T* data;         // 存储队列元素的数组或链表
    int front;       // 队头指针
    int rear;        // 队尾指针
    int capacity;    // 队列的容量

    // 构造函数
    Queue(int size) {
        data = new T[size];
        front = rear = -1;  // 初始化队列为空
        capacity = size;
    }

    // 析构函数
    ~Queue() {
        delete[] data;
    }

    bool isEmpty() { return front == rear; }
    bool isFull() { return (rear + 1) % capacity == front; }
    void enqueue(const T&amp; value);
    T dequeue();
    T frontElement();
};
</pre><hr /><h4><a name='header-n1327' class='md-header-anchor '></a>3.5.2 循环队列 —— 队列的顺序表示和实现</h4><p><strong>循环队列</strong>是队列的一种特殊表示方法，它通过使用数组实现队列，且队列的尾部连接到头部。当队列满时，队尾指针会回绕到队头，实现数组空间的最大利用。</p><p><strong>循环队列的特点：</strong></p><ul><li><strong>队头指针</strong>：指向队列中的第一个元素。</li><li><strong>队尾指针</strong>：指向队列中的最后一个元素的下一个位置。</li><li><strong>数组空间利用</strong>：使用模运算（<code>%</code>）来实现循环的效果。</li></ul><p><strong>循环队列的顺序实现：</strong></p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

template &lt;typename T&gt;
class CircularQueue {
private:
    T* data;       // 存储队列元素的数组
    int front;     // 队头指针
    int rear;      // 队尾指针
    int capacity;  // 队列容量

public:
    // 构造函数
    CircularQueue(int size) {
        data = new T[size];
        front = rear = 0;  // 初始化队列为空
        capacity = size;
    }

    // 析构函数
    ~CircularQueue() {
        delete[] data;
    }

    // 判断队列是否为空
    bool isEmpty() {
        return front == rear;
    }

    // 判断队列是否已满
    bool isFull() {
        return (rear + 1) % capacity == front;
    }

    // 入队操作
    void enqueue(const T&amp; value) {
        if (isFull()) {
            cout &lt;&lt; "Queue is full!" &lt;&lt; endl;
            return;
        }
        data[rear] = value;  // 将元素添加到队尾
        rear = (rear + 1) % capacity;  // 更新队尾指针
    }

    // 出队操作
    T dequeue() {
        if (isEmpty()) {
            cout &lt;&lt; "Queue is empty!" &lt;&lt; endl;
            return T();  // 返回默认值
        }
        T value = data[front];  // 获取队头元素
        front = (front + 1) % capacity;  // 更新队头指针
        return value;  // 返回出队的元素
    }

    // 获取队头元素
    T frontElement() {
        if (isEmpty()) {
            cout &lt;&lt; "Queue is empty!" &lt;&lt; endl;
            return T();  // 返回默认值
        }
        return data[front];  // 返回队头元素
    }

    // 打印队列中的元素
    void printQueue() {
        if (isEmpty()) {
            cout &lt;&lt; "Queue is empty!" &lt;&lt; endl;
            return;
        }
        int i = front;
        while (i != rear) {
            cout &lt;&lt; data[i] &lt;&lt; " ";
            i = (i + 1) % capacity;  // 采用模运算循环访问队列元素
        }
        cout &lt;&lt; endl;
    }
};

int main() {
    CircularQueue&lt;int&gt; queue(5);  // 创建一个容量为 5 的循环队列

    queue.enqueue(10);
    queue.enqueue(20);
    queue.enqueue(30);
    queue.enqueue(40);
    queue.enqueue(50);

    queue.printQueue();  // 打印队列中的元素

    queue.dequeue();
    queue.printQueue();  // 弹出队头元素并打印队列中的元素

    queue.enqueue(60);  // 入队新元素
    queue.printQueue();  // 打印队列中的元素

    return 0;
}
</pre><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">10 20 30 40 50 
20 30 40 50 
20 30 40 50 60 
</pre><p><strong>代码说明：</strong></p><ul><li><strong>入队（enqueue）</strong>：将元素添加到队尾，并更新队尾指针。使用 <code>(rear + 1) % capacity</code> 来实现循环。</li><li><strong>出队（dequeue）</strong>：从队头移除元素，并更新队头指针。</li><li><strong>队列为空检查（isEmpty）</strong>：当队头指针与队尾指针相同，表示队列为空。</li><li><strong>队列已满检查（isFull）</strong>：当队尾指针的下一个位置与队头指针相同，表示队列已满。</li><li><strong>打印队列</strong>：从队头到队尾打印队列中的元素，使用 <code>(i + 1) % capacity</code> 来访问队列。</li></ul><hr /><h4><a name='header-n1367' class='md-header-anchor '></a>3.5.3 链队列 —— 队列的链式表示和实现</h4><p><strong>链队列</strong>是通过链表实现的队列，不需要事先确定大小。链队列的每个节点包含队列元素和指向下一个节点的指针。</p><p><strong>链队列的特点：</strong></p><ul><li><strong>队头指针</strong>：指向队列中的第一个节点。</li><li><strong>队尾指针</strong>：指向队列中的最后一个节点。</li></ul><p><strong>链队列的实现：</strong></p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 链表节点
template &lt;typename T&gt;
struct Node {
    T data;           // 队列元素
    Node* next;       // 指向下一个节点
};

// 链队列类
template &lt;typename T&gt;
class LinkQueue {
private:
    Node&lt;T&gt;* front;   // 队头指针
    Node&lt;T&gt;* rear;    // 队尾指针

public:
    // 构造函数
    LinkQueue() {
        front = rear = nullptr;  // 初始化队列为空
    }

    // 析构函数
    ~LinkQueue() {
        while (!isEmpty()) {
            dequeue();  // 释放队列中的所有节点
        }
    }

    // 判断队列是否为空
    bool isEmpty() {
        return front == nullptr;
    }

    // 入队操作
    void enqueue(const T&amp; value) {
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;{value, nullptr};  // 创建新节点
        if (isEmpty()) {
            front = rear = newNode;  // 队列为空时，新节点既是队头也是队尾
        } else {
            rear-&gt;next = newNode;  // 队尾节点的 next 指向新节点
            rear = newNode;        // 更新队尾指针
        }
    }

    // 出队操作
    T dequeue() {
        if (isEmpty()) {
            cout &lt;&lt; "Queue is empty!" &lt;&lt; endl;
            return T();  // 返回默认值
        }
        Node&lt;T&gt;* temp = front;  // 保存队头节点
        T value = front-&gt;data;  // 获取队头元素
        front = front-&gt;next;    // 更新队头指针
        if (front == nullptr) { // 队列为空时，更新队尾指针
            rear = nullptr;
        }
        delete temp;  // 释放队头节点
        return value;  // 返回出队的元素
    }

    // 获取队头元素
    T frontElement() {
        if (isEmpty()) {
            cout &lt;&lt; "Queue is empty!" &lt;&lt; endl;
            return T();  // 返回默认值
        }
        return front-&gt;data;
</pre><p>&nbsp;</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">// 返回队头元素}
// 打印队列中的元素
void printQueue() {
    if (isEmpty()) {
        cout &lt;&lt; "Queue is empty!" &lt;&lt; endl;
        return;
    }
    Node&lt;T&gt;* temp = front;
    while (temp != nullptr) {
        cout &lt;&lt; temp-&gt;data &lt;&lt; " ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; endl;
}
};

int main() {LinkQueue queue;  // 创建链队列

</pre><pre class="md-fences mock-cm md-end-block" lang="">queue.enqueue(10);
queue.enqueue(20);
queue.enqueue(30);
queue.enqueue(40);

queue.printQueue();  // 打印队列中的元素

queue.dequeue();
queue.printQueue();  // 弹出队头元素并打印队列中的元素

return 0;
}
</pre><p>&nbsp;</p><p><strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">10 20 30 4020 30 40
</pre><p>&nbsp;</p><p><strong>代码说明：</strong></p><ul><li><strong>入队（enqueue）</strong>：创建新节点，并将其添加到队列的尾部。如果队列为空，则新节点同时是队头和队尾。</li><li><strong>出队（dequeue）</strong>：移除队头节点，并返回该节点的值。如果队列为空，则输出提示。</li><li><strong>打印队列</strong>：从队头开始，逐一访问链表中的元素。</li></ul><hr /><h3><a name='header-n1406' class='md-header-anchor '></a>总结</h3><ol start='' ><li><p><strong>循环队列</strong>：通过数组实现，队列的尾部连接到头部，有效地利用了数组空间。适合用于固定容量的队列应用。</p></li><li><p><strong>链队列</strong>：通过链表实现，队列大小动态变化，适合用于容量不确定的队列应用。</p><p>​</p></li></ol><h2><a name='header-n1416' class='md-header-anchor '></a>第 4 章 串、数组和广义表</h2><p>在本章中，我们将探讨与字符串、数组以及广义表相关的内容。我们将从基本概念出发，逐步深入，介绍它们的定义、存储结构以及常见操作，尤其是如何处理字符串相关的算法和技术。</p><hr /><h3><a name='header-n1420' class='md-header-anchor '></a>4.1 串的定义</h3><p><strong>串（String）</strong>是由零个或多个字符组成的有限序列，通常用于表示文本数据。在计算机中，串是字符的有序集合，通常用一维数组或链表来表示。</p><p>串的基本操作包括：</p><ol start='' ><li><strong>串的连接（Concatenation）</strong>：将两个串合并成一个串。</li><li><strong>串的长度（Length）</strong>：获取串中字符的个数。</li><li><strong>串的比较（Comparison）</strong>：判断两个串是否相等，或者哪个串更大。</li><li><strong>串的模式匹配（Pattern Matching）</strong>：查找子串的位置。</li></ol><p>在一些编程语言中，串是一个数据类型，如Python中的<code>str</code>类型，而在C/C++中，串通常由字符数组表示。</p><hr /><h3><a name='header-n1441' class='md-header-anchor '></a>4.2 案例引入</h3><p>假设我们有一个文本文件，其中包含一些句子和单词。我们想要实现一个简单的应用程序，该程序能够实现以下功能：</p><ol start='' ><li><strong>统计单词出现的次数</strong>。</li><li><strong>在字符串中查找特定的单词</strong>。</li><li><strong>替换字符串中的某些部分</strong>。</li></ol><p>为了完成这些任务，我们需要对字符串的存储结构和操作有一个深入的理解。</p><hr /><h3><a name='header-n1457' class='md-header-anchor '></a>4.3 串的类型定义、存储结构及其运算</h3><p>在本节中，我们将详细介绍字符串的抽象类型定义、存储结构以及常见的字符串运算。</p><h5><a name='header-n1460' class='md-header-anchor '></a>4.3.1 串的抽象类型定义</h5><p>串作为一种数据类型，其抽象定义包括以下几个方面：</p><ul><li><p><strong>定义</strong>：串是由若干字符组成的有限序列。</p></li><li><p>基本操作</p><p>：</p><ul><li><strong>长度（Length）</strong>：计算串的长度。</li><li><strong>连接（Concatenate）</strong>：将两个串连接成一个新的串。</li><li><strong>获取字符</strong>：获取串中的某个字符。</li><li><strong>模式匹配</strong>：查找子串的位置。</li></ul></li></ul><p>C++中可以通过类来实现一个串的抽象数据类型。以下是一个简单的串的类定义：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

class String {
private:
    char* str;  // 存储字符串的指针
    int length; // 字符串长度

public:
    // 构造函数
    String(const char* s) {
        length = strlen(s);
        str = new char[length + 1];  // 为字符串分配内存
        strcpy(str, s);  // 复制字符串
    }

    // 析构函数
    ~String() {
        delete[] str;  // 释放分配的内存
    }

    // 获取字符串长度
    int getLength() const {
        return length;
    }

    // 获取字符串内容
    const char* getString() const {
        return str;
    }

    // 串的连接操作
    String concatenate(const String&amp; other) {
        int newLength = length + other.getLength();
        char* newStr = new char[newLength + 1];
        strcpy(newStr, str);
        strcat(newStr, other.getString());  // 连接两个字符串
        return String(newStr);
    }

    // 串的比较操作
    bool compare(const String&amp; other) {
        return strcmp(str, other.getString()) == 0;  // 字符串比较
    }

    // 打印字符串
    void print() const {
        cout &lt;&lt; str &lt;&lt; endl;
    }
};

int main() {
    String s1("Hello");
    String s2(" World");
    String s3 = s1.concatenate(s2);

    s1.print();  // 输出：Hello
    s2.print();  // 输出： World
    s3.print();  // 输出：Hello World

    return 0;
}
</pre><p><strong>代码说明：</strong></p><ul><li><code>String</code> 类定义了字符串的基本操作，如获取长度、连接字符串、比较两个字符串等。</li><li><code>concatenate()</code> 方法将两个字符串连接成一个新的字符串。</li><li><code>compare()</code> 方法比较两个字符串是否相等。</li></ul><hr /><h4><a name='header-n1501' class='md-header-anchor '></a>4.3.2 串的存储结构</h4><p>在计算机中，串通常通过以下两种方式存储：</p><ol start='' ><li><p><strong>顺序存储（数组）</strong>：</p><ul><li>串可以通过一个字符数组存储，字符数组的长度表示串的长度，数组的每个元素表示串中的一个字符。</li><li>优点：存储和访问方便。</li><li>缺点：无法动态增长，空间利用率不高，尤其是对于动态长度的字符串。</li></ul></li><li><p><strong>链式存储（链表）</strong>：</p><ul><li>通过链表来存储字符串，其中每个节点存储一个字符和指向下一个节点的指针。</li><li>优点：能够动态地存储字符串，适合处理变长字符串。</li><li>缺点：访问较慢，空间开销大。</li></ul></li></ol><p><strong>顺序存储的示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">char str[] = "Hello, World!";
</pre><p><strong>链式存储的示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">struct Node {
    char data;
    Node* next;
};

Node* createNode(char c) {
    Node* newNode = new Node();
    newNode-&gt;data = c;
    newNode-&gt;next = nullptr;
    return newNode;
}
</pre><hr /><h4><a name='header-n1538' class='md-header-anchor '></a>4.3.3 串的模式匹配算法</h4><p>模式匹配算法的目的是在一个串（文本串）中查找另一个串（模式串）的出现位置。常见的模式匹配算法包括：</p><ol start='' ><li><p>朴素算法</p><p>：</p><ul><li>通过从文本串的每个位置开始，逐个字符地与模式串进行比较。</li><li>时间复杂度：O(n * m)，其中n是文本串的长度，m是模式串的长度。</li></ul></li></ol><pre class="md-fences mock-cm md-end-block" lang="">int naiveMatch(const char* text, const char* pattern) {
    int n = strlen(text);
    int m = strlen(pattern);
    
    for (int i = 0; i &lt;= n - m; ++i) {
        int j = 0;
        while (j &lt; m &amp;&amp; text[i + j] == pattern[j]) {
            ++j;
        }
        if (j == m) return i;  // 找到匹配，返回位置
    }
    return -1;  // 未找到匹配
}
</pre><ol start='' ><li><p>KMP算法</p><p>（Knuth-Morris-Pratt算法）：</p><ul><li>通过预处理模式串，构造一个部分匹配表，避免重复比较。</li><li>时间复杂度：O(n + m)，大大优化了朴素算法。</li></ul></li></ol><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">void computePrefixFunction(const char* pattern, int* pi) {
    int m = strlen(pattern);
    pi[0] = 0;
    for (int i = 1, j = 0; i &lt; m; ++i) {
        while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) {
            j = pi[j - 1];
        }
        if (pattern[i] == pattern[j]) {
            ++j;
        }
        pi[i] = j;
    }
}

int KMPMatch(const char* text, const char* pattern) {
    int n = strlen(text);
    int m = strlen(pattern);
    int* pi = new int[m];
    computePrefixFunction(pattern, pi);

    for (int i = 0, j = 0; i &lt; n; ++i) {
        while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) {
            j = pi[j - 1];
        }
        if (text[i] == pattern[j]) {
            ++j;
        }
        if (j == m) {
            delete[] pi;
            return i - m + 1;  // 返回匹配位置
        }
    }
    delete[] pi;
    return -1;  // 未找到匹配
}
</pre><hr /><h3><a name='header-n1570' class='md-header-anchor '></a>小结</h3><p>在本章中，我们深入探讨了串的定义、存储结构和常见操作。通过学习串的抽象类型定义、存储方式以及模式匹配算法，我们掌握了如何有效地处理和操作字符串数据。在实际应用中，选择合适的存储结构和算法可以大大提高程序的性能和可扩展性。</p><h3><a name='header-n1573' class='md-header-anchor '></a>4.4 数组</h3><p>数组（Array）是一种线性数据结构，用于存储一组相同类型的元素。数组在内存中是连续存储的，可以通过索引直接访问任何一个元素。在本节中，我们将探讨数组的类型定义、顺序存储方式以及特殊矩阵的压缩存储。</p><hr /><h4><a name='header-n1577' class='md-header-anchor '></a>4.4.1 数组的类型定义</h4><p>数组的基本特点是能够存储多个同类型元素，并通过索引（下标）访问这些元素。数组在大多数编程语言中都有一种类似的定义方式。</p><h5><a name='header-n1580' class='md-header-anchor '></a>数组的定义：</h5><ul><li><strong>一维数组</strong>：一维数组是最简单的数组类型，可以视为一个元素线性排列的集合。</li><li><strong>多维数组</strong>：二维数组或三维数组是更复杂的数组，通常用于表示表格数据或更高维的数据结构。</li></ul><h5><a name='header-n1588' class='md-header-anchor '></a>C++ 中的数组定义：</h5><ol start='' ><li><strong>一维数组</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">int arr[5];  // 定义一个包含5个整数元素的一维数组
</pre><ol start='' ><li><strong>二维数组</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">int arr[3][4];  // 定义一个3行4列的二维数组
</pre><ol start='' ><li><strong>动态数组</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">int* arr = new int[5];  // 动态分配一个包含5个整数元素的一维数组
</pre><ol start='' ><li><strong>数组初始化</strong>：</li></ol><pre class="md-fences mock-cm md-end-block" lang="">int arr[5] = {1, 2, 3, 4, 5};  // 定义并初始化一维数组
int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};  // 初始化二维数组
</pre><hr /><h4><a name='header-n1610' class='md-header-anchor '></a>4.4.2 数组的顺序存储</h4><p>数组的<strong>顺序存储</strong>是指数组中的元素在内存中是连续存储的，这使得数组在访问时具有较高的效率。顺序存储结构是数组的最基本存储方式，适用于元素个数固定且需要高效访问的场景。</p><h5><a name='header-n1613' class='md-header-anchor '></a>数组顺序存储的特点：</h5><ol start='' ><li><strong>访问速度快</strong>：由于数组元素在内存中是连续存储的，可以通过下标直接访问任意元素，时间复杂度为 O(1)。</li><li><strong>固定大小</strong>：数组的大小在声明时确定，无法动态调整（对于静态数组而言）。</li><li><strong>内存连续性</strong>：数组的所有元素在内存中是紧密排列的，减少了内存碎片，但也可能造成内存的浪费。</li><li><strong>插入删除效率低</strong>：数组中的元素插入和删除操作通常需要移动大量数据，时间复杂度为 O(n)。</li></ol><h5><a name='header-n1627' class='md-header-anchor '></a>顺序存储的操作：</h5><ol start='' ><li><p><strong>访问数组元素</strong>：通过数组下标直接访问元素。</p><pre class="md-fences mock-cm md-end-block" lang="">int arr[5] = {1, 2, 3, 4, 5};
int x = arr[2];  // 访问数组中下标为 2 的元素，值为 3
</pre></li><li><p><strong>遍历数组</strong>：通过循环遍历数组中的元素。</p><pre class="md-fences mock-cm md-end-block" lang="">for (int i = 0; i &lt; 5; ++i) {
    cout &lt;&lt; arr[i] &lt;&lt; " ";
}
</pre></li><li><p><strong>修改数组元素</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">arr[3] = 10;  // 修改数组中下标为 3 的元素，值为 10
</pre></li><li><p><strong>多维数组的顺序存储</strong>：</p><ul><li>多维数组在内存中是按照<strong>行优先</strong>的顺序存储的，即先存储第一行，后存储第二行，依此类推。</li><li>例如，二维数组 <code>arr[3][4]</code> 将会按顺序存储为一维数组 <code>arr[0][0], arr[0][1], arr[0][2], arr[0][3], arr[1][0], ...</code>。</li></ul><pre class="md-fences mock-cm md-end-block" lang="">int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
// 内存中存储顺序为：1 2 3 4 5 6
</pre></li></ol><h5><a name='header-n1652' class='md-header-anchor '></a>数组的存储示意图：</h5><pre class="md-fences mock-cm md-end-block" lang="">int arr[4] = {10, 20, 30, 40};
// 内存布局（假设数组在内存的起始地址为1000）：
地址 1000 | 1004 | 1008 | 1012
值     10   |  20  |  30  |  40
</pre><hr /><h4><a name='header-n1655' class='md-header-anchor '></a>4.4.3 特殊矩阵的压缩存储</h4><p>特殊矩阵是指某些矩阵具有稀疏性，即矩阵中的大部分元素为零。为了节省存储空间，可以使用<strong>压缩存储</strong>技术，仅保存非零元素及其位置。这种技术通常用于<strong>稀疏矩阵</strong>的存储，能够大幅减少内存开销。</p><h5><a name='header-n1658' class='md-header-anchor '></a>常见的压缩存储方法：</h5><ol start='' ><li><p><strong>压缩行存储（CSR, Compressed Sparse Row）</strong>：</p><ul><li>只存储非零元素的值、每行非零元素的开始位置以及每个非零元素所在的列索引。</li><li>适用于按行访问较频繁的稀疏矩阵。</li></ul></li><li><p><strong>压缩列存储（CSC, Compressed Sparse Column）</strong>：</p><ul><li>类似于CSR，但存储的是列索引而不是行索引。</li><li>适用于按列访问较频繁的稀疏矩阵。</li></ul></li><li><p><strong>坐标列表（COO, Coordinate List）</strong>：</p><ul><li>存储矩阵的非零元素以及它们的行和列坐标，适用于某些稀疏矩阵的快速操作。</li></ul></li></ol><h5><a name='header-n1687' class='md-header-anchor '></a>例：压缩行存储（CSR）</h5><p>假设我们有如下稀疏矩阵：</p><pre class="md-fences mock-cm md-end-block" lang="">0  0  0  3  0
0  0  0  0  0
0  0  0  0  2
5  0  0  0  0
</pre><p>对于这个矩阵，我们可以用压缩行存储来保存其非零元素。</p><ol start='' ><li><strong>非零元素的值</strong>：<code>3, 2, 5</code></li><li><strong>每行非零元素的开始位置</strong>：<code>0, 3, 4, 5</code>（分别表示每行的第一个非零元素在值数组中的位置）</li><li><strong>每个非零元素所在的列索引</strong>：<code>3, 4, 0</code>（表示每个非零元素所在的列）</li></ol><pre class="md-fences mock-cm md-end-block" lang="">// CSR存储格式：
int values[] = {3, 2, 5};      // 非零元素值
int columnIndices[] = {3, 4, 0};  // 非零元素列索引
int rowPointers[] = {0, 3, 4, 5};  // 每行非零元素的开始位置

// 稀疏矩阵的压缩存储可以节省大量内存空间
</pre><h5><a name='header-n1704' class='md-header-anchor '></a>代码示例：使用CSR压缩存储稀疏矩阵</h5><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

class SparseMatrix {
private:
    int* values;         // 非零元素值
    int* columnIndices;  // 列索引
    int* rowPointers;    // 行指针

    int numRows, numCols, numNonZero;

public:
    SparseMatrix(int rows, int cols, int nonZero) {
        numRows = rows;
        numCols = cols;
        numNonZero = nonZero;
        
        values = new int[nonZero];
        columnIndices = new int[nonZero];
        rowPointers = new int[rows + 1];
    }

    ~SparseMatrix() {
        delete[] values;
        delete[] columnIndices;
        delete[] rowPointers;
    }

    // 设置矩阵的值、列索引和行指针
    void setData(int* vals, int* cols, int* rows) {
        for (int i = 0; i &lt; numNonZero; ++i) {
            values[i] = vals[i];
            columnIndices[i] = cols[i];
        }
        for (int i = 0; i &lt;= numRows; ++i) {
            rowPointers[i] = rows[i];
        }
    }

    // 打印压缩存储的矩阵
    void print() {
        cout &lt;&lt; "Values: ";
        for (int i = 0; i &lt; numNonZero; ++i) {
            cout &lt;&lt; values[i] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;

        cout &lt;&lt; "Column Indices: ";
        for (int i = 0; i &lt; numNonZero; ++i) {
            cout &lt;&lt; columnIndices[i] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;

        cout &lt;&lt; "Row Pointers: ";
        for (int i = 0; i &lt;= numRows; ++i) {
            cout &lt;&lt; rowPointers[i] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
  };

int main() {int values[] = {3, 2, 5};int columnIndices[] = {3, 4, 0};int rowPointers[] = {0, 3, 4, 5};
SparseMatrix mat(4, 5, 3);
mat.setData(values, columnIndices, rowPointers);
mat.print();

return 0;

}

</pre><p>&nbsp;</p><p>&nbsp;</p><p>  <strong>输出示例：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">  Values: 3 2 5Column Indices: 3 4 0Row Pointers: 0 3 4 5
</pre><p>&nbsp;</p><hr /><h3><a name='header-n1717' class='md-header-anchor '></a>小结</h3><p>  在本节中，我们深入探讨了数组的类型定义、顺序存储方式以及稀疏矩阵的压缩存储方法。通过顺序存储和压缩存储技术，我们可以有效地存储和访问不同类型的数据，特别是在处理稀疏矩阵时，压缩存储方法能够显著节省内存。</p><h3><a name='header-n1720' class='md-header-anchor '></a>4.5 广义表</h3><p>广义表（Generalized List，简称GL）是一种递归的数据结构，可以看作是一个包含原子元素和/或子表的表。在广义表中，表的元素不仅可以是数据项（如整数、字符等），还可以是其他广义表，形成一种递归嵌套结构。广义表是一种扩展了线性表（如数组、链表）概念的数据结构。</p><p>广义表常用于 Lisp 等编程语言中，支持数据的动态结构变化。其灵活性使得它能够表示复杂的树形结构，适用于表达各种递归结构的数据，如解析表达式、树形结构的表示等。</p><p>在本节中，我们将介绍广义表的定义、存储结构，并给出相关的实现示例。</p><hr /><h4><a name='header-n1728' class='md-header-anchor '></a>4.5.1 广义表的定义</h4><p>广义表可以定义为：</p><ul><li><strong>原子元素</strong>：例如，整数、字符等基本数据。</li><li><strong>子表</strong>：包含其他广义表作为元素的表。</li></ul><p>广义表的定义具有递归性质：一个广义表可以包含多个元素，而这些元素可以是原子元素，也可以是其他广义表。广义表可以是<strong>非空表</strong>（包含一个或多个元素）或<strong>空表</strong>（通常用一个空指针表示）。</p><p>广义表的表示方式通常是递归的，因为一个表的元素可能是另一个表。</p><h5><a name='header-n1742' class='md-header-anchor '></a>广义表的例子：</h5><ul><li>空表：<code>()</code> 或者 <code>nil</code></li><li>非空广义表：<code>(1, 2, (3, 4), 5)</code>，这个广义表包含了原子元素 1, 2, 5 和一个子表 <code>(3, 4)</code>。</li></ul><h5><a name='header-n1750' class='md-header-anchor '></a>广义表的操作：</h5><ul><li><strong>首元素（first）</strong>：获取广义表的第一个元素。</li><li><strong>剩余部分（rest）</strong>：获取广义表中去掉第一个元素后的部分。</li><li><strong>判断是否为空表（null）</strong>：判断一个广义表是否为空。</li></ul><p>广义表的递归性质使得它非常适合用链表来实现。</p><hr /><h4><a name='header-n1764' class='md-header-anchor '></a>4.5.2 广义表的存储结构</h4><p>广义表的存储结构是递归的，每个广义表的元素要么是原子元素（如整数、字符），要么是另一个广义表。为此，我们可以通过链表来实现广义表。链表节点可以包含两部分：一个存储元素的指针，另一个是指向下一个元素的指针。如果当前元素是一个子表，它可以指向一个新的广义表。</p><h5><a name='header-n1767' class='md-header-anchor '></a>广义表的链式存储结构：</h5><ol start='' ><li><strong>原子元素</strong>：通常表示为基本数据类型。</li><li><strong>子表</strong>：也是一个广义表，因此是递归结构。</li></ol><p>广义表的链式存储可以采用以下方式实现：</p><ul><li>每个节点可以包含一个<strong>数据域</strong>（存储元素）和一个<strong>指针域</strong>（指向下一个节点或子表）。</li><li>对于子表，指针指向另一个广义表。</li></ul><h5><a name='header-n1784' class='md-header-anchor '></a>广义表节点定义：</h5><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 定义广义表节点
class GList {
public:
    bool isAtom;  // 判断元素是否为原子元素
    union {
        int atom;  // 如果是原子元素，存储数据
        GList* sublist;  // 如果是子表，指向另一个广义表
    };
    GList* next;  // 指向下一个元素

    // 构造原子元素
    GList(int value) {
        isAtom = true;
        atom = value;
        next = nullptr;
    }

    // 构造子表
    GList(GList* list) {
        isAtom = false;
        sublist = list;
        next = nullptr;
    }

    // 添加下一个元素
    void addNext(GList* nextElement) {
        next = nextElement;
    }
};

// 打印广义表
void printGList(GList* list) {
    if (list == nullptr) {
        cout &lt;&lt; "()";
        return;
    }

    cout &lt;&lt; "(";
    while (list != nullptr) {
        if (list-&gt;isAtom) {
            cout &lt;&lt; list-&gt;atom;
        } else {
            printGList(list-&gt;sublist);
        }
        if (list-&gt;next != nullptr) {
            cout &lt;&lt; ", ";
        }
        list = list-&gt;next;
    }
    cout &lt;&lt; ")";
}

int main() {
    // 构建广义表 (1, 2, (3, 4), 5)
    GList* g1 = new GList(1);
    GList* g2 = new GList(2);
    GList* g3 = new GList(3);
    GList* g4 = new GList(4);
    GList* g5 = new GList(5);

    // 创建子表 (3, 4)
    g3-&gt;addNext(g4);
    GList* sublist = new GList(g3);

    // 构建整个广义表
    g1-&gt;addNext(g2);
    g2-&gt;addNext(sublist);
    sublist-&gt;addNext(g5);

    // 打印广义表
    printGList(g1);  // 输出: (1, 2, (3, 4), 5)

    return 0;
}
</pre><h5><a name='header-n1786' class='md-header-anchor '></a>代码解释：</h5><ul><li><p><strong>GList类</strong>：表示广义表的节点。它包含两个主要部分：</p><ul><li><code>isAtom</code>：用于判断当前节点是否为原子元素。</li><li><code>union</code>：使用 <code>union</code> 来存储原子元素或子表。</li><li><code>next</code>：指向下一个节点。</li></ul></li><li><p><strong>构造函数</strong>：</p><ul><li>如果是原子元素，则将 <code>atom</code> 设置为元素值。</li><li>如果是子表，则将 <code>sublist</code> 设置为指向子表的指针。</li></ul></li><li><p><strong>addNext</strong>：用于将下一个元素连接到当前节点。</p></li><li><p><strong>printGList</strong>：递归打印广义表。它会遍历广义表的每一个元素，如果元素是原子，则直接打印；如果是子表，则递归调用 <code>printGList</code> 打印子表。</p></li></ul><hr /><h3><a name='header-n1818' class='md-header-anchor '></a>递归结构的好处</h3><p>广义表的一个重要特点就是其递归结构，这使得它非常适合用链表来表示。每个元素的 <code>next</code> 指针可以指向下一个元素或者子表。通过递归处理子表，广义表能够灵活地表示和处理树形结构、层次结构等复杂数据。</p><p>广义表的操作可以通过递归函数来实现，例如：</p><ol start='' ><li>获取广义表的首元素（first）。</li><li>获取广义表的剩余部分（rest）。</li><li>判断广义表是否为空。</li></ol><p>这种递归处理的方式非常简洁，并且易于扩展。</p><hr /><h3><a name='header-n1836' class='md-header-anchor '></a>小结</h3><p>在本节中，我们讨论了广义表的定义、存储结构以及如何在 C++ 中实现广义表。广义表是一个递归的数据结构，可以包含原子元素和子表，通过链表存储来实现。通过递归操作，广义表能够灵活地表示各种层次结构和树形结构，是处理复杂数据结构的强大工具。</p><h3><a name='header-n1839' class='md-header-anchor '></a>第 5 章 树和二叉树</h3><p>树和二叉树是两种非常重要的非线性数据结构，它们广泛应用于各种领域，如计算机图形学、数据库管理、文件系统等。在本章中，我们将详细介绍树和二叉树的定义、基本术语以及如何在 C++ 中实现这些数据结构。</p><hr /><h4><a name='header-n1843' class='md-header-anchor '></a>5.1 树和二叉树的定义</h4><p>树是由节点组成的非线性数据结构，每个节点包含数据元素和指向子节点的指针。树的应用广泛，如文件系统、决策树等。二叉树是树的一种特殊形式，其中每个节点最多有两个子节点。</p><hr /><h5><a name='header-n1847' class='md-header-anchor '></a>5.1.1 树的定义</h5><p><strong>树（Tree）</strong> 是一种由若干节点组成的集合，并满足以下两个条件：</p><ol start='' ><li><strong>根节点</strong>：树有一个特定的节点称为根节点。</li><li><strong>节点</strong>：每个节点包含一个数据元素，并且可以有多个子节点。</li></ol><p>树是一个递归结构，根节点下面可以有若干个子树，这些子树本身也是树。树的基本特点是每个节点都可能有多个子节点，但通常没有循环。</p><h5><a name='header-n1859' class='md-header-anchor '></a>树的基本术语：</h5><ol start='' ><li><strong>根节点（Root）</strong>：树的最上层节点。</li><li><strong>节点（Node）</strong>：树中的元素，每个节点包含数据和指向子节点的指针。</li><li><strong>父节点（Parent）</strong>：节点直接连接的上级节点。</li><li><strong>子节点（Child）</strong>：一个节点的直接后代。</li><li><strong>叶节点（Leaf）</strong>：没有子节点的节点。</li><li><strong>高度（Height）</strong>：树的最大层数。</li><li><strong>深度（Depth）</strong>：节点到根节点的路径长度。</li><li><strong>兄弟节点（Sibling）</strong>：同一个父节点的其他节点。</li></ol><p>树的广泛应用包括：</p><ul><li><strong>文件系统</strong>：文件夹包含子文件夹和文件，每个文件夹都是一个子树。</li><li><strong>XML 文档</strong>：文档的元素可以形成树状结构。</li><li><strong>决策树</strong>：机器学习中的决策树用于分类任务。</li></ul><hr /><h5><a name='header-n1898' class='md-header-anchor '></a>5.1.2 树的基本术语</h5><p>除了根节点、父节点、子节点等基本术语外，树的深度、高度以及节点的度（每个节点的子节点个数）也是树的基本术语。</p><ul><li><strong>度（Degree）</strong>：一个节点的子节点数量。</li><li><strong>树的深度（Depth of a tree）</strong>：从根节点到叶节点的最长路径上的边数。</li><li><strong>树的高度（Height of a tree）</strong>：树中所有节点的最大深度。</li></ul><h5><a name='header-n1911' class='md-header-anchor '></a>例：树的示意图</h5><pre class="md-fences mock-cm md-end-block" lang="">          A           &lt;- 根节点
        /   \
       B     C        &lt;- 子节点
      / \   / \
     D   E F   G      &lt;- 叶节点
</pre><ul><li>根节点：A</li><li>A的子节点：B, C</li><li>B的子节点：D, E</li><li>C的子节点：F, G</li><li>叶节点：D, E, F, G</li><li>高度：3（根节点A到叶节点的最长路径）</li><li>深度：根节点深度为0，节点B的深度为1，节点D的深度为2</li></ul><hr /><h5><a name='header-n1936' class='md-header-anchor '></a>5.1.3 二叉树的定义</h5><p><strong>二叉树（Binary Tree）</strong> 是一种特殊的树，其中每个节点最多只能有两个子节点，通常这两个子节点被称为<strong>左子节点</strong>和<strong>右子节点</strong>。二叉树是一种非常重要的数据结构，广泛应用于表达式解析、搜索树等领域。</p><p>二叉树的定义：</p><ul><li>每个节点最多有两个子节点。</li><li>每个节点包含一个数据元素及指向其左、右子节点的指针。</li></ul><p>二叉树的应用包括：</p><ul><li><strong>二叉查找树（BST）</strong>：一种特殊的二叉树，用于快速查找、插入和删除操作。</li><li><strong>堆（Heap）</strong>：二叉树的一种特殊形式，用于实现优先队列。</li></ul><h5><a name='header-n1957' class='md-header-anchor '></a>二叉树的性质：</h5><ol start='' ><li><strong>满二叉树（Full Binary Tree）</strong>：每个节点要么是叶子节点，要么有两个子节点。</li><li><strong>完全二叉树（Complete Binary Tree）</strong>：除了最后一层，其他每一层都是满的，且最后一层的节点都在左侧。</li><li><strong>平衡二叉树（Balanced Binary Tree）</strong>：任何节点的左右子树的高度差不超过1。</li></ol><hr /><h4><a name='header-n1969' class='md-header-anchor '></a>5.2 案例引入</h4><p>在了解了树和二叉树的定义及其基本术语后，接下来我们将通过 C++ 实现一个简单的树和二叉树。通过代码示例，您将能够更好地理解这些数据结构的实际应用。</p><hr /><h3><a name='header-n1973' class='md-header-anchor '></a>代码示例：树的实现</h3><p>我们将首先实现一个简单的树结构，然后实现二叉树。</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// 树的节点定义
class TreeNode {
public:
    int data;              // 节点的数据
    vector&lt;TreeNode*&gt; children; // 子节点列表

    TreeNode(int value) : data(value) {} // 构造函数

    // 添加子节点
    void addChild(TreeNode* child) {
        children.push_back(child);
    }
};

// 打印树的结构
void printTree(TreeNode* root, int level = 0) {
    if (root == nullptr) return;

    // 打印当前节点的值
    for (int i = 0; i &lt; level; ++i) cout &lt;&lt; "  "; // 缩进
    cout &lt;&lt; root-&gt;data &lt;&lt; endl;

    // 打印所有子节点
    for (TreeNode* child : root-&gt;children) {
        printTree(child, level + 1);
    }
}

int main() {
    // 创建节点
    TreeNode* root = new TreeNode(1);  // 根节点
    TreeNode* child1 = new TreeNode(2);
    TreeNode* child2 = new TreeNode(3);
    TreeNode* child3 = new TreeNode(4);
    
    // 构建树
    root-&gt;addChild(child1);
    root-&gt;addChild(child2);
    child1-&gt;addChild(child3);
    
    // 打印树结构
    printTree(root);

    return 0;
}
</pre><p><strong>输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">1
  2
    4
  3
</pre><p><strong>代码解释：</strong></p><ul><li><code>TreeNode</code> 类：表示树的节点，包含数据和一个子节点列表。</li><li><code>addChild</code> 方法：将子节点添加到当前节点的子节点列表中。</li><li><code>printTree</code> 函数：递归打印树的结构，使用缩进表示树的层次。</li></ul><hr /><h3><a name='header-n1993' class='md-header-anchor '></a>代码示例：二叉树的实现</h3><p>接下来，我们将实现一个简单的二叉树，支持插入节点和遍历操作。</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 二叉树节点定义
class BinaryTreeNode {
public:
    int data;                   // 节点的数据
    BinaryTreeNode* left;        // 左子节点
    BinaryTreeNode* right;       // 右子节点

    BinaryTreeNode(int value) : data(value), left(nullptr), right(nullptr) {} // 构造函数
};

// 前序遍历
void preOrderTraversal(BinaryTreeNode* root) {
    if (root == nullptr) return;
    cout &lt;&lt; root-&gt;data &lt;&lt; " ";  // 访问根节点
    preOrderTraversal(root-&gt;left);  // 递归遍历左子树
    preOrderTraversal(root-&gt;right); // 递归遍历右子树
}

// 中序遍历
void inOrderTraversal(BinaryTreeNode* root) {
    if (root == nullptr) return;
    inOrderTraversal(root-&gt;left);   // 递归遍历左子树
    cout &lt;&lt; root-&gt;data &lt;&lt; " ";      // 访问根节点
    inOrderTraversal(root-&gt;right);  // 递归遍历右子树
}

// 后序遍历
void postOrderTraversal(BinaryTreeNode* root) {
    if (root == nullptr) return;
    postOrderTraversal(root-&gt;left);  // 递归遍历左子树
    postOrderTraversal(root-&gt;right); // 递归遍历右子树
    cout &lt;&lt; root-&gt;data &lt;&lt; " ";       // 访问根节点
}

int main() {
    // 创建节点
    BinaryTreeNode* root = new BinaryTreeNode(1);
    root-&gt;left = new BinaryTreeNode(2);
    root-&gt;right = new BinaryTreeNode(3);
    root-&gt;left-&gt;left = new BinaryTreeNode(4);
    root-&gt;left-&gt;right = new BinaryTreeNode(5);
    
    // 打印二叉树的遍历
    cout &lt;&lt; "Preorder Traversal: ";
    preOrderTraversal(root);
    cout &lt;&lt; endl;

    cout &lt;&lt; "Inorder Traversal: ";
    inOrderTraversal(root);
    cout &lt;&lt; endl;

    cout &lt;&lt; "Postorder Traversal: ";
    postOrderTraversal(root);
    cout &lt;&lt; endl;

	return 0;
   }        
</pre><p>&nbsp;</p><p><strong>输出：</strong></p><pre class="md-fences mock-cm md-end-block" lang="">Preorder Traversal: 1 2 4 5 3Inorder Traversal: 4 2 5 1 3Postorder Traversal: 4 5 2 3 1
</pre><p><strong>代码解释：</strong></p><ul><li><code>BinaryTreeNode</code> 类：表示二叉树的节点，包含数据、左子节点和右子节点。</li><li><code>preOrderTraversal</code>：前序遍历，访问根节点后递归遍历左右子树。</li><li><code>inOrderTraversal</code>：中序遍历，递归遍历左子树后访问根节点，再递归遍历右子树。</li><li><code>postOrderTraversal</code>：后序遍历，递归遍历左右子树后访问根节点。</li></ul><hr /><h3><a name='header-n2018' class='md-header-anchor '></a>小结</h3><p>本章介绍了树和二叉树的定义及其基本术语，并通过 C++ 实现了树和二叉树的数据结构。树是一种非线性的数据结构，广泛应用于文件系统、决策树等领域；二叉树是一种特殊的树，其中每个节点最多有两个子节点。通过实现二叉树的插入和遍历操作，我们能够更好地理解这些数据结构的工作原理。</p><h3><a name='header-n2021' class='md-header-anchor '></a>5.3 树和二叉树的抽象数据类型定义</h3><p>抽象数据类型（Abstract Data Type，简称ADT）是指数据的定义及其操作的集合。ADT描述了数据的逻辑结构和可以对数据进行的操作，但不涉及数据的具体实现。在本节中，我们将定义树和二叉树的抽象数据类型，并详细讨论它们的操作。</p><hr /><h4><a name='header-n2025' class='md-header-anchor '></a>5.3.1 树的抽象数据类型（ADT）</h4><p>树的抽象数据类型包括节点、子树、根节点等元素及其相关操作。以下是树的基本操作：</p><ol start='' ><li><p><strong>创建树</strong>：</p><ul><li><code>Tree create()</code>: 创建一棵新的空树。</li></ul></li><li><p><strong>插入节点</strong>：</p><ul><li><code>void insert(TreeNode* parent, TreeNode* child)</code>: 向指定的父节点插入一个新的子节点。</li></ul></li><li><p><strong>删除节点</strong>：</p><ul><li><code>void delete(TreeNode* node)</code>: 删除指定的节点。</li></ul></li><li><p><strong>获取树的根节点</strong>：</p><ul><li><code>TreeNode* root()</code>: 返回树的根节点。</li></ul></li><li><p><strong>遍历树</strong>：</p><ul><li><code>void traverse(TreeNode* node)</code>: 遍历树的所有节点，通常为前序、后序或中序遍历。</li></ul></li><li><p><strong>判断树是否为空</strong>：</p><ul><li><code>bool isEmpty()</code>: 判断树是否为空。</li></ul></li><li><p><strong>获取节点的子节点</strong>：</p><ul><li><code>List&lt;TreeNode*&gt; children(TreeNode* node)</code>: 返回一个节点的所有子节点。</li></ul></li><li><p><strong>获取节点的父节点</strong>：</p><ul><li><code>TreeNode* parent(TreeNode* node)</code>: 返回指定节点的父节点。</li></ul></li></ol><h4><a name='header-n2085' class='md-header-anchor '></a>5.3.2 二叉树的抽象数据类型（ADT）</h4><p>二叉树是一种特殊类型的树，其中每个节点最多有两个子节点（通常称为左子节点和右子节点）。二叉树的抽象数据类型包含以下操作：</p><ol start='' ><li><p><strong>创建二叉树</strong>：</p><ul><li><code>BinaryTree create()</code>: 创建一棵空的二叉树。</li></ul></li><li><p><strong>插入节点</strong>：</p><ul><li><code>void insert(BinaryTreeNode* parent, BinaryTreeNode* left, BinaryTreeNode* right)</code>: 向指定的父节点插入左子节点和右子节点。</li></ul></li><li><p><strong>删除节点</strong>：</p><ul><li><code>void delete(BinaryTreeNode* node)</code>: 删除指定节点。</li></ul></li><li><p><strong>获取根节点</strong>：</p><ul><li><code>BinaryTreeNode* root()</code>: 返回二叉树的根节点。</li></ul></li><li><p><strong>遍历二叉树</strong>：</p><ul><li><code>void preOrderTraversal(BinaryTreeNode* node)</code>: 前序遍历。</li><li><code>void inOrderTraversal(BinaryTreeNode* node)</code>: 中序遍历。</li><li><code>void postOrderTraversal(BinaryTreeNode* node)</code>: 后序遍历。</li></ul></li><li><p><strong>判断二叉树是否为空</strong>：</p><ul><li><code>bool isEmpty()</code>: 判断二叉树是否为空。</li></ul></li><li><p><strong>获取节点的左子节点</strong>：</p><ul><li><code>BinaryTreeNode* leftChild(BinaryTreeNode* node)</code>: 获取节点的左子节点。</li></ul></li><li><p><strong>获取节点的右子节点</strong>：</p><ul><li><code>BinaryTreeNode* rightChild(BinaryTreeNode* node)</code>: 获取节点的右子节点。</li></ul></li></ol><hr /><h3><a name='header-n2152' class='md-header-anchor '></a>5.4 二叉树的性质和存储结构</h3><p>在这一节中，我们将讨论二叉树的性质及其常见的存储结构。二叉树是数据结构中的重要类型，具有多种应用，如在搜索树、堆等领域中都有广泛应用。</p><hr /><h4><a name='header-n2156' class='md-header-anchor '></a>5.4.1 二叉树的性质</h4><p>二叉树具有一些基本的性质，了解这些性质有助于更好地理解和实现二叉树。以下是二叉树的主要性质：</p><ol start='' ><li><p><strong>节点数与高度</strong>：</p><ul><li>一个高度为 <code>h</code> 的二叉树，最多有 <code>2^h - 1</code> 个节点。</li><li>二叉树的高度是树中从根节点到最深节点的最长路径上的边数。</li></ul></li><li><p><strong>叶子节点数与总节点数</strong>：</p><ul><li>假设二叉树有 <code>n</code> 个节点，其中 <code>L</code> 个是叶子节点，那么二叉树的内部节点数（非叶节点）为 <code>n - L</code>。而根据性质，叶子节点 <code>L</code> 与非叶节点之间的关系为：
<code>L = (n + 1) / 2</code>。这说明，在一棵完全二叉树中，叶子节点的个数约为总节点数的一半。</li></ul></li><li><p><strong>完全二叉树的性质</strong>：</p><ul><li>完全二叉树是一种特殊的二叉树，其中除了最底层之外，其他每一层的节点数都达到最大值，并且最底层的节点都集中在左侧。</li><li>完全二叉树的节点数为 <code>n</code> 时，其高度为 <code>⌊log₂n⌋</code>。</li></ul></li><li><p><strong>满二叉树的性质</strong>：</p><ul><li>满二叉树是一种特殊的二叉树，其中每个节点都具有两个子节点，且所有叶子节点都在同一层。</li><li>满二叉树的节点数与高度之间有着明确的关系。假设满二叉树的高度为 <code>h</code>，则节点数为 <code>2^h - 1</code>。</li></ul></li><li><p><strong>二叉树的平衡性</strong>：</p><ul><li>平衡二叉树（如 AVL 树、红黑树）是一类特殊的二叉树，它要求任何节点的左右子树高度差不超过 1。平衡二叉树的高度通常是 <code>O(log n)</code>，这使得它们在查找、插入、删除等操作时能够保持较好的效率。</li></ul></li><li><p><strong>二叉树的遍历</strong>：</p><ul><li><p>二叉树有三种基本遍历方式：前序遍历、中序遍历和后序遍历。</p><ul><li><strong>前序遍历</strong>：根节点 → 左子树 → 右子树</li><li><strong>中序遍历</strong>：左子树 → 根节点 → 右子树</li><li><strong>后序遍历</strong>：左子树 → 右子树 → 根节点</li></ul></li></ul></li></ol><hr /><h4><a name='header-n2223' class='md-header-anchor '></a>5.4.2 二叉树的存储结构</h4><p>二叉树的存储结构有两种常见方式：<strong>顺序存储</strong>和<strong>链式存储</strong>。</p><h5><a name='header-n2226' class='md-header-anchor '></a>1. 顺序存储结构</h5><p>顺序存储结构是通过一个数组来存储二叉树。对于树中的每一个节点，我们可以使用数组中的一个元素来表示，数组的下标表示节点的位置。具体规则如下：</p><ul><li>根节点存储在数组的第一个元素（下标为 0）。</li><li>对于一个节点，其左子节点的下标是 <code>2i + 1</code>，右子节点的下标是 <code>2i + 2</code>，父节点的下标是 <code>(i - 1) / 2</code>（假设节点从下标 0 开始）。</li></ul><p>顺序存储适用于完全二叉树或者节点数固定的二叉树，因为其内存连续分配，查找节点的时间复杂度为 O(1)。</p><p><strong>优点</strong>：</p><ul><li>适用于节点数固定且较为均衡的二叉树。</li><li>存储方式简单，访问节点直接通过数组下标。</li></ul><p><strong>缺点</strong>：</p><ul><li>如果树的节点不均匀分布，顺序存储会浪费大量空间。</li><li>插入和删除操作相对复杂，因为涉及到数组的移动。</li></ul><h5><a name='header-n2256' class='md-header-anchor '></a>2. 链式存储结构</h5><p>链式存储结构是通过链表节点来存储二叉树。每个节点包含一个数据元素和两个指针，分别指向其左子节点和右子节点。每个二叉树节点的结构如下：</p><pre class="md-fences mock-cm md-end-block" lang="">struct TreeNode {
    int data;                  // 节点的数据
    TreeNode* left;            // 指向左子节点的指针
    TreeNode* right;           // 指向右子节点的指针

    TreeNode(int value) : data(value), left(nullptr), right(nullptr) {}  // 构造函数
};
</pre><p><strong>优点</strong>：</p><ul><li>动态分配内存，适用于节点数不固定的情况。</li><li>适合实现不规则的树结构（例如，满二叉树、完全二叉树之外的二叉树）。</li></ul><p><strong>缺点</strong>：</p><ul><li>存储开销较大，每个节点需要额外的空间来存储指针。</li><li>访问节点时需要通过指针进行查找，时间复杂度为 O(n)。</li></ul><hr /><h3><a name='header-n2279' class='md-header-anchor '></a>小结</h3><p>在本节中，我们详细讨论了二叉树的性质和存储结构。我们介绍了二叉树的基本性质，如节点数、叶子节点数、高度、平衡性等，同时阐述了二叉树的两种常见存储结构——顺序存储和链式存储。每种存储结构有其优缺点，具体的选择取决于应用场景和二叉树的特点。</p><h3><a name='header-n2282' class='md-header-anchor '></a>5.5.1 遍历二叉树</h3><p>遍历二叉树是访问树中每个节点的过程。二叉树的遍历方式通常有三种：前序遍历、中序遍历和后序遍历。在每种遍历方式中，我们依照不同的顺序访问根节点、左子树和右子树。遍历二叉树不仅有助于理解二叉树的结构，还广泛应用于很多算法和应用程序，如树的排序、搜索等。</p><h4><a name='header-n2285' class='md-header-anchor '></a>1. 前序遍历 (Pre-order Traversal)</h4><p>前序遍历的顺序是：<strong>根节点 → 左子树 → 右子树</strong>。</p><h4><a name='header-n2288' class='md-header-anchor '></a>2. 中序遍历 (In-order Traversal)</h4><p>中序遍历的顺序是：<strong>左子树 → 根节点 → 右子树</strong>。</p><h4><a name='header-n2291' class='md-header-anchor '></a>3. 后序遍历 (Post-order Traversal)</h4><p>后序遍历的顺序是：<strong>左子树 → 右子树 → 根节点</strong>。</p><p>在这三种遍历中，每种遍历都能遍历所有节点，但是访问的顺序不同。</p><hr /><h4><a name='header-n2297' class='md-header-anchor '></a>5.5.1.1 C++ 代码实现</h4><p>我们将在 C++ 中实现二叉树的前序、中序、后序遍历，并使用递归方式来进行遍历。</p><h5><a name='header-n2300' class='md-header-anchor '></a>二叉树的结构和遍历实现</h5><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 二叉树节点定义
struct BinaryTreeNode {
    int data;                   // 节点的数据
    BinaryTreeNode* left;        // 左子节点
    BinaryTreeNode* right;       // 右子节点

    BinaryTreeNode(int value) : data(value), left(nullptr), right(nullptr) {} // 构造函数
};

// 前序遍历
void preOrderTraversal(BinaryTreeNode* root) {
    if (root == nullptr) return; // 如果节点为空，返回
    cout &lt;&lt; root-&gt;data &lt;&lt; " ";   // 访问根节点
    preOrderTraversal(root-&gt;left);  // 递归遍历左子树
    preOrderTraversal(root-&gt;right); // 递归遍历右子树
}

// 中序遍历
void inOrderTraversal(BinaryTreeNode* root) {
    if (root == nullptr) return; // 如果节点为空，返回
    inOrderTraversal(root-&gt;left);   // 递归遍历左子树
    cout &lt;&lt; root-&gt;data &lt;&lt; " ";      // 访问根节点
    inOrderTraversal(root-&gt;right);  // 递归遍历右子树
}

// 后序遍历
void postOrderTraversal(BinaryTreeNode* root) {
    if (root == nullptr) return; // 如果节点为空，返回
    postOrderTraversal(root-&gt;left);  // 递归遍历左子树
    postOrderTraversal(root-&gt;right); // 递归遍历右子树
    cout &lt;&lt; root-&gt;data &lt;&lt; " ";       // 访问根节点
}

int main() {
    // 创建二叉树
    BinaryTreeNode* root = new BinaryTreeNode(1);
    root-&gt;left = new BinaryTreeNode(2);
    root-&gt;right = new BinaryTreeNode(3);
    root-&gt;left-&gt;left = new BinaryTreeNode(4);
    root-&gt;left-&gt;right = new BinaryTreeNode(5);

    // 打印二叉树的遍历
    cout &lt;&lt; "Preorder Traversal: ";
    preOrderTraversal(root);
    cout &lt;&lt; endl;

    cout &lt;&lt; "Inorder Traversal: ";
    inOrderTraversal(root);
    cout &lt;&lt; endl;

    cout &lt;&lt; "Postorder Traversal: ";
    postOrderTraversal(root);
    cout &lt;&lt; endl;

    return 0;
}
</pre><hr /><h4><a name='header-n2303' class='md-header-anchor '></a>5.5.1.2 代码说明</h4><ol start='' ><li><p><strong>节点定义</strong>：</p><ul><li><code>BinaryTreeNode</code> 结构体表示二叉树的节点，其中 <code>data</code> 存储节点的值，<code>left</code> 和 <code>right</code> 分别指向左子节点和右子节点。</li></ul></li><li><p><strong>前序遍历</strong>：</p><ul><li>前序遍历遵循根节点 → 左子树 → 右子树的顺序，递归地访问每个节点。</li></ul></li><li><p><strong>中序遍历</strong>：</p><ul><li>中序遍历遵循左子树 → 根节点 → 右子树的顺序，递归地访问每个节点。</li></ul></li><li><p><strong>后序遍历</strong>：</p><ul><li>后序遍历遵循左子树 → 右子树 → 根节点的顺序，递归地访问每个节点。</li></ul></li></ol><hr /><h4><a name='header-n2334' class='md-header-anchor '></a>5.5.1.3 运行结果</h4><pre class="md-fences mock-cm md-end-block" lang="">Preorder Traversal: 1 2 4 5 3 
Inorder Traversal: 4 2 5 1 3 
Postorder Traversal: 4 5 2 3 1 
</pre><p>在上述代码中，创建了一个简单的二叉树结构，并分别实现了三种遍历方式。通过递归实现遍历，代码简单且易于理解。每个遍历方法都会按特定顺序访问树中的节点，并输出节点的数据。</p><hr /><h3><a name='header-n2339' class='md-header-anchor '></a>5.5.2 线索二叉树</h3><p>线索二叉树（Threaded Binary Tree）是二叉树的一种特殊形式，旨在解决普通二叉树中指向空指针的问题。在线索二叉树中，空指针被“线索”所替代，即通过空指针指向二叉树的前驱或后继节点。</p><h4><a name='header-n2342' class='md-header-anchor '></a>1. 线索二叉树的特点</h4><ul><li><strong>空指针替换为线索</strong>：在普通的二叉树中，叶节点的左右指针为空，而在线索二叉树中，这些空指针会指向节点的前驱或者后继节点。</li><li><strong>前驱指针和后继指针</strong>：线索二叉树中的空左指针指向节点的前驱节点，空右指针指向节点的后继节点。</li><li><strong>中序线索化</strong>：最常见的线索二叉树是中序线索二叉树，它利用空指针指向节点的中序前驱或后继。</li></ul><h4><a name='header-n2353' class='md-header-anchor '></a>2. 线索二叉树的结构定义</h4><p>我们首先定义一个线索二叉树节点的结构体。这个结构体包含了一个标志位，表示当前指针是指向子节点还是指向线索。</p><pre class="md-fences mock-cm md-end-block" lang="">#include &lt;iostream&gt;
using namespace std;

// 线索二叉树节点定义
struct ThreadedBinaryTreeNode {
    int data;                    // 节点的数据
    ThreadedBinaryTreeNode* left;  // 左子节点或前驱节点
    ThreadedBinaryTreeNode* right; // 右子节点或后继节点
    bool leftThread;              // 如果是线索，leftThread 为 true
    bool rightThread;             // 如果是线索，rightThread 为 true

    ThreadedBinaryTreeNode(int value) : data(value), left(nullptr), right(nullptr), leftThread(false), rightThread(false) {} // 构造函数
};
</pre><p>在这个结构中，<code>leftThread</code> 和 <code>rightThread</code> 是布尔值，用来标记左指针和右指针是否为线索。如果为 <code>true</code>，表示该指针不是指向子节点，而是指向前驱或后继节点。</p><hr /><h4><a name='header-n2360' class='md-header-anchor '></a>3. 中序线索化的实现</h4><p>为了更好地理解线索二叉树的实现，我们将实现一个简单的中序线索化操作。中序线索化的目标是遍历树并将空指针（如果有）替换为相应的前驱和后继指针。</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

struct ThreadedBinaryTreeNode {
    int data;
    ThreadedBinaryTreeNode* left;
    ThreadedBinaryTreeNode* right;
    bool leftThread;
    bool rightThread;

    ThreadedBinaryTreeNode(int value) : data(value), left(nullptr), right(nullptr), leftThread(false), rightThread(false) {}
};

// 中序线索化二叉树
void inOrderThread(ThreadedBinaryTreeNode* root) {
    if (!root) return;

    ThreadedBinaryTreeNode* prev = nullptr;  // 用于保存前驱节点
    ThreadedBinaryTreeNode* current = root;

    // 中序遍历
    while (current != nullptr) {
        // 找到最左边的节点
        while (current-&gt;left != nullptr &amp;&amp; !current-&gt;leftThread) {
            current = current-&gt;left;
        }

        // 处理当前节点
        if (prev &amp;&amp; current-&gt;left == nullptr) {
            current-&gt;left = prev;
            current-&gt;leftThread = true;
        }

        cout &lt;&lt; current-&gt;data &lt;&lt; " ";

        if (current-&gt;right == nullptr || current-&gt;rightThread) {
            prev = current;
            current = current-&gt;right;
        } else {
            prev = nullptr;
            current = current-&gt;right;
        }
    }
}

int main() {
    // 创建节点
    ThreadedBinaryTreeNode* root = new ThreadedBinaryTreeNode(1);
    root-&gt;left = new ThreadedBinaryTreeNode(2);
    root-&gt;right = new ThreadedBinaryTreeNode(3);
    root-&gt;left-&gt;left = new ThreadedBinaryTreeNode(4);
    root-&gt;left-&gt;right =
</pre><p>new ThreadedBinaryTreeNode(5);</p><pre class="md-fences mock-cm md-end-block" lang="">// 中序线索化
cout &lt;&lt; "InOrder Traversal (Threaded): ";
inOrderThread(root);
cout &lt;&lt; endl;

return 0;
</pre><p>}</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">---

#### 4. 代码说明

1. **节点结构**：
   - 结构体 `ThreadedBinaryTreeNode` 包含了 `data`、`left`、`right` 等基本信息，以及 `leftThread` 和 `rightThread` 标志，指示是否为线索。

2. **中序线索化操作**：
   - 在遍历二叉树时，空的左指针会指向前驱节点，空的右指针会指向后继节点。

3. **遍历过程**：
   - 我们采用中序遍历的方式，并在遍历过程中将空指针替换为线索。

---

#### 5. 运行结果

​```bash
InOrder Traversal (Threaded): 4 2 5 1 3
</pre><hr /><h3><a name='header-n2371' class='md-header-anchor '></a>小结</h3><ul><li>在本节中，我们介绍了二叉树的三种基本遍历方式：前序遍历、中序遍历和后序遍历，并实现了对应的 C++ 代码。</li><li>另外，我们还介绍了线索二叉树的概念，并实现了一个简单的中序线索化过程，展示了如何通过线索来替代空指针，使二叉树的遍历更加高效。线索二叉树可以在遍历时减少对空指针的判断，并加速树的遍历过程。</li></ul><h3><a name='header-n2379' class='md-header-anchor '></a>5.6 树和森林</h3><p>树和森林是数据结构中非常重要的概念。树是由若干个节点通过边连接而成的非线性数据结构，而森林则是由若干棵树组成的集合。树和森林广泛应用于文件系统、数据库索引、解析树等领域。在这一节中，我们将介绍树的存储结构，森林与二叉树的转换，以及树和森林的遍历方法。</p><hr /><h4><a name='header-n2383' class='md-header-anchor '></a>5.6.1 树的存储结构</h4><p>树的存储结构有两种常见的实现方式：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>。</p><h5><a name='header-n2386' class='md-header-anchor '></a>1. 顺序存储结构</h5><p>顺序存储结构是使用一个数组来存储树的节点。在顺序存储结构中，树的节点之间的父子关系通过数组下标来表示。例如，对于一棵树来说：</p><ul><li>假设树的根节点存储在数组的第一个位置（下标为 0）。</li><li>对于一个节点，其左子节点的下标为 <code>2i + 1</code>，右子节点的下标为 <code>2i + 2</code>（其中 <code>i</code> 是该节点的数组下标）。</li><li>父节点的下标为 <code>(i - 1) / 2</code>（<code>i</code> 为当前节点的数组下标）。</li></ul><p>这种存储方式适用于节点数目固定、结构比较规则的树，特别是完全二叉树。</p><h5><a name='header-n2401' class='md-header-anchor '></a>2. 链式存储结构</h5><p>链式存储结构是通过节点之间的指针来表示树的结构。每个节点包含一个数据域和多个子节点指针。在这种结构中，我们可以为每个节点定义一个<strong>链表</strong>或<strong>链式数组</strong>来存储它的所有子节点。</p><p>对于树的链式存储结构，每个节点的定义通常如下：</p><pre class="md-fences mock-cm md-end-block" lang="">struct TreeNode {
    int data;                  // 节点的数据
    TreeNode* parent;          // 指向父节点的指针
    vector&lt;TreeNode*&gt; children; // 存储子节点的指针集合

    TreeNode(int value) : data(value), parent(nullptr) {}
};
</pre><p>这种结构可以处理任意类型的树（不仅限于二叉树），适用于节点数目不固定、树的形态比较灵活的场景。</p><hr /><h4><a name='header-n2410' class='md-header-anchor '></a>5.6.2 森林与二叉树的转换</h4><p>在数据结构中，森林是若干棵互不相交的树的集合。森林与二叉树之间可以通过一种非常特殊的方式进行转换。通常的做法是将森林转化为一棵二叉树，反之亦然。</p><h5><a name='header-n2413' class='md-header-anchor '></a>1. 森林转二叉树</h5><p>将森林转换为二叉树的基本思想是<strong>通过左子树链表</strong>和<strong>右子树链表</strong>的方式来表示森林。每一棵树的根节点被转换成二叉树的一棵子树。</p><ul><li><strong>左子树</strong>：指向当前节点的第一个子节点。</li><li><strong>右子树</strong>：指向当前节点的右兄弟（即同一父节点的下一个兄弟节点）。</li></ul><p>假设森林由树 <code>T1, T2, ..., Tn</code> 构成，每一棵树 <code>Ti</code> 的根节点变成二叉树的根节点，并且树 <code>Ti</code> 的左子树指向其第一个子节点，右子树指向其右兄弟。</p><h5><a name='header-n2425' class='md-header-anchor '></a>2. 二叉树转森林</h5><p>将二叉树转换为森林的基本思想是将每个二叉树的左子树和右子树分别分解为独立的树，并把左子树和右子树分别作为森林中的元素。根节点作为森林的“父节点”，其左子树变成森林的一棵树，右子树变成森林的另一棵树。</p><p>例如，二叉树的左子树和右子树本身都可以是一个独立的树，这样转换后就得到了一个森林。</p><hr /><h4><a name='header-n2431' class='md-header-anchor '></a>5.6.3 树和森林的遍历</h4><p>树和森林的遍历方式与二叉树的遍历类似，但是有一些额外的细节需要注意。由于森林是多个树的集合，因此遍历森林时，我们需要分别遍历每棵树。</p><h5><a name='header-n2434' class='md-header-anchor '></a>1. 树的遍历</h5><p>树的遍历方式通常有<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>，这些遍历方式和二叉树的遍历方式类似。唯一不同的是，树的节点可以有多个子节点，因此我们需要遍历每个节点的所有子节点。</p><p>以下是树的前序遍历的基本思路：</p><ul><li><p>前序遍历</p><p>（根节点 → 左子树 → 右子树）：</p><ul><li>访问根节点。</li><li>遍历左子树。</li><li>遍历右子树。</li></ul></li></ul><pre class="md-fences mock-cm md-end-block" lang="">void preOrderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    cout &lt;&lt; root-&gt;data &lt;&lt; " "; // 访问根节点
    for (TreeNode* child : root-&gt;children) {
        preOrderTraversal(child); // 遍历每个子节点
    }
}
</pre><h5><a name='header-n2456' class='md-header-anchor '></a>2. 森林的遍历</h5><p>森林的遍历实际上是对森林中每一棵树的遍历。我们可以通过遍历每一棵树来实现森林的遍历。假设森林包含若干棵树 <code>T1, T2, ..., Tn</code>，遍历森林的操作就是遍历每棵树 <code>Ti</code>。</p><pre class="md-fences mock-cm md-end-block" lang="">void traverseForest(vector&lt;TreeNode*&gt; forest) {
    for (TreeNode* tree : forest) {
        preOrderTraversal(tree); // 对每棵树进行遍历
        cout &lt;&lt; endl;  // 每棵树遍历后换行
    }
}
</pre><p>在上面的代码中，我们首先定义了一个 <code>preOrderTraversal</code> 函数来遍历单棵树，然后通过 <code>traverseForest</code> 函数遍历森林中所有的树。</p><hr /><h3><a name='header-n2463' class='md-header-anchor '></a>小结</h3><p>在这一节中，我们讨论了树和森林的相关知识。主要内容包括：</p><ul><li><strong>树的存储结构</strong>：介绍了树的顺序存储和链式存储结构，强调了它们的优缺点。</li><li><strong>森林与二叉树的转换</strong>：讲解了如何将森林转换为二叉树，反之亦然。</li><li><strong>树和森林的遍历</strong>：我们介绍了树的前序遍历，并扩展到森林的遍历，即遍历森林中的每一棵树。</li></ul><h3><a name='header-n2476' class='md-header-anchor '></a>5.7 哈夫曼树及其应用</h3><p>哈夫曼树（Huffman Tree）是一种用于数据压缩的最优二叉树。它由哈夫曼编码算法构造，广泛应用于文件压缩、图像压缩以及视频编码等领域。哈夫曼树的构造利用了频率或权重的思想，在编码过程中通过赋予频率较高的字符较短的编码，频率较低的字符较长的编码，从而实现数据的有效压缩。</p><hr /><h4><a name='header-n2480' class='md-header-anchor '></a>5.7.1 哈夫曼树的基本概念</h4><p>哈夫曼树是由 <strong>贪心算法</strong> 构建的二叉树，其基本思想是：在编码时给频率高的字符分配较短的编码，频率低的字符分配较长的编码，以此减少整体数据的存储量。</p><p>哈夫曼树的构造过程涉及到以下几个基本概念：</p><ul><li><strong>字符的频率</strong>：每个字符在文本中出现的频率。</li><li><strong>哈夫曼树的性质</strong>：哈夫曼树是一棵带权路径长度最小的二叉树，其中每个叶子节点表示一个字符，而每条边的权值通常与字符的出现频率成正比。</li></ul><p>哈夫曼树具有以下特点：</p><ol start='' ><li><strong>完全二叉树</strong>：每个内部节点都有两个子节点。</li><li><strong>最小带权路径长度</strong>：该树的带权路径长度（即字符的编码长度的加权和）最小，具有最优性。</li></ol><hr /><h4><a name='header-n2502' class='md-header-anchor '></a>5.7.2 哈夫曼树的构造算法</h4><p>构造哈夫曼树的算法是基于贪心算法的。它的基本思想是：</p><ol start='' ><li><strong>初始化</strong>：把每个字符作为一个叶子节点，每个节点的权值是该字符出现的频率。</li><li><strong>选择最小的两个节点</strong>：从森林中选择频率最小的两个节点，合并为一个新的节点，该节点的权值为两个最小节点的权值之和。</li><li><strong>构建哈夫曼树</strong>：重复步骤 2，直到只剩下一个节点，即哈夫曼树的根节点。</li></ol><p>具体步骤如下：</p><ol start='' ><li><strong>初始化</strong>：构建一个最小堆（或优先队列），将所有节点按频率从小到大排序。</li><li><strong>合并节点</strong>：从堆中取出两个最小的节点，构建一个新的节点，并将这个新节点的频率设置为两个节点的频率之和，然后将新节点插入堆中。</li><li><strong>重复合并</strong>：重复这个过程，直到堆中只剩下一个节点，此时的节点即为哈夫曼树的根节点。</li></ol><h4><a name='header-n2527' class='md-header-anchor '></a>C++ 代码实现</h4><p>以下是基于 C++ 的哈夫曼树构造算法的实现：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
using namespace std;

// 哈夫曼树节点
struct HuffmanNode {
    char ch;            // 字符
    int freq;           // 字符频率
    HuffmanNode* left;  // 左子节点
    HuffmanNode* right; // 右子节点

    // 构造函数
    HuffmanNode(char c, int f) : ch(c), freq(f), left(nullptr), right(nullptr) {}
};

// 自定义比较器，用于优先队列
struct Compare {
    bool operator()(HuffmanNode* a, HuffmanNode* b) {
        return a-&gt;freq &gt; b-&gt;freq;  // 最小堆，频率小的优先
    }
};

// 构造哈夫曼树
HuffmanNode* buildHuffmanTree(const unordered_map&lt;char, int&gt;&amp; freqMap) {
    priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, Compare&gt; pq;

    // 将所有字符及其频率放入优先队列
    for (auto&amp; entry : freqMap) {
        pq.push(new HuffmanNode(entry.first, entry.second));
    }

    // 合并节点直到队列中只剩下一个节点
    while (pq.size() &gt; 1) {
        // 取出两个最小频率的节点
        HuffmanNode* left = pq.top(); pq.pop();
        HuffmanNode* right = pq.top(); pq.pop();

        // 创建新的父节点
        HuffmanNode* parent = new HuffmanNode('\0', left-&gt;freq + right-&gt;freq);  // 不存储字符
        parent-&gt;left = left;
        parent-&gt;right = right;

        // 将新的节点插入优先队列
        pq.push(parent);
    }

    // 返回哈夫曼树的根节点
    return pq.top();
}

// 递归遍历哈夫曼树并生成哈夫曼编码
void generateHuffmanCodes(HuffmanNode* root, string code, unordered_map&lt;char, string&gt;&amp; huffmanCodes) {
    if (root == nullptr) return;

    // 叶子节点，保存字符和对应的编码
    if (root-&gt;ch != '\0') {
        huffmanCodes[root-&gt;ch] = code;
    }

    // 递归遍历左右子树
    generateHuffmanCodes(root-&gt;left, code + "0", huffmanCodes);
    generateHuffmanCodes(root-&gt;right, code + "1", huffmanCodes);
}

int main() {
    // 示例：字符及其频率
    unordered_map&lt;char, int&gt; freqMap = {
        {'a', 5},
        {'b', 9},
        {'c', 12},
        {'d', 13},
        {'e', 16},
        {'f', 45}
    };

    // 构造哈夫曼树
    HuffmanNode* root = buildHuffmanTree(freqMap);

    // 获取哈夫曼编码
    unordered_map&lt;char, string&gt; huffmanCodes;
    generateHuffmanCodes(root, "", huffmanCodes);

    // 输出哈夫曼编码
    cout &lt;&lt; "Huffman Codes:" &lt;&lt; endl;
    for (auto&amp; entry : huffmanCodes) {
        cout &lt;&lt; entry.first &lt;&lt; ": " &lt;&lt; entry.second &lt;&lt; endl;
    }

    return 0;
}
</pre><hr /><h4><a name='header-n2532' class='md-header-anchor '></a>5.7.3 哈夫曼编码</h4><p>哈夫曼编码是哈夫曼树的应用之一。哈夫曼编码通过将频率高的字符编码为较短的二进制码，频率低的字符编码为较长的二进制码，来达到数据压缩的目的。</p><p>在哈夫曼树中，路径从根节点到叶子节点的每个分支决定了该叶子节点（即字符）的哈夫曼编码：</p><ul><li>向左分支表示编码为 <code>0</code>。</li><li>向右分支表示编码为 <code>1</code>。</li></ul><p>哈夫曼编码的主要优势是<strong>前缀编码</strong>（即没有编码是另一个编码的前缀）。这种特性保证了编码的唯一性和无歧义性。</p><h5><a name='header-n2546' class='md-header-anchor '></a>示例</h5><p>假设有以下字符及其频率：</p><pre class="md-fences mock-cm md-end-block" lang="">a: 5
b: 9
c: 12
d: 13
e: 16
f: 45
</pre><p>通过哈夫曼树构建和编码的过程，我们得到如下的哈夫曼编码：</p><pre class="md-fences mock-cm md-end-block" lang="">a: 1100
b: 1101
c: 111
d: 10
e: 0
f: 1
</pre><p>根据上述编码，可以看到字符 <code>f</code> （频率最高）拥有最短的编码，而字符 <code>a</code> （频率较低）则拥有较长的编码。</p><hr /><h3><a name='header-n2556' class='md-header-anchor '></a>小结</h3><p>在这一节中，我们学习了哈夫曼树及其应用的几个重要方面：</p><ol start='' ><li><strong>哈夫曼树的基本概念</strong>：哈夫曼树是一种带有最小带权路径长度的二叉树，常用于数据压缩。</li><li><strong>哈夫曼树的构造算法</strong>：通过贪心算法，我们将频率最低的节点合并，逐步构造哈夫曼树。</li><li><strong>哈夫曼编码</strong>：通过遍历哈夫曼树的路径，我们可以为每个字符生成一个唯一的二进制编码，用于数据压缩。</li></ol><p>哈夫曼编码不仅具有最优性，而且由于其简单的结构和编码方式，广泛应用于文件压缩算法（如 ZIP 和 GZIP）以及图像压缩算法（如 JPEG 和 PNG）。</p><h3><a name='header-n2571' class='md-header-anchor '></a>第 6 章 图</h3><p>图是一种广泛应用于计算机科学和其他领域的重要数据结构，它由若干个节点（也称为顶点）和连接这些节点的边组成。图在许多实际问题中都有应用，如社交网络、计算机网络、路径规划、推荐系统等。本章将介绍图的定义、基本术语以及一些常见的图的应用。</p><hr /><h4><a name='header-n2575' class='md-header-anchor '></a>6.1 图的定义和基本术语</h4><p>图（Graph）是由一组顶点（V）和一组边（E）组成的集合。每条边都连接图中的两个顶点，图的边可以是有向的，也可以是无向的，顶点和边的排列组合定义了不同类型的图。</p><h5><a name='header-n2578' class='md-header-anchor '></a>6.1.1 图的定义</h5><p>图 G 可以表示为一个有序二元组：</p><pre class="md-fences mock-cm md-end-block" lang="">G = (V, E)
</pre><p>其中：</p><ul><li><strong>V</strong>：是图中的顶点集合，V = {v₁, v₂, ..., vn}，表示图中所有的节点。</li><li><strong>E</strong>：是图中的边集合，E = {(v₁, v₂), (v₂, v₃), ...}，每条边连接图中的两个顶点。</li></ul><p>图的种类：</p><ul><li><strong>有向图（Directed Graph）</strong>：图中的边有方向，表示从一个顶点到另一个顶点的关系。每条边用有序对表示 <code>(v₁, v₂)</code>，表示从顶点 <code>v₁</code> 到顶点 <code>v₂</code>。</li><li><strong>无向图（Undirected Graph）</strong>：图中的边没有方向，表示两个顶点之间的关系。每条边用无序对表示 <code>{v₁, v₂}</code>，表示顶点 <code>v₁</code> 和顶点 <code>v₂</code> 之间的关系。</li></ul><p>此外，还有一些特殊的图：</p><ul><li><strong>加权图（Weighted Graph）</strong>：图中的每条边都有一个权值（或称为成本、长度等）。</li><li><strong>无权图（Unweighted Graph）</strong>：图中的每条边没有权值。</li><li><strong>完全图（Complete Graph）</strong>：图中的每对不同的顶点都有一条边。</li><li><strong>连通图（Connected Graph）</strong>：无向图中任意两个顶点都有路径相连。</li></ul><h5><a name='header-n2615' class='md-header-anchor '></a>6.1.2 图的基本术语</h5><p>图的基本术语包括以下几个方面：</p><ol start='' ><li><p><strong>顶点（Vertex）</strong>：图中的每一个节点称为顶点（有时也称为“点”）。</p></li><li><p><strong>边（Edge）</strong>：连接两个顶点的线段称为边。对于无向图，边是无方向的；对于有向图，边是有方向的。</p></li><li><p>度（Degree）</p><p>：</p><ul><li><strong>顶点的度（Degree of a Vertex）</strong>：一个顶点的度是与该顶点相连接的边的数量。在无向图中，顶点的度是该顶点的边的数量；在有向图中，顶点的度可以分为<strong>入度</strong>（指向该顶点的边的数量）和<strong>出度</strong>（从该顶点指向其他顶点的边的数量）。</li></ul></li><li><p><strong>路径（Path）</strong>：从一个顶点到另一个顶点的顶点序列，序列中的每两个连续顶点之间都有边连接。</p></li><li><p><strong>简单路径（Simple Path）</strong>：路径中的每个顶点都不重复。</p></li><li><p><strong>回路（Cycle）</strong>：从某一顶点出发，沿着边回到该顶点的路径。若路径中的所有顶点都不重复，则称为<strong>简单回路</strong>。</p></li><li><p>连通性</p><p>：</p><ul><li><strong>连通图（Connected Graph）</strong>：无向图中的任意两个顶点都可以通过路径相连。</li><li><strong>强连通图（Strongly Connected Graph）</strong>：有向图中的任意两个顶点都有路径可以互相到达。</li></ul></li></ol><hr /><h4><a name='header-n2656' class='md-header-anchor '></a>6.2 案例引入</h4><p>在实际应用中，图有很多重要的应用场景。我们来看几个典型的应用案例。</p><h5><a name='header-n2659' class='md-header-anchor '></a>1. 社交网络</h5><p>社交网络中的用户可以看作图的顶点，用户之间的关系（如“朋友”关系）可以看作边。社交网络中的一些问题，如“最短路径”问题（两个人之间的最短友谊链）、“推荐系统”问题（通过朋友推荐朋友）等，都可以通过图来建模和解决。</p><h5><a name='header-n2662' class='md-header-anchor '></a>2. 路径规划</h5><p>在地图上，城市可以看作图的顶点，城市之间的道路可以看作边。每条道路可能有不同的长度或交通状况，可以在图中赋予不同的权值。路径规划问题（例如找到从一个城市到另一个城市的最短路径）可以通过图算法来解决，如Dijkstra算法、A*算法等。</p><h5><a name='header-n2665' class='md-header-anchor '></a>3. 计算机网络</h5><p>计算机网络是由许多计算机和它们之间的连接（例如路由器、交换机）组成的图。在计算机网络中，节点代表计算机，边代表计算机之间的通信链路。网络中最短路径、最小生成树等问题可以通过图算法来求解。</p><h5><a name='header-n2668' class='md-header-anchor '></a>4. Web页面链接</h5><p>Web页面可以看作图中的顶点，而页面之间的超链接可以看作边。搜索引擎会根据网页之间的链接关系来评估页面的相关性和权重，Google的PageRank算法就是基于图的思想，通过计算每个页面的权重来判断页面的重要性。</p><h5><a name='header-n2671' class='md-header-anchor '></a>5. 推荐系统</h5><p>在推荐系统中，图可以用来表示用户与物品的关系。用户和物品都是图中的顶点，用户与物品之间的关系（如购买、评分）可以用边来表示。基于图的推荐算法，如协同过滤算法，能够为用户推荐他们可能喜欢的物品。</p><p>这些应用案例表明了图在不同领域中的广泛应用，图的相关算法为解决这些问题提供了理论基础和技术支持。</p><hr /><h3><a name='header-n2677' class='md-header-anchor '></a>小结</h3><p>本节内容主要介绍了图的定义和基本术语，包括：</p><ul><li><strong>图的定义</strong>：图是由顶点和边组成的集合，包含有向图、无向图、加权图等多种形式。</li><li><strong>基本术语</strong>：如顶点、边、度、路径、回路等。</li><li><strong>应用案例</strong>：通过社交网络、路径规划、计算机网络、Web页面链接、推荐系统等案例，展示了图在实际中的重要应用。</li></ul><h3><a name='header-n2690' class='md-header-anchor '></a>6.3 图的类型定义</h3><p>在图的理论中，图的类型定义主要是根据图的边的特性和结构来分类的。图的类型不仅影响图的存储方式，还影响我们选择适当的图算法来解决具体的问题。常见的图的分类包括有向图和无向图、加权图和无权图、连通图和非连通图等。本节将详细介绍这些常见图的类型及其定义。</p><hr /><h4><a name='header-n2694' class='md-header-anchor '></a>6.3.1 无向图（Undirected Graph）</h4><p>无向图是一种图，其中的边没有方向，即边连接两个顶点的关系是对称的。例如，在社交网络中，朋友关系是对称的，因此用无向图表示更为合适。</p><ul><li><p><strong>定义</strong>：无向图 G=(V,E)G = (V, E)，其中：</p><ul><li>VV 是顶点集合，</li><li>EE 是边的集合，每条边 ee 都是顶点对 (vi,vj)(v_i, v_j) 的无序对。</li></ul></li><li><p><strong>性质</strong>：无向图的边没有方向，意味着边 (vi,vj)(v_i, v_j) 和 (vj,vi)(v_j, v_i) 是等价的。</p></li><li><p><strong>例子</strong>：社交网络中的朋友关系。</p></li></ul><h5><a name='header-n2714' class='md-header-anchor '></a>无向图的表示：</h5><p>对于无向图的存储，可以使用邻接矩阵、邻接表等数据结构。无向图的邻接矩阵是对称的，因为边的方向没有区分。</p><hr /><h4><a name='header-n2718' class='md-header-anchor '></a>6.3.2 有向图（Directed Graph）</h4><p>有向图是一种图，其中的边是有方向的，即每条边都有一个起点和一个终点。边的方向从一个顶点指向另一个顶点，因此有向图是一个有序的顶点对。</p><ul><li><p><strong>定义</strong>：有向图 G=(V,E)G = (V, E)，其中：</p><ul><li>VV 是顶点集合，</li><li>EE 是边的集合，每条边 ee 都是顶点对 (vi,vj)(v_i, v_j) 的有序对。</li></ul></li><li><p><strong>性质</strong>：有向图中的边是有方向的，意味着 (vi,vj)(v_i, v_j) 和 (vj,vi)(v_j, v_i) 是不同的边。</p></li><li><p><strong>例子</strong>：计算机网络中的数据包传输，网页之间的超链接，交通流向等。</p></li></ul><h5><a name='header-n2738' class='md-header-anchor '></a>有向图的表示：</h5><p>有向图的邻接矩阵是非对称的，因为边有方向，因此 (vi,vj)(v_i, v_j) 与 (vj,vi)(v_j, v_i) 不一定相等。</p><hr /><h4><a name='header-n2742' class='md-header-anchor '></a>6.3.3 加权图（Weighted Graph）</h4><p>加权图是一种图，其中每条边都有一个与之相关的权值（或称为成本、长度）。在加权图中，边的权值通常表示边的某种特性，如距离、费用、时间等。</p><ul><li><p><strong>定义</strong>：加权图 G=(V,E)G = (V, E)，其中：</p><ul><li>VV 是顶点集合，</li><li>EE 是边的集合，每条边 e=(vi,vj)e = (v_i, v_j) 都关联一个权值 wijw_{ij}。</li></ul></li><li><p><strong>性质</strong>：加权图中的边不仅包含连接两个顶点的关系，还包含边的权值。权值可以是任意的数值，可以表示距离、费用、容量等。</p></li><li><p><strong>例子</strong>：地图上的道路网络，边的权值可以表示距离或通行时间；计算机网络中，边的权值可以表示带宽。</p></li></ul><h5><a name='header-n2762' class='md-header-anchor '></a>加权图的表示：</h5><p>加权图通常使用邻接矩阵或邻接表来表示，每条边都有一个权值。如果边没有权值，则可以看作是一个无权图。</p><hr /><h4><a name='header-n2766' class='md-header-anchor '></a>6.3.4 无权图（Unweighted Graph）</h4><p>无权图是一种图，其中每条边都没有权值。无权图只关心顶点之间是否有连接关系，而不考虑连接的强度或其他性质。</p><ul><li><p><strong>定义</strong>：无权图 G=(V,E)G = (V, E)，其中：</p><ul><li>VV 是顶点集合，</li><li>EE 是边的集合，每条边仅表示两个顶点之间的连接关系，而没有权值。</li></ul></li><li><p><strong>性质</strong>：无权图的边没有权值，边的存在性即表示连接关系，通常用于表示存在性问题（例如“是否有路径连接两个节点”）。</p></li><li><p><strong>例子</strong>：朋友关系网络（只关心是否为朋友，不关心朋友关系的强度）。</p></li></ul><h5><a name='header-n2786' class='md-header-anchor '></a>无权图的表示：</h5><p>无权图的邻接矩阵和邻接表表示都只关心边的存在与否，边可以用0和1表示，0表示无连接，1表示有连接。</p><hr /><h4><a name='header-n2790' class='md-header-anchor '></a>6.3.5 完全图（Complete Graph）</h4><p>完全图是一种图，其中每对不同的顶点都有一条边直接连接。对于一个顶点集合中的每两个不同的顶点 viv_i 和 vjv_j，都有一条边连接它们。</p><ul><li><strong>定义</strong>：完全图是一个无向图 G=(V,E)G = (V, E)，其中每对不同的顶点 viv_i 和 vjv_j 都有一条边 (vi,vj)∈E(v_i, v_j) \in E。</li><li><strong>性质</strong>：一个包含 nn 个顶点的完全图有 n(n−1)2\frac{n(n-1)}{2} 条边。</li><li><strong>例子</strong>：在社交网络中，如果每个用户都与所有其他用户直接有连接关系，那么这个网络可以用完全图表示。</li></ul><h5><a name='header-n2803' class='md-header-anchor '></a>完全图的表示：</h5><p>完全图的邻接矩阵中，除了对角线上的元素（表示顶点自己与自己没有边）外，其他所有元素都为1，表示每两个不同的顶点之间都有边。</p><hr /><h4><a name='header-n2807' class='md-header-anchor '></a>6.3.6 连通图（Connected Graph）</h4><p>连通图是一种无向图，其中任意两个顶点之间都有一条路径相连。换句话说，连通图中的任意两个顶点都可以通过边达到。</p><ul><li><strong>定义</strong>：无向图 G=(V,E)G = (V, E) 是连通的，当且仅当图中的任意两个不同的顶点 viv_i 和 vjv_j 都存在一条路径连接它们。</li><li><strong>性质</strong>：连通图中的所有顶点都是相互可达的。如果图不是连通的，则称为<strong>非连通图</strong>。</li><li><strong>例子</strong>：城市之间的道路网络。如果每个城市都可以通过一系列道路互相到达，则该图是连通的。</li></ul><h5><a name='header-n2820' class='md-header-anchor '></a>连通图的表示：</h5><p>连通图的邻接矩阵表示中，任意两个顶点之间都有路径连接。非连通图则可能存在一些顶点是孤立的。</p><hr /><h4><a name='header-n2824' class='md-header-anchor '></a>6.3.7 强连通图（Strongly Connected Graph）</h4><p>强连通图是一个有向图，在这个图中，任意两个顶点都可以互相到达，即从顶点 viv_i 可以通过有向边到达顶点 vjv_j，同时也可以从 vjv_j 回到 viv_i。</p><ul><li><strong>定义</strong>：有向图 G=(V,E)G = (V, E) 是强连通的，当且仅当任意两个不同的顶点 viv_i 和 vjv_j 都有路径可以互相到达。</li><li><strong>性质</strong>：强连通图中的每两个顶点都有双向的路径连接。如果有向图不是强连通的，则称其为<strong>非强连通图</strong>。</li><li><strong>例子</strong>：一个社交网络中的双向互动关系，如果两个用户之间可以互相评论和回复，那么它们之间是强连通的。</li></ul><h5><a name='header-n2837' class='md-header-anchor '></a>强连通图的表示：</h5><p>强连通图的邻接矩阵没有任何元素是零，表示每个顶点都可以通过路径到达其他顶点。</p><hr /><h3><a name='header-n2841' class='md-header-anchor '></a>小结</h3><p>本节介绍了图的不同类型及其定义，包括无向图、有向图、加权图、无权图、完全图、连通图和强连通图等。这些类型的不同决定了图的存储方式和适用的算法。了解这些图的类型可以帮助我们根据问题的实际需求选择合适的图模型，并设计高效的图算法。</p><h3><a name='header-n2844' class='md-header-anchor '></a>6.4 图的存储结构</h3><p>图的存储结构主要有四种常见的表示方式：邻接矩阵、邻接表、十字链表和邻接多重表。每种存储结构各有优缺点，适用于不同的应用场景。选择合适的存储结构可以有效地提高图算法的性能。</p><hr /><h4><a name='header-n2848' class='md-header-anchor '></a>6.4.1 邻接矩阵（Adjacency Matrix）</h4><p>邻接矩阵是一种二维数组，用来表示图中顶点之间的连接关系。对于一个有 nn 个顶点的图，邻接矩阵是一个 n×nn \times n 的矩阵，其中每个元素表示顶点之间是否有边连接。</p><ul><li><p><strong>定义</strong>：</p><ul><li>对于无向图，邻接矩阵是对称的，即 A[i][j]=A[j][i]A[i][j] = A[j][i]。</li><li>对于有向图，矩阵元素表示从顶点 ii 到顶点 jj 是否有边。</li></ul></li><li><p><strong>矩阵表示</strong>：</p><ul><li>如果图是无权图，矩阵元素为 1 表示有边，0 表示无边。</li><li>如果图是加权图，矩阵元素为边的权值，若没有边，则为 0 或某个特殊值（如无穷大）。</li></ul></li><li><p><strong>优缺点</strong>：</p><ul><li><p>优点</p><p>：</p><ul><li>适用于稠密图（边数较多的图）。</li><li>可以在 O(1)O(1) 时间内判断任意两个顶点之间是否有边。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>空间复杂度较高，对于稀疏图（边数较少的图），存储空间浪费较多。</li><li>不适合动态变化的图（如频繁增删边）。</li></ul></li></ul></li><li><p><strong>邻接矩阵示例</strong>：对于以下无向图：</p><pre class="md-fences mock-cm md-end-block" lang="">0 -- 1
|    |
2 -- 3
</pre><p>邻接矩阵表示为：</p><pre class="md-fences mock-cm md-end-block" lang="">A = [
    [0, 1, 1, 0],
    [1, 0, 1, 0],
    [1, 1, 0, 1],
    [0, 0, 1, 0]
]
</pre><p>这里，顶点 00 和顶点 11 之间有一条边，因此 A[0][1]=1A[0][1] = 1，而 A[0][3]=0A[0][3] = 0，表示顶点 00 和顶点 33 没有边。</p></li></ul><hr /><h4><a name='header-n2910' class='md-header-anchor '></a>6.4.2 邻接表（Adjacency List）</h4><p>邻接表是另一种常见的图存储结构。它通过为图中的每个顶点维护一个链表（或其他线性结构）来表示与该顶点相邻的所有顶点。</p><ul><li><p><strong>定义</strong>：</p><ul><li>对于每个顶点 viv_i，维护一个链表，链表中的元素表示与 viv_i 相连接的其他顶点。</li></ul></li><li><p><strong>优缺点</strong>：</p><ul><li><p>优点</p><p>：</p><ul><li>节省空间，特别适用于稀疏图。</li><li>对于稀疏图，边的存储量比邻接矩阵节省很多空间。</li><li>可以有效地存储动态变化的图（如增删边）。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>在查询两个顶点是否有边连接时，需要遍历链表，时间复杂度为 O(k)O(k)，其中 kk 为顶点 viv_i 的度数。</li></ul></li></ul></li><li><p><strong>邻接表示例</strong>：对于以下无向图：</p><pre class="md-fences mock-cm md-end-block" lang="">0 -- 1
|    |
2 -- 3
</pre><p>邻接表表示为：</p><pre class="md-fences mock-cm md-end-block" lang="">0: 1 -&gt; 2
1: 0 -&gt; 3
2: 0 -&gt; 3
3: 1 -&gt; 2
</pre><p>其中，顶点 0 的邻接表存储了顶点 1 和 2，表示顶点 0 与这两个顶点有边连接。</p></li></ul><hr /><h4><a name='header-n2959' class='md-header-anchor '></a>6.4.3 十字链表（Orthogonal List）</h4><p>十字链表是图的另一种存储结构，专门为有向图设计。它结合了邻接矩阵和邻接表的优点，能够有效存储有向图的顶点和边。十字链表为每个边设置了两个指针，一个指向起点，另一个指向终点。十字链表的每个结点通常包含四个指针：一个指向起点的邻接表，一个指向终点的邻接表，以及起点和终点的“逆”链表。</p><ul><li><p><strong>定义</strong>：</p><ul><li><p>十字链表使用四种指针来维护信息：</p><ul><li><strong>头指针</strong>：指向图的顶点。</li><li><strong>出边指针</strong>：指向从该顶点出发的边。</li><li><strong>入边指针</strong>：指向指向该顶点的边。</li><li><strong>逆边指针</strong>：指向与当前边反向的边。</li></ul></li></ul></li><li><p><strong>优缺点</strong>：</p><ul><li><p>优点</p><p>：</p><ul><li>十字链表适用于有向图，能够高效地存储有向边。</li><li>在存储有向图时，查询顶点的入度和出度都比较方便。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>存储结构较为复杂，空间开销较大。</li><li>对于无向图或稀疏图，使用十字链表的优势不明显。</li></ul></li></ul></li><li><p><strong>十字链表示例</strong>：假设有一个有向图 GG：</p><pre class="md-fences mock-cm md-end-block" lang="">0 → 1
↑    ↓
2 ← 3
</pre><p>其十字链表表示可能包括以下四个链表：</p><ul><li><p>顶点链表</p><p>：</p><pre class="md-fences mock-cm md-end-block" lang="">0 → 1 → 2 → 3
</pre></li><li><p>出边链表</p><p>（从顶点出发的边）：</p><pre class="md-fences mock-cm md-end-block" lang="">0 → 1
1 → 3
2 → 0
3 → 2
</pre></li><li><p>入边链表</p><p>（指向顶点的边）：</p><pre class="md-fences mock-cm md-end-block" lang="">0 → 2
1 → 0
2 → 3
3 → 1
</pre></li><li><p>逆边链表</p><p>：</p><pre class="md-fences mock-cm md-end-block" lang="">0 ← 2
1 ← 0
2 ← 3
3 ← 1
</pre></li></ul></li></ul><hr /><h4><a name='header-n3043' class='md-header-anchor '></a>6.4.4 邻接多重表（Adjacency Multilist）</h4><p>邻接多重表是一种图的存储结构，适用于包含多重边（即两个顶点之间存在多条边）的图。与邻接表类似，邻接多重表为每个顶点维护一个链表来存储与该顶点相连的顶点信息，但它允许一个顶点有多条边连接到另一个顶点，因此每个链表中可以有多个相同的边。</p><ul><li><p><strong>定义</strong>：</p><ul><li>每个顶点对应一个邻接表，其中每个节点表示与该顶点相连的其他顶点。</li><li>允许在邻接表中存储多条边，适用于有多重边的图。</li></ul></li><li><p><strong>优缺点</strong>：</p><ul><li><p>优点</p><p>：</p><ul><li>支持多重边，适用于需要存储重复连接关系的图。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>存储空间较大。</li><li>对于没有多重边的图，使用邻接多重表可能浪费空间。</li></ul></li></ul></li><li><p><strong>邻接多重表示例</strong>：对于以下图，两个顶点 0 和 1 之间存在两条边：</p><pre class="md-fences mock-cm md-end-block" lang="">0 -- 1
|    |
2 -- 3
</pre><p>邻接多重表可以表示为：</p><pre class="md-fences mock-cm md-end-block" lang="">0: 1 → 1 → 2
1: 0 → 3
2: 0 → 3
3: 1 → 2
</pre><p>其中，顶点 0 和 1 之间有两条边，因此在邻接表中会出现两个 <code>1</code>。</p></li></ul><hr /><h3><a name='header-n3092' class='md-header-anchor '></a>小结</h3><p>本节介绍了图的四种常见存储结构：</p><ul><li><strong>邻接矩阵</strong>：适用于稠密图，查询快速，但存储空间较大。</li><li><strong>邻接表</strong>：适用于稀疏图，存储节省空间，但查询顶点连接关系时可能较慢。</li><li><strong>十字链表</strong>：专门为有向图设计，支持高效的有向边存储和查询，但存储复杂。</li><li><strong>邻接多重表</strong>：适用于多重边的图，支持存储重复的边，空间开销较大。</li></ul><h3><a name='header-n3108' class='md-header-anchor '></a>6.5 图的遍历</h3><p>图的遍历是图论中的一种基本操作，主要有两种经典的遍历方法：<strong>深度优先搜索（DFS）和广度优先搜索（BFS）</strong>。这两种遍历方法分别适用于不同的应用场景，能够帮助我们解决各种图相关的问题，例如查找路径、寻找连通组件、拓扑排序等。</p><hr /><h4><a name='header-n3112' class='md-header-anchor '></a>6.5.1 深度优先搜索（DFS）</h4><p>深度优先搜索（DFS）是一种图的遍历算法，它通过从一个起始顶点出发，沿着图的深度方向搜索，直到到达没有未访问的邻居的顶点为止，然后回溯并继续搜索其他路径。DFS 通常使用栈来辅助实现，能够深入到图的每一个分支。</p><ul><li><p><strong>基本思想</strong>：</p><ol start='' ><li>从起始顶点出发，访问该顶点。</li><li>对于当前顶点的每个未访问的邻居，递归地进行深度优先遍历。</li><li>如果所有邻居都已访问，回溯到上一个顶点，继续遍历其未访问的邻居。</li></ol></li><li><p><strong>实现方式</strong>：</p><ul><li><strong>递归实现</strong>：使用系统栈来存储每个递归调用。</li><li><strong>非递归实现</strong>：使用显式栈来模拟递归调用的过程。</li></ul></li><li><p><strong>时间复杂度</strong>：</p><ul><li>DFS 的时间复杂度为 O(V+E)O(V + E)，其中 VV 是顶点数，EE 是边数。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li>深度优先搜索适用于需要深入探索每个分支的场景，例如寻找路径、拓扑排序、判断图的连通性等。</li></ul></li><li><p><strong>C++ 代码示例（递归实现）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// 图的邻接表表示
class Graph {
public:
    int V; // 顶点数
    vector&lt;vector&lt;int&gt;&gt; adj; // 邻接表

    Graph(int V) {
        this-&gt;V = V;
        adj.resize(V);
    }

    // 添加边
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }

    // 深度优先搜索
    void DFS(int v, vector&lt;bool&gt;&amp; visited) {
        // 标记当前顶点为已访问
        visited[v] = true;
        cout &lt;&lt; v &lt;&lt; " "; // 输出当前顶点

        // 递归访问所有邻接的未访问顶点
        for (int neighbor : adj[v]) {
            if (!visited[neighbor]) {
                DFS(neighbor, visited);
            }
        }
    }
};

int main() {
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(2, 3);

    vector&lt;bool&gt; visited(4, false); // 用于标记顶点是否已访问
    cout &lt;&lt; "深度优先搜索结果: ";
    g.DFS(0, visited); // 从顶点0开始DFS
    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">深度优先搜索结果: 0 1 3 2
</pre></li></ul><hr /><h4><a name='header-n3161' class='md-header-anchor '></a>6.5.2 广度优先搜索（BFS）</h4><p>广度优先搜索（BFS）是一种图的遍历算法，它通过从一个起始顶点出发，先访问该顶点的所有邻居，然后再依次访问每个邻居的邻居，逐层向外扩展。BFS 通常使用队列来辅助实现，能够按照图的层次结构逐层遍历所有顶点。</p><ul><li><p><strong>基本思想</strong>：</p><ol start='' ><li>从起始顶点出发，访问该顶点并将其加入队列。</li><li>从队列中取出顶点，访问其所有未访问的邻居，并将这些邻居加入队列。</li><li>重复上述步骤，直到队列为空。</li></ol></li><li><p><strong>实现方式</strong>：</p><ul><li>使用队列来存储待访问的顶点，按照层次顺序逐个访问。</li></ul></li><li><p><strong>时间复杂度</strong>：</p><ul><li>BFS 的时间复杂度为 O(V+E)O(V + E)，其中 VV 是顶点数，EE 是边数。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li>广度优先搜索适用于需要层次遍历的场景，例如最短路径问题、连通分量的查找等。</li></ul></li><li><p><strong>C++ 代码示例</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

// 图的邻接表表示
class Graph {
public:
    int V; // 顶点数
    vector&lt;vector&lt;int&gt;&gt; adj; // 邻接表

    Graph(int V) {
        this-&gt;V = V;
        adj.resize(V);
    }

    // 添加边
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }

    // 广度优先搜索
    void BFS(int start) {
        vector&lt;bool&gt; visited(V, false); // 标记顶点是否已访问
        queue&lt;int&gt; q; // 用于BFS的队列

        // 标记起始顶点并加入队列
        visited[start] = true;
        q.push(start);

        while (!q.empty()) {
            int v = q.front(); // 取队列头部元素
            q.pop();
            cout &lt;&lt; v &lt;&lt; " "; // 输出当前顶点

            // 访问所有未访问的邻接顶点
            for (int neighbor : adj[v]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
    }
};

int main() {
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(2, 3);

    cout &lt;&lt; "广度优先搜索结果: ";
    g.BFS(0); // 从顶点0开始BFS
    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">广度优先搜索结果: 0 1 2 3
</pre></li></ul><hr /><h3><a name='header-n3207' class='md-header-anchor '></a>小结</h3><ol start='' ><li><p><strong>深度优先搜索（DFS）</strong>：</p><ul><li>通过递归或栈进行图的深度遍历。</li><li>时间复杂度：O(V+E)O(V + E)。</li><li>适合用于路径查找、拓扑排序、连通性检测等问题。</li></ul></li><li><p><strong>广度优先搜索（BFS）</strong>：</p><ul><li>通过队列进行图的层次遍历。</li><li>时间复杂度：O(V+E)O(V + E)。</li><li>适合用于最短路径问题、层次遍历、连通分量检测等问题。</li></ul></li></ol><h3><a name='header-n3235' class='md-header-anchor '></a>6.6 图的应用</h3><p>图作为一种重要的数据结构，在许多实际问题中得到了广泛应用。通过图的各种算法，能够解决诸如网络优化、路径搜索、排序等问题。以下是图的四个经典应用：最小生成树、最短路径、拓扑排序和关键路径。</p><hr /><h4><a name='header-n3239' class='md-header-anchor '></a>6.6.1 最小生成树（Minimum Spanning Tree）</h4><p>最小生成树（MST）是图论中的一个重要概念，指的是在一个连通加权图中，选择一部分边使得图中的所有顶点都能够连通，且边的总权重最小。最小生成树可以用来解决网络设计问题，例如构建最小成本的网络连接。</p><ul><li><p><strong>定义</strong>：</p><ul><li><strong>最小生成树</strong>是一个包含图中所有顶点的生成树，且生成树的边的权重之和最小。</li></ul></li><li><p><strong>常用算法</strong>：</p><ul><li><strong>Kruskal 算法</strong>：基于贪心策略，通过按权重升序排列边，逐步选择边来构建生成树。</li><li><strong>Prim 算法</strong>：从一个起始顶点出发，逐步选择与树相连接的最小边来扩展生成树。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li>最小生成树可以用于网络布线、城市的道路规划、电子电路设计等场景。</li></ul></li><li><p><strong>C++ 代码示例（Kruskal 算法）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

// 边的结构体
struct Edge {
    int u, v, weight;
    bool operator&lt;(const Edge &amp;e) {
        return weight &lt; e.weight;
    }
};

class Graph {
public:
    int V; // 顶点数
    vector&lt;Edge&gt; edges; // 边的集合

    Graph(int V) {
        this-&gt;V = V;
    }

    // 添加边
    void addEdge(int u, int v, int weight) {
        edges.push_back({u, v, weight});
    }

    // 查找祖先
    int find(int parent[], int i) {
        if (parent[i] == -1)
            return i;
        return find(parent, parent[i]);
    }

    // 合并两个集合
    void Union(int parent[], int x, int y) {
        int xroot = find(parent, x);
        int yroot = find(parent, y);
        parent[xroot] = yroot;
    }

    // Kruskal 算法
    void kruskal() {
        sort(edges.begin(), edges.end()); // 按权重排序边

        int parent[V];
        fill(parent, parent + V, -1); // 初始化并查集

        vector&lt;Edge&gt; mst; // 最小生成树

        for (auto &amp;edge : edges) {
            int x = find(parent, edge.u);
            int y = find(parent, edge.v);

            // 如果不在同一个集合中，加入最小生成树
            if (x != y) {
                mst.push_back(edge);
                Union(parent, x, y);
            }
        }

        // 输出最小生成树的边
        cout &lt;&lt; "最小生成树的边：" &lt;&lt; endl;
        for (auto &amp;edge : mst) {
            cout &lt;&lt; edge.u &lt;&lt; " - " &lt;&lt; edge.v &lt;&lt; " : " &lt;&lt; edge.weight &lt;&lt; endl;
        }
    }
};

int main() {
    Graph g(4);
    g.addEdge(0, 1, 10);
    g.addEdge(0, 2, 6);
    g.addEdge(0, 3, 5);
    g.addEdge(1, 3, 15);
    g.addEdge(2, 3, 4);

    g.kruskal(); // 计算最小生成树
    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">最小生成树的边：
2 - 3 : 4
0 - 3 : 5
0 - 1 : 10
</pre></li></ul><hr /><h4><a name='header-n3275' class='md-header-anchor '></a>6.6.2 最短路径（Shortest Path）</h4><p>最短路径问题是图论中的一个经典问题，要求在图中找到从一个起始顶点到所有其他顶点的最短路径。最短路径算法广泛应用于地图导航、网络数据传输、路径规划等领域。</p><ul><li><p><strong>常用算法</strong>：</p><ul><li><strong>Dijkstra 算法</strong>：适用于没有负权边的图，通过贪心策略逐步确定起点到其他顶点的最短路径。</li><li><strong>Bellman-Ford 算法</strong>：适用于带有负权边的图，能够处理负权环路。</li><li><strong>Floyd-Warshall 算法</strong>：适用于计算图中所有顶点对之间的最短路径。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li>网络路由、导航系统、地铁线路规划等。</li></ul></li><li><p><strong>C++ 代码示例（Dijkstra 算法）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
using namespace std;

class Graph {
public:
    int V; // 顶点数
    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj; // 邻接表，存储边的权重

    Graph(int V) {
        this-&gt;V = V;
        adj.resize(V);
    }

    // 添加边
    void addEdge(int u, int v, int weight) {
        adj[u].push_back({v, weight});
        adj[v].push_back({u, weight}); // 如果是无向图
    }

    // Dijkstra 算法计算最短路径
    void dijkstra(int start) {
        vector&lt;int&gt; dist(V, INT_MAX); // 存储最短距离
        dist[start] = 0;
        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; // 优先队列
        pq.push({0, start}); // 起始点入队

        while (!pq.empty()) {
            int u = pq.top().second;
            int d = pq.top().first;
            pq.pop();

            // 遍历当前顶点的所有邻接点
            for (auto &amp;neighbor : adj[u]) {
                int v = neighbor.first;
                int weight = neighbor.second;

                if (dist[u] + weight &lt; dist[v]) {
                    dist[v] = dist[u] + weight;
                    pq.push({dist[v], v});
                }
            }
        }

        // 输出最短路径
        for (int i = 0; i &lt; V; ++i) {
            cout &lt;&lt; "从顶点 " &lt;&lt; start &lt;&lt; " 到顶点 " &lt;&lt; i &lt;&lt; " 的最短路径是: " &lt;&lt; dist[i] &lt;&lt; endl;
        }
    }
};

int main() {
    Graph g(5);
    g.addEdge(0, 1, 10);
    g.addEdge(0, 4, 5);
    g.addEdge(1, 2, 1);
    g.addEdge(1, 4, 2);
    g.addEdge(2, 3, 4);
    g.addEdge(3, 0, 7);
    g.addEdge(4, 2, 9);
    g.addEdge(4, 3, 2);

    g.dijkstra(0); // 从顶点0开始计算最短路径
    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">从顶点 0 到顶点 0 的最短路径是: 0
从顶点 0 到顶点 1 的最短路径是: 8
从顶点 0 到顶点 2 的最短路径是: 9
从顶点 0 到顶点 3 的最短路径是: 7
从顶点 0 到顶点 4 的最短路径是: 5
</pre></li></ul><hr /><h4><a name='header-n3307' class='md-header-anchor '></a>6.6.3 拓扑排序（Topological Sort）</h4><p>拓扑排序是对有向无环图（DAG）中的顶点进行排序，使得对于图中的每一条有向边 (u,v)(u, v)，顶点 uu 都排在顶点 vv 之前。拓扑排序广泛应用于任务调度、课程安排、项目管理等场景。</p><ul><li><p><strong>基本思想</strong>：</p><ul><li>拓扑排序可以通过 <strong>深度优先搜索（DFS）</strong> 或 <strong>入度为零的顶点</strong> 的算法实现。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li>项目调度、课程安排、编译器中的依赖关系处理等。</li></ul></li><li><p><strong>C++ 代码示例（拓扑排序，Kahn 算法）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

class Graph {
public:
    int V; // 顶点数
    vector&lt;vector&lt;int&gt;&gt; adj; // 邻接表
    vector&lt;int&gt; indegree; // 入度

    Graph(int V) {
        this-&gt;V = V;
        adj.resize(V);
        indegree.resize(V, 0
        )
;}
  // 添加边
  void addEdge(int u, int v) {
      adj[u].push_back(v);
      indegree[v]++;
  }

  // 拓扑排序
  void topologicalSort() {
      queue&lt;int&gt; q;

      // 将所有入度为0的顶点入队
      for (int i = 0; i &lt; V; ++i) {
          if (indegree[i] == 0) {
              q.push(i);
          }
      }

      while (!q.empty()) {
          int u = q.front();
          q.pop();
          cout &lt;&lt; u &lt;&lt; " "; // 输出顶点

          // 遍历所有邻接点，更新入度
          for (int v : adj[u]) {
              if (--indegree[v] == 0) {
                  q.push(v);
              }
          }
      }
      cout &lt;&lt; endl;
  }
  };

int main()
{
Graph g(6);
g.addEdge(5, 2);
g.addEdge(5, 0);
g.addEdge(4, 0);
g.addEdge(4, 1);
g.addEdge(2, 3);
g.addEdge(3, 1);
 cout &lt;&lt; "拓扑排序结果: ";
 g.topologicalSort();
  return 0;
  }
</pre></li></ul><pre class="md-fences mock-cm md-end-block" lang=""><br></pre><p>&nbsp;</p><pre class="md-fences mock-cm md-end-block" lang=""><br></pre><p>&nbsp;</p><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">拓扑排序结果: 4 5 2 3 1 0
</pre><p>&nbsp;</p><hr /><h4><a name='header-n3342' class='md-header-anchor '></a>6.6.4 关键路径（Critical Path）</h4><p>关键路径是指项目管理中一个有向有环图（DAG）中，从起点到终点的最长路径，它决定了项目的最短完成时间。关键路径算法用于项目调度，帮助确定哪些任务是关键的，不能延误。</p><ul><li><strong>应用</strong>：</li><li>项目调度、时间管理、资源分配等。</li><li><strong>算法</strong>：</li><li>利用拓扑排序和动态规划，计算最早开始时间、最晚开始时间等，最终求出关键路径。</li></ul><hr /><h3><a name='header-n3359' class='md-header-anchor '></a>小结</h3><ul><li><strong>最小生成树</strong>：通过 Kruskal 或 Prim 算法来构造最小生成树，应用于网络设计和优化。</li><li><strong>最短路径</strong>：通过 Dijkstra、Bellman-Ford 或 Floyd-Warshall 算法来求解最短路径问题，广泛应用于网络路由、导航系统等。</li><li><strong>拓扑排序</strong>：用于处理有向无环图（DAG）中的任务调度、依赖关系等问题。</li><li><strong>关键路径</strong>：通过拓扑排序和动态规划来求解项目调度中的关键路径问题。</li></ul><h3><a name='header-n3373' class='md-header-anchor '></a>第 7 章 查找</h3><p>查找是数据结构中的一个重要操作，它的目的是在数据集（如数组、链表、树等）中查找某个特定元素。查找方法的选择直接影响查找的效率。不同类型的数据结构有不同的查找策略，本章将介绍几种常见的查找方法及其应用。</p><hr /><h4><a name='header-n3377' class='md-header-anchor '></a>7.1 查找的基本概念</h4><p>查找操作的目的是从一个集合中找到特定元素的位置，通常是通过比较元素来完成。根据数据结构的不同，查找算法的时间复杂度也有所不同。</p><ul><li><p><strong>查找算法的分类</strong>：</p><ul><li><strong>顺序查找</strong>：通过逐个元素与目标元素进行比较，直至找到目标或遍历完整个集合。</li><li><strong>折半查找</strong>：也叫二分查找，适用于有序数据，通过每次比较中间元素来缩小查找范围。</li><li><strong>分块查找</strong>：将数据分为若干块，每次查找一个块，块内可以使用其他查找算法。</li></ul></li><li><p><strong>查找的性能评价</strong>：</p><ul><li><strong>时间复杂度</strong>：表示算法在最坏情况下的执行时间。常见的时间复杂度有 O(n)、O(log n) 等。</li><li><strong>空间复杂度</strong>：表示算法执行过程中所占用的额外存储空间。</li></ul></li></ul><hr /><h4><a name='header-n3405' class='md-header-anchor '></a>7.2 线性表的查找</h4><p>线性表是最简单的一种数据结构，常见的查找方法包括顺序查找、折半查找和分块查找。本节将分别介绍这几种方法及其实现。</p><hr /><h5><a name='header-n3409' class='md-header-anchor '></a>7.2.1 顺序查找（Sequential Search）</h5><p>顺序查找是一种最简单的查找方法，它的基本思想是从线性表的第一个元素开始，逐个与目标元素进行比较，直到找到为止。</p><ul><li><p><strong>算法步骤</strong>：</p><ol start='' ><li>从第一个元素开始遍历线性表。</li><li>将当前元素与目标元素进行比较。</li><li>如果相等，则返回该元素的位置。</li><li>如果遍历完所有元素仍未找到，则返回查找失败。</li></ol></li><li><p><strong>时间复杂度</strong>：最坏情况下为 O(n)，其中 n 是线性表的长度。</p></li><li><p><strong>C++ 代码实现</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 顺序查找函数
int sequentialSearch(int arr[], int n, int target) {
    for (int i = 0; i &lt; n; ++i) {
        if (arr[i] == target) {
            return i;  // 返回找到的元素索引
        }
    }
    return -1;  // 未找到目标元素，返回-1
}

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int n = sizeof(arr) / sizeof(arr[0]);
    int target = 30;

    int result = sequentialSearch(arr, n, target);
    if (result != -1) {
        cout &lt;&lt; "元素 " &lt;&lt; target &lt;&lt; " 在数组中的位置是: " &lt;&lt; result &lt;&lt; endl;
    } else {
        cout &lt;&lt; "元素 " &lt;&lt; target &lt;&lt; " 不在数组中！" &lt;&lt; endl;
    }

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">元素 30 在数组中的位置是: 2
</pre></li></ul><hr /><h5><a name='header-n3440' class='md-header-anchor '></a>7.2.2 折半查找（Binary Search）</h5><p>折半查找，也称为二分查找，是一种高效的查找算法，适用于已排序的线性表。它的基本思想是每次将查找区间分为两半，通过与中间元素的比较来逐步缩小查找范围。</p><ul><li><p><strong>算法步骤</strong>：</p><ol start='' ><li>如果查找区间为空，说明未找到目标元素。</li><li>计算查找区间的中间元素。</li><li>如果中间元素等于目标元素，则返回该元素的位置。</li><li>如果目标元素小于中间元素，则在左半区间继续查找。</li><li>如果目标元素大于中间元素，则在右半区间继续查找。</li></ol></li><li><p><strong>时间复杂度</strong>：O(log n)，其中 n 是线性表的长度。</p></li><li><p><strong>C++ 代码实现</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 折半查找（前提：数组已排序）
int binarySearch(int arr[], int n, int target) {
    int low = 0, high = n - 1;
    
    while (low &lt;= high) {
        int mid = low + (high - low) / 2;  // 防止溢出

        if (arr[mid] == target) {
            return mid;  // 找到目标元素，返回索引
        } else if (arr[mid] &lt; target) {
            low = mid + 1;  // 在右半部分查找
        } else {
            high = mid - 1;  // 在左半部分查找
        }
    }
    return -1;  // 查找失败
}

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int n = sizeof(arr) / sizeof(arr[0]);
    int target = 30;

    int result = binarySearch(arr, n, target);
    if (result != -1) {
        cout &lt;&lt; "元素 " &lt;&lt; target &lt;&lt; " 在数组中的位置是: " &lt;&lt; result &lt;&lt; endl;
    } else {
        cout &lt;&lt; "元素 " &lt;&lt; target &lt;&lt; " 不在数组中！" &lt;&lt; endl;
    }

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">元素 30 在数组中的位置是: 2
</pre></li></ul><hr /><h5><a name='header-n3474' class='md-header-anchor '></a>7.2.3 分块查找（Block Search）</h5><p>分块查找将线性表分为若干个块，每个块内可以使用其他查找方法（如顺序查找或折半查找），查找时首先确定目标元素所在的块，然后在该块内进行查找。</p><ul><li><p><strong>算法步骤</strong>：</p><ol start='' ><li>将线性表划分为若干个块，每个块的大小为 <code>block_size</code>。</li><li>使用顺序查找或折半查找确定目标元素所在的块。</li><li>在确定的块内再次进行查找。</li></ol></li><li><p><strong>时间复杂度</strong>：最坏情况下为 O(n / m + m)，其中 n 为线性表长度，m 为块的大小。通常取 m 为常数，从而查找时间接近 O(√n)。</p></li><li><p><strong>C++ 代码实现（分块查找）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

// 分块查找函数
int blockSearch(int arr[], int n, int target, int block_size) {
    int num_blocks = (n + block_size - 1) / block_size;  // 计算块数
    int i = 0;
    
    // 查找目标元素所在的块
    for (i = 0; i &lt; num_blocks; ++i) {
        int block_start = i * block_size;
        int block_end = min((i + 1) * block_size - 1, n - 1);

        // 在块内顺序查找
        for (int j = block_start; j &lt;= block_end; ++j) {
            if (arr[j] == target) {
                return j;
            }
        }
    }
    return -1;  // 查找失败
}

int main() {
    int arr[] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
    int n = sizeof(arr) / sizeof(arr[0]);
    int target = 70;
    int block_size = 3;  // 块的大小为3

    int result = blockSearch(arr, n, target, block_size);
    if (result != -1) {
        cout &lt;&lt; "元素 " &lt;&lt; target &lt;&lt; " 在数组中的位置是: " &lt;&lt; result &lt;&lt; endl;
    } else {
        cout &lt;&lt; "元素 " &lt;&lt; target &lt;&lt; " 不在数组中！" &lt;&lt; endl;
    }

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">元素 70 在数组中的位置是: 6
</pre></li></ul><hr /><h3><a name='header-n3502' class='md-header-anchor '></a>小结</h3><ul><li><strong>顺序查找</strong>：适用于无序数据，时间复杂度为 O(n)。</li><li><strong>折半查找</strong>：适用于有序数据，时间复杂度为 O(log n)，效率较高。</li><li><strong>分块查找</strong>：通过将数据分块，结合顺序查找或折半查找来提高查找效率，适用于大规模数据。</li></ul><h3><a name='header-n3513' class='md-header-anchor '></a>7.3 树表的查找</h3><p>在查找操作中，树形结构（如二叉排序树、平衡二叉树、B-树、B+树）是一种有效的数据结构。它们能够提供比线性查找更高效的查找操作，尤其在需要频繁插入、删除和查找的场景下，树形结构的查找算法通常具有更好的性能。本节将介绍几种常见的树表查找方法及其实现。</p><hr /><h4><a name='header-n3517' class='md-header-anchor '></a>7.3.1 二叉排序树（Binary Search Tree，BST）</h4><p>二叉排序树是一种满足特定顺序性质的二叉树，具体要求如下：</p><ul><li>每个节点的左子树只包含比当前节点小的元素。</li><li>每个节点的右子树只包含比当前节点大的元素。</li><li>左右子树的节点也分别满足上述条件。</li></ul><p><strong>查找算法</strong>：</p><ol start='' ><li>从根节点开始，如果目标元素等于当前节点的值，则查找成功。</li><li>如果目标元素小于当前节点的值，则向左子树递归查找。</li><li>如果目标元素大于当前节点的值，则向右子树递归查找。</li><li>如果某一节点为空，则查找失败。</li></ol><p><strong>时间复杂度</strong>：</p><ul><li>最坏情况下为 O(n)，即树变成了链表（树的高度为 n）。</li><li>最好情况下为 O(log n)，即树保持平衡。</li></ul><p><strong>C++ 实现</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 二叉树节点结构
struct Node {
    int data;
    Node* left;
    Node* right;

    Node(int value) : data(value), left(nullptr), right(nullptr) {}
};

// 二叉排序树类
class BinarySearchTree {
public:
    Node* root;

    BinarySearchTree() : root(nullptr) {}

    // 插入节点
    void insert(int value) {
        root = insertRec(root, value);
    }

    // 查找节点
    Node* search(int value) {
        return searchRec(root, value);
    }

private:
    // 插入的递归函数
    Node* insertRec(Node* node, int value) {
        // 如果树为空，创建新节点
        if (node == nullptr) {
            return new Node(value);
        }

        // 否则，递归地在左子树或右子树中插入
        if (value &lt; node-&gt;data) {
            node-&gt;left = insertRec(node-&gt;left, value);
        } else if (value &gt; node-&gt;data) {
            node-&gt;right = insertRec(node-&gt;right, value);
        }

        return node;
    }

    // 查找的递归函数
    Node* searchRec(Node* node, int value) {
        // 如果节点为空或找到目标元素，返回节点
        if (node == nullptr || node-&gt;data == value) {
            return node;
        }

        // 如果目标元素小于当前节点，递归左子树
        if (value &lt; node-&gt;data) {
            return searchRec(node-&gt;left, value);
        }

        // 如果目标元素大于当前节点，递归右子树
        return searchRec(node-&gt;right, value);
    }
};

int main() {
    BinarySearchTree bst;

    // 插入节点
    bst.insert(50);
    bst.insert(30);
    bst.insert(20);
    bst.insert(40);
    bst.insert(70);
    bst.insert(60);
    bst.insert(80);

    // 查找节点
    int target = 40;
    Node* result = bst.search(target);
    if (result != nullptr) {
        cout &lt;&lt; "找到节点，值为: " &lt;&lt; result-&gt;data &lt;&lt; endl;
    } else {
        cout &lt;&lt; "节点 " &lt;&lt; target &lt;&lt; " 不在树中!" &lt;&lt; endl;
    }

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">找到节点，值为: 40
</pre><hr /><h4><a name='header-n3561' class='md-header-anchor '></a>7.3.2 平衡二叉树（AVL 树）</h4><p>AVL 树是一种自平衡的二叉排序树。它的平衡因子（左子树高度减去右子树高度）始终保持在 -1、0 和 1 之间。插入或删除操作后，如果树不平衡，会通过旋转操作恢复平衡。</p><p><strong>查找算法</strong>：与普通的二叉排序树相同，只不过在每次插入或删除节点后，需要对树进行平衡调整。</p><p><strong>时间复杂度</strong>：插入、删除和查找操作的时间复杂度为 O(log n)。</p><p><strong>C++ 实现</strong>（插入和查找）：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

// 二叉树节点结构
struct Node {
    int data;
    Node* left;
    Node* right;
    int height; // 节点的高度

    Node(int value) : data(value), left(nullptr), right(nullptr), height(1) {}
};

// AVL树类
class AVLTree {
public:
    Node* root;

    AVLTree() : root(nullptr) {}

    // 插入节点
    void insert(int value) {
        root = insertRec(root, value);
    }

    // 查找节点
    Node* search(int value) {
        return searchRec(root, value);
    }

private:
    // 插入的递归函数
    Node* insertRec(Node* node, int value) {
        // 1. 执行正常的二叉搜索树插入
        if (node == nullptr) {
            return new Node(value);
        }

        if (value &lt; node-&gt;data) {
            node-&gt;left = insertRec(node-&gt;left, value);
        } else if (value &gt; node-&gt;data) {
            node-&gt;right = insertRec(node-&gt;right, value);
        } else {
            return node; // 如果值相等，不插入
        }

        // 2. 更新节点的高度
        node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));

        // 3. 计算平衡因子并检查是否平衡
        int balance = getBalance(node);

        // 4. 如果不平衡，则进行相应的旋转
        if (balance &gt; 1 &amp;&amp; value &lt; node-&gt;left-&gt;data) {
            return rotateRight(node); // 左左情况
        }
        if (balance &lt; -1 &amp;&amp; value &gt; node-&gt;right-&gt;data) {
            return rotateLeft(node); // 右右情况
        }
        if (balance &gt; 1 &amp;&amp; value &gt; node-&gt;left-&gt;data) {
            node-&gt;left = rotateLeft(node-&gt;left); // 左右情况
            return rotateRight(node);
        }
        if (balance &lt; -1 &amp;&amp; value &lt; node-&gt;right-&gt;data) {
            node-&gt;right = rotateRight(node-&gt;right); // 右左情况
            return rotateLeft(node);
        }

        return node;
    }

    // 查找的递归函数
    Node* searchRec(Node* node, int value) {
        if (node == nullptr || node-&gt;data == value) {
            return node;
        }
        if (value &lt; node-&gt;data) {
            return searchRec(node-&gt;left, value);
        }
        return searchRec(node-&gt;right, value);
    }

    // 获取节点的高度
    int getHeight(Node* node) {
        return node ? node-&gt;height : 0;
    }

    // 获取节点的平衡因子
    int getBalance(Node* node) {
        return node ? getHeight(node-&gt;left) - getHeight(node-&gt;right) : 0;
    }

    // 右旋转
    Node* rotateRight(Node* y) {
        Node* x = y-&gt;left;
        Node* T2 = x-&gt;right;

        // 执行旋转
        x-&gt;right = y;
        y-&gt;left = T2;

        // 更新高度
        y-&gt;height = max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1;
        x-&gt;height = max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1;

        return x;
    }

    // 左旋转
    Node* rotateLeft(Node* x) {
        Node* y = x-&gt;right;
        Node* T2 = y-&gt;left;

        // 执行旋转
        y-&gt;left = x;
        x-&gt;right = T2;

        // 更新高度
        x-&gt;height = max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1;
        y-&gt;height = max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1;

        return y;
    }
};

int main() {
    AVLTree avl;

    // 插入节点
    avl.insert(30);
    avl.insert(20);
    avl.insert(40);
    avl.insert(10);
    avl.insert(5);

    // 查找节点
    int target = 20;
    Node* result = avl.search(target);
    if (result != nullptr) {
        cout &lt;&lt; "找到节点，值为: " &lt;&lt; result-&gt;data &lt;&lt; endl;
    } else {
        cout &lt;&lt; "节点 " &lt;&lt; target &lt;&lt; " 不在树中!" &lt;&lt; endl;
    }

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">找到节点，值为: 20
</pre><hr /><h4><a name='header-n3575' class='md-header-anchor '></a>7.3.3 B-树</h4><p>B-树是一种自平衡</p><p>的多路查找树，广泛应用于数据库系统中。它适用于磁盘存储的高效查找。</p><p>B-树的特点：</p><ul><li>每个节点最多有 m 个子节点。</li><li>所有的叶子节点都在同一层。</li><li>内部节点的关键字按照升序排列。</li></ul><hr /><h4><a name='header-n3593' class='md-header-anchor '></a>7.3.4 B+ 树</h4><p>B+ 树是 B-树的变种，主要区别在于它的所有数据都保存在叶子节点中，内节点只保存索引。它通常用于数据库和文件系统中，用来优化查找性能。</p><hr /><p>以上为树表查找的几种常见方法。每种树结构的查找性能不同，B+ 树尤其适用于大量数据的磁盘存储和查找场景，而 AVL 树和二叉排序树则适用于内存中的数据查找。</p><h3><a name='header-n3599' class='md-header-anchor '></a>7.4 散列表的查找</h3><p>散列表（Hash Table）是一种基于哈希函数的查找数据结构，它通过将关键字映射到一个固定大小的数组下标来进行数据的存储和查找。散列表的查找时间复杂度通常为 O(1)O(1)，但在出现冲突时，查找的时间复杂度可能会增加。散列表在需要频繁查找操作的场景中表现出色，特别是在处理大量数据时。</p><p>本节将详细介绍散列表的基本概念、哈希函数的构造方法、处理冲突的方法以及散列表的查找操作。</p><hr /><h4><a name='header-n3605' class='md-header-anchor '></a>7.4.1 散列表的基本概念</h4><p>散列表通过哈希函数将关键字映射到一个固定大小的数组中。每个位置可以存储一个元素，当多个元素映射到同一个位置时，发生<strong>冲突</strong>。散列表解决冲突的方法有多种，包括链式地址法、开放地址法等。</p><p>散列表的基本概念：</p><ul><li><strong>哈希函数（Hash Function）</strong>：将输入的关键字映射到数组索引的函数。</li><li><strong>哈希表（Hash Table）</strong>：由一组数组和哈希函数组成的存储结构。</li><li><strong>冲突</strong>：当多个不同的元素通过哈希函数映射到相同的数组位置时，就发生了冲突。</li><li><strong>负载因子（Load Factor）</strong>：表示哈希表已使用空间与总空间的比例。负载因子高会导致冲突的发生频率增加。</li></ul><hr /><h4><a name='header-n3624' class='md-header-anchor '></a>7.4.2 散列函数的构造方法</h4><p>哈希函数的目的是将输入的关键字均匀地映射到哈希表的各个槽位上。一个好的哈希函数能够减少冲突的发生。以下是常见的几种哈希函数构造方法：</p><ol start='' ><li><p><strong>除法法</strong>：使用关键字对一个素数取余得到数组的索引。常用的素数是质数，因为质数能够有效减少冲突。</p><p>哈希函数的形式为：</p><p>h(k)=kmod  ph(k) = k \mod p</p><p>其中 kk 是关键字，pp 是一个素数，\mod 表示取余操作。</p></li><li><p><strong>乘法法</strong>：使用关键字乘以一个常数 AA，然后取整数部分的余数。常常取 A=(5−1)/2A = ( \sqrt{5} - 1) / 2，即黄金分割数的倒数，以优化哈希函数的分布。</p><p>哈希函数的形式为：</p><p>h(k)=⌊m(kAmod  1)⌋h(k) = \lfloor m(kA \mod 1) \rfloor</p><p>其中 mm 是哈希表的大小，⌊x⌋\lfloor x \rfloor 表示取整操作，mod  1\mod 1 表示取小数部分。</p></li><li><p><strong>平方法</strong>：对关键字进行平方运算后，取中间的若干位作为哈希值。</p></li></ol><hr /><h4><a name='header-n3650' class='md-header-anchor '></a>7.4.3 处理冲突的方法</h4><p>当多个关键字通过哈希函数映射到同一位置时，会发生<strong>冲突</strong>。处理冲突的常见方法有两种：<strong>链式地址法</strong>和<strong>开放地址法</strong>。</p><h5><a name='header-n3653' class='md-header-anchor '></a>1. 链式地址法</h5><p>链式地址法通过在哈希表的每个位置使用一个链表来存储所有映射到该位置的元素。如果多个元素的哈希值相同，它们将存储在同一个链表中。</p><p><strong>链式地址法的优点</strong>：</p><ul><li>插入和删除操作简单。</li><li>无需重新哈希数组大小，适应性强。</li></ul><p><strong>缺点</strong>：</p><ul><li>在极端情况下（例如所有元素都映射到同一位置），查找时间复杂度可能变为 O(n)O(n)。</li></ul><h5><a name='header-n3671' class='md-header-anchor '></a>2. 开放地址法</h5><p>开放地址法通过查找表中其他空闲的位置来存储冲突的元素，常见的开放地址法处理冲突的方式包括：</p><ul><li><strong>线性探测</strong>：如果当前位置已被占用，则依次检查下一个位置，直到找到空槽。</li><li><strong>二次探测</strong>：在发生冲突时，使用平方函数跳跃到下一个位置。</li><li><strong>双重哈希</strong>：使用第二个哈希函数来确定冲突后的跳跃步长。</li></ul><p><strong>开放地址法的优点</strong>：</p><ul><li>不需要额外的存储空间（不需要链表）。</li><li>查找较为高效，尤其在负载因子较低时。</li></ul><p><strong>缺点</strong>：</p><ul><li>插入、删除操作可能需要较多的查找步骤。</li><li>当负载因子增加时，性能下降较为显著。</li></ul><hr /><h4><a name='header-n3703' class='md-header-anchor '></a>7.4.4 散列表的查找</h4><p>在散列表中查找一个元素的过程：</p><ol start='' ><li><p>使用哈希函数计算目标元素的哈希值，得到对应的槽位。</p></li><li><p>在该槽位检查是否有目标元素。</p><ul><li>如果没有冲突，直接返回该元素。</li><li>如果发生冲突，使用冲突解决方法（链式地址法或开放地址法）继续查找。</li></ul></li></ol><p><strong>时间复杂度</strong>：</p><ul><li>最坏情况下，查找时间复杂度为 O(n)O(n)，即所有元素都映射到同一位置。</li><li>平均情况下，查找时间复杂度为 O(1)O(1)，如果哈希函数和冲突解决方法设计良好。</li></ul><p><strong>C++ 实现</strong>（使用链式地址法处理冲突）：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std;

class HashTable {
public:
    HashTable(int size) : table(size) {}

    // 哈希函数
    int hash(int key) {
        return key % table.size(); // 使用除法法
    }

    // 插入元素
    void insert(int key) {
        int index = hash(key);
        table[index].push_back(key); // 将元素插入到链表中
    }

    // 查找元素
    bool search(int key) {
        int index = hash(key);
        for (int item : table[index]) {
            if (item == key) {
                return true; // 找到元素
            }
        }
        return false; // 没有找到元素
    }

    // 删除元素
    void remove(int key) {
        int index = hash(key);
        table[index].remove(key); // 从链表中删除元素
    }

private:
    vector&lt;list&lt;int&gt;&gt; table; // 使用链表数组作为哈希表
};

int main() {
    HashTable ht(10); // 创建一个大小为 10 的哈希表

    ht.insert(10);
    ht.insert(20);
    ht.insert(30);
    ht.insert(15);

    cout &lt;&lt; "查找 20: " &lt;&lt; (ht.search(20) ? "找到" : "未找到") &lt;&lt; endl;
    cout &lt;&lt; "查找 40: " &lt;&lt; (ht.search(40) ? "找到" : "未找到") &lt;&lt; endl;

    ht.remove(20);
    cout &lt;&lt; "查找 20: " &lt;&lt; (ht.search(20) ? "找到" : "未找到") &lt;&lt; endl;

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">查找 20: 找到
查找 40: 未找到
查找 20: 未找到
</pre><hr /><h3><a name='header-n3736' class='md-header-anchor '></a>总结</h3><p>散列表是一种非常高效的查找数据结构，特别是在需要频繁进行查找操作时。通过良好的哈希函数设计和有效的冲突处理方法，散列表能够在大多数情况下实现 O(1)O(1) 的查找效率。链式地址法和开放地址法是两种常见的处理冲突的方法，适用于不同的应用场景。在实际使用中，选择合适的哈希函数和冲突解决策略对于散列表的性能至关重要。</p><h3><a name='header-n3739' class='md-header-anchor '></a>第 8 章 排序</h3><p>排序是计算机科学中的基本问题之一，其目的是将一个无序的元素集合按照某种顺序排列。排序广泛应用于数据库管理、搜索算法、图形图像处理等各个领域。高效的排序算法不仅能提高程序的性能，还能优化整体系统的响应速度。</p><p>本章主要介绍排序的基本概念、内部排序方法的分类、待排序记录的存储方式，以及如何评价排序算法的效率。</p><hr /><h4><a name='header-n3745' class='md-header-anchor '></a>8.1 基本概念和排序方法概述</h4><p>排序是将一个序列中的元素按照某种特定的顺序（如升序或降序）排列的过程。排序操作有多种方法，选择合适的排序算法对于提高程序的性能至关重要。</p><h5><a name='header-n3748' class='md-header-anchor '></a>8.1.1 排序的基本概念</h5><p>排序的基本目标是将一个无序的记录序列，按照关键字的大小进行排列。排序可以分为两类：</p><ul><li><strong>内部排序</strong>：所有待排序的记录都可以存储在内存中，排序过程完全在内存中进行。</li><li><strong>外部排序</strong>：待排序的记录量大到无法全部放入内存时，排序需要利用外部存储设备（如磁盘）来辅助排序。</li></ul><p>排序的目标是：根据给定的比较规则，将元素按升序或降序排列。排序操作的结果应该使得任何一个元素都比它后面的元素要小（或大，视排序方式而定）。</p><h5><a name='header-n3760' class='md-header-anchor '></a>8.1.2 内部排序方法的分类</h5><p>内部排序方法主要分为以下几类：</p><ol start='' ><li><p><strong>比较排序</strong>：比较排序是通过比较元素之间的大小来决定元素的顺序。这类排序算法的时间复杂度通常是 O(nlog⁡n)O(n \log n) 或更高。常见的比较排序算法包括：</p><ul><li>冒泡排序</li><li>插入排序</li><li>选择排序</li><li>快速排序</li><li>归并排序</li><li>堆排序</li></ul></li><li><p><strong>非比较排序</strong>：非比较排序不通过比较元素大小来排序，而是利用其他方法（如计数、基数等）来实现排序。常见的非比较排序算法包括：</p><ul><li>计数排序</li><li>桶排序</li><li>基数排序</li></ul></li><li><p><strong>稳定排序与不稳定排序</strong>：</p><ul><li><strong>稳定排序</strong>：如果两个元素相等，排序后它们的相对位置不会改变。常见的稳定排序算法有插入排序、归并排序和计数排序。</li><li><strong>不稳定排序</strong>：相等元素的相对位置可能会发生变化。常见的不稳定排序算法有快速排序和选择排序。</li></ul></li></ol><h5><a name='header-n3809' class='md-header-anchor '></a>8.1.3 待排序记录的存储方式</h5><p>排序的效率与待排序数据的存储方式密切相关。常见的存储方式有：</p><ul><li><strong>顺序存储</strong>：将数据存储在连续的内存空间中，适合对数组或链表进行排序。常见的排序算法（如冒泡排序、快速排序）通常使用顺序存储。</li><li><strong>链式存储</strong>：将数据存储在链表等数据结构中，这种存储方式常常用在一些特定的排序算法中（如归并排序中的链表实现）。</li></ul><p>不同的存储方式会对排序算法的实现和效率产生影响。例如，链式存储的排序可能需要额外的指针操作来维护链表的连接，而顺序存储的排序可以直接通过数组下标进行访问。</p><h5><a name='header-n3821' class='md-header-anchor '></a>8.1.4 排序算法效率的评价指标</h5><p>评估排序算法的效率通常使用以下几个指标：</p><ol start='' ><li><p><strong>时间复杂度</strong>：时间复杂度表示算法随着数据规模 nn 增长，所需要的时间增长速度。排序算法的时间复杂度通常分为三种情况：</p><ul><li><strong>最优时间复杂度</strong>：算法在最好情况下的表现。</li><li><strong>最坏时间复杂度</strong>：算法在最坏情况下的表现。</li><li><strong>平均时间复杂度</strong>：算法在平均情况下的表现。</li></ul><p>对于比较排序算法，最好的时间复杂度通常是 O(nlog⁡n)O(n \log n)，最差情况下可能会退化为 O(n2)O(n^2)，如冒泡排序和插入排序。</p></li><li><p><strong>空间复杂度</strong>：空间复杂度表示排序算法所需要的额外空间。对于一些排序算法，如归并排序和快速排序，可能需要额外的存储空间，而其他算法（如冒泡排序、插入排序）则可以在原地排序，空间复杂度为 O(1)O(1)。</p></li><li><p><strong>稳定性</strong>：稳定性是指当两个元素相等时，它们在排序后相对位置是否会发生改变。稳定性在一些应用中非常重要，如在多重排序中，稳定的排序算法可以确保之前排序的顺序保持不变。</p></li><li><p><strong>适应性</strong>：一些排序算法能够在待排序数据本身已接近排序状态时，提供更好的性能。例如，插入排序在数组接近有序时表现出 O(n)O(n) 的时间复杂度。</p></li></ol><hr /><h3><a name='header-n3850' class='md-header-anchor '></a>总结</h3><p>排序算法是计算机科学中的基础技术，选择合适的排序算法能够显著提高程序的效率。在本节中，我们讨论了排序的基本概念、常见的排序方法及其分类、待排序记录的存储方式，以及排序算法效率的评价指标。选择正确的排序算法时，需要根据数据的规模、存储方式、以及应用场景来决定。</p><h3><a name='header-n3853' class='md-header-anchor '></a>8.2 插入排序</h3><p>插入排序是一种简单的排序算法，其工作原理类似于我们整理扑克牌的过程。它将数据分为“已排序部分”和“未排序部分”，每次从未排序部分取出一个元素，插入到已排序部分的合适位置，直到所有元素都有序。</p><p>插入排序有不同的变种，常见的包括<strong>直接插入排序</strong>、<strong>折半插入排序</strong>和<strong>希尔排序</strong>。</p><hr /><h4><a name='header-n3859' class='md-header-anchor '></a>8.2.1 直接插入排序</h4><p><strong>直接插入排序</strong>是插入排序的一种最基本形式，它将未排序的元素逐个与已排序部分进行比较，将其插入到合适的位置。其核心思想是不断将当前元素插入到已经排好序的部分。</p><p><strong>算法步骤</strong>：</p><ol start='' ><li>从第二个元素开始，将其与前面的元素进行比较。</li><li>如果当前元素小于前面的元素，则将前面的元素后移一位，为当前元素腾出位置。</li><li>直到找到合适的位置，将当前元素插入。</li><li>对所有元素重复以上步骤，直到所有元素排序完成。</li></ol><p><strong>时间复杂度</strong>：</p><ul><li>最坏情况下：如果数组是逆序排列，时间复杂度为 O(n2)O(n^2)。</li><li>最好情况下：如果数组已经有序，时间复杂度为 O(n)O(n)。</li><li>平均情况下：时间复杂度为 O(n2)O(n^2)。</li></ul><p><strong>代码实现（C++）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

void insertionSort(int arr[], int n) {
    for (int i = 1; i &lt; n; i++) {
        int key = arr[i];  // 当前元素
        int j = i - 1;

        // 将大于 key 的元素移到一个位置后
        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;  // 将 key 插入到正确位置
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = sizeof(arr) / sizeof(arr[0]);
    insertionSort(arr, n);

    cout &lt;&lt; "排序后的数组: ";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">排序后的数组: 5 6 11 12 13
</pre><hr /><h4><a name='header-n3896' class='md-header-anchor '></a>8.2.2 折半插入排序</h4><p><strong>折半插入排序</strong>是对直接插入排序的一种优化。直接插入排序每次比较时都从数组的头部开始，时间复杂度较高。而折半插入排序通过使用二分查找法找到合适的位置，从而减少比较次数。</p><p><strong>算法步骤</strong>：</p><ol start='' ><li>对每个待插入的元素，使用二分查找在已排序部分找到合适的位置。</li><li>在找到的位置插入元素，并将已排序部分的元素后移。</li></ol><p><strong>时间复杂度</strong>：</p><ul><li>最坏情况下：时间复杂度为 O(n2)O(n^2)，和直接插入排序相同，因为元素的移动次数依然是 O(n)O(n)。</li><li>平均情况下：时间复杂度为 O(n2)O(n^2)。</li><li>但是相比于直接插入排序，折半插入排序在比较的次数上有所减少，提升了效率。</li></ul><p><strong>代码实现（C++）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 使用二分查找找到插入的位置
int binarySearch(int arr[], int key, int low, int high) {
    while (low &lt;= high) {
        int mid = low + (high - low) / 2;
        if (key == arr[mid]) return mid + 1;
        if (key &lt; arr[mid]) high = mid - 1;
        else low = mid + 1;
    }
    return low;
}

void binaryInsertionSort(int arr[], int n) {
    for (int i = 1; i &lt; n; i++) {
        int key = arr[i];
        int low = 0, high = i - 1;

        // 使用二分查找找到插入的位置
        int pos = binarySearch(arr, key, low, high);

        // 将元素后移
        for (int j = i - 1; j &gt;= pos; j--) {
            arr[j + 1] = arr[j];
        }
        arr[pos] = key;  // 插入元素
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = sizeof(arr) / sizeof(arr[0]);
    binaryInsertionSort(arr, n);

    cout &lt;&lt; "排序后的数组: ";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">排序后的数组: 5 6 11 12 13
</pre><hr /><h4><a name='header-n3927' class='md-header-anchor '></a>8.2.3 希尔排序</h4><p><strong>希尔排序</strong>是插入排序的一种优化版本，基本思想是将整个数组分成若干子序列（通过一个步长序列），对每个子序列分别进行插入排序。随着步长逐渐缩小，排序逐渐细化，最终变成直接插入排序。</p><p><strong>算法步骤</strong>：</p><ol start='' ><li>选择一个步长序列（例如：<code>n/2, n/4, ..., 1</code>），将待排序的数组按步长划分为若干子序列。</li><li>对每个子序列执行插入排序，步长逐步减小，直到步长为 1 时，再对整个数组执行一次插入排序。</li></ol><p><strong>时间复杂度</strong>：</p><ul><li>最坏情况下：时间复杂度依赖于步长序列的选择，通常是 O(n3/2)O(n^{3/2})。</li><li>最好情况下：时间复杂度为 O(nlog⁡n)O(n \log n)（取决于步长序列）。</li></ul><p><strong>代码实现（C++）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

void shellSort(int arr[], int n) {
    for (int gap = n / 2; gap &gt; 0; gap /= 2) {
        for (int i = gap; i &lt; n; i++) {
            int key = arr[i];
            int j = i;
            while (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = key;
        }
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = sizeof(arr) / sizeof(arr[0]);
    shellSort(arr, n);

    cout &lt;&lt; "排序后的数组: ";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">排序后的数组: 5 6 11 12 13
</pre><hr /><h3><a name='header-n3955' class='md-header-anchor '></a>总结</h3><ul><li><strong>直接插入排序</strong>：适用于小规模数据，平均时间复杂度为 O(n2)O(n^2)，当数据基本有序时，效率较高。</li><li><strong>折半插入排序</strong>：通过二分查找减少比较次数，但元素移动次数和直接插入排序相同，效率依然较低。</li><li><strong>希尔排序</strong>：通过缩小步长改善了插入排序的性能，适合中等规模的数据。时间复杂度与步长序列密切相关，最优情况下能达到 O(nlog⁡n)O(n \log n)。</li></ul><p>插入排序及其变种是简单而直观的排序算法，适合用于小规模的数据排序，或当数据接近有序时，表现出较高的效率。</p><h3><a name='header-n3968' class='md-header-anchor '></a>8.3 交换排序</h3><p>交换排序是一类通过交换元素位置来实现排序的算法。常见的交换排序算法包括<strong>冒泡排序</strong>和<strong>快速排序</strong>。这些算法通常具有 O(n2)O(n^2) 的时间复杂度，但通过一些优化，快速排序的性能可以大大提升，成为高效的排序方法。</p><hr /><h4><a name='header-n3972' class='md-header-anchor '></a>8.3.1 冒泡排序</h4><p><strong>冒泡排序</strong>是一种简单的排序算法，它通过重复地交换相邻的逆序元素来将较大的元素“冒泡”到数组的末端。算法的核心思想是每次遍历数组，将最大（或最小）的元素放到已排序部分的最后。</p><p><strong>算法步骤</strong>：</p><ol start='' ><li>从数组的第一个元素开始，依次比较相邻的两个元素。</li><li>如果当前元素大于下一个元素，则交换这两个元素的位置。</li><li>每次遍历完成后，最大的元素会被移到数组的末尾。</li><li>重复以上过程，直到整个数组排序完成。</li></ol><p><strong>时间复杂度</strong>：</p><ul><li>最坏情况下：时间复杂度为 O(n2)O(n^2)，当数组逆序时，冒泡排序会进行最多 n−1n-1 次的交换操作。</li><li>最好情况下：时间复杂度为 O(n)O(n)，如果数组已经有序，则只需要进行一次遍历。</li><li>平均情况下：时间复杂度为 O(n2)O(n^2)。</li></ul><p><strong>代码实现（C++）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

void bubbleSort(int arr[], int n) {
    bool swapped;
    for (int i = 0; i &lt; n-1; i++) {
        swapped = false;
        // 从前往后遍历数组
        for (int j = 0; j &lt; n-i-1; j++) {
            // 如果当前元素比下一个元素大，则交换
            if (arr[j] &gt; arr[j+1]) {
                swap(arr[j], arr[j+1]);
                swapped = true;
            }
        }
        // 如果没有发生交换，说明数组已经有序，可以提前结束排序
        if (!swapped) {
            break;
        }
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr)/sizeof(arr[0]);

    bubbleSort(arr, n);

    cout &lt;&lt; "排序后的数组: ";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">排序后的数组: 11 12 22 25 34 64 90
</pre><hr /><h4><a name='header-n4009' class='md-header-anchor '></a>8.3.2 快速排序</h4><p><strong>快速排序</strong>是一种分治算法，它的基本思想是选择一个“基准”元素，然后将比基准元素小的元素放到左边，比基准元素大的元素放到右边。接着，对左右两个子数组分别进行快速排序。这个过程递归地进行，直到所有子数组都排好序。</p><p><strong>算法步骤</strong>：</p><ol start='' ><li>选择一个基准元素（通常选择数组的第一个、最后一个或随机一个元素）。</li><li>将数组重新排列，使得所有比基准小的元素排在基准的左边，所有比基准大的元素排在右边。</li><li>递归地对基准左侧和右侧的子数组进行快速排序。</li></ol><p><strong>时间复杂度</strong>：</p><ul><li>最坏情况下：时间复杂度为 O(n2)O(n^2)，当数组已经是有序或逆序时，分割后的子数组可能不均匀，导致递归深度过大。</li><li>最好情况下：时间复杂度为 O(nlog⁡n)O(n \log n)，当每次划分的子数组都均匀时，递归树的深度为 O(log⁡n)O(\log n)。</li><li>平均情况下：时间复杂度为 O(nlog⁡n)O(n \log n)，对于随机输入，快速排序通常表现出较好的性能。</li></ul><p><strong>代码实现（C++）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 交换两个元素
void swap(int &amp;a, int &amp;b) {
    int temp = a;
    a = b;
    b = temp;
}

// 分割函数，将数组分为两部分，小于基准元素的部分和大于基准元素的部分
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // 选择最后一个元素作为基准
    int i = (low - 1);  // i 是小于基准元素的区域的最后一个元素的索引

    for (int j = low; j &lt; high; j++) {
        // 如果当前元素小于等于基准元素，则将其与小于区域的下一个元素交换
        if (arr[j] &lt;= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    // 将基准元素放到正确的位置
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}

// 快速排序函数
void quickSort(int arr[], int low, int high) {
    if (low &lt; high) {
        // 找到基准元素的正确位置
        int pi = partition(arr, low, high);
        
        // 递归地对基准元素左侧和右侧进行快速排序
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    quickSort(arr, 0, n - 1);

    cout &lt;&lt; "排序后的数组: ";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">排序后的数组: 1 5 7 8 9 10
</pre><hr /><h3><a name='header-n4043' class='md-header-anchor '></a>总结</h3><ul><li><strong>冒泡排序</strong>：是一种简单的交换排序算法，适用于小规模数据排序，最坏情况下时间复杂度为 O(n2)O(n^2)。</li><li><strong>快速排序</strong>：是一种分治排序算法，具有较高的效率，平均时间复杂度为 O(nlog⁡n)O(n \log n)，但在最坏情况下会退化为 O(n2)O(n^2)。快速排序是大多数实际应用中最常用的排序算法之一。</li></ul><p>尽管冒泡排序简单易懂，但其效率较低，主要用于教学和小规模数据排序；而快速排序在大规模数据中表现出优异的性能，是最常用的排序算法之一。</p><h3><a name='header-n4053' class='md-header-anchor '></a>8.4 选择排序</h3><p>选择排序是一种简单的排序算法，它的基本思想是每次从待排序的部分中选择最小（或最大）元素，将其放到已排序部分的末尾。通过不断选择未排序部分的最小值进行交换，最终将整个数组排好序。</p><p>常见的选择排序算法有<strong>简单选择排序</strong>、<strong>树形选择排序</strong>和<strong>堆排序</strong>。</p><hr /><h4><a name='header-n4059' class='md-header-anchor '></a>8.4.1 简单选择排序</h4><p><strong>简单选择排序</strong>是一种直接的排序方法，每一趟都从待排序的部分中找到最小的元素，然后与未排序部分的第一个元素交换，重复此过程，直到数组排序完成。</p><p><strong>算法步骤</strong>：</p><ol start='' ><li>从数组的第一个元素开始，遍历整个数组，找到最小的元素。</li><li>将最小的元素与当前遍历位置的元素交换。</li><li>然后从剩余部分重复以上步骤。</li><li>直到整个数组排好序。</li></ol><p><strong>时间复杂度</strong>：</p><ul><li>最坏情况下：时间复杂度为 O(n2)O(n^2)。</li><li>最好情况下：时间复杂度为 O(n2)O(n^2)，因为每一趟都要进行遍历。</li><li>平均情况下：时间复杂度为 O(n2)O(n^2)，适用于小规模数据。</li></ul><p><strong>代码实现（C++）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

void selectionSort(int arr[], int n) {
    for (int i = 0; i &lt; n - 1; i++) {
        int minIndex = i;  // 假设当前位置的元素是最小的
        for (int j = i + 1; j &lt; n; j++) {
            // 找到当前未排序部分中的最小元素
            if (arr[j] &lt; arr[minIndex]) {
                minIndex = j;
            }
        }
        // 如果最小元素不是当前位置的元素，进行交换
        if (minIndex != i) {
            swap(arr[i], arr[minIndex]);
        }
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    selectionSort(arr, n);

    cout &lt;&lt; "排序后的数组: ";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">排序后的数组: 11 12 22 25 34 64 90
</pre><hr /><h4><a name='header-n4096' class='md-header-anchor '></a>8.4.2 树形选择排序</h4><p><strong>树形选择排序</strong>是一种通过构建完全二叉树来优化选择排序的算法。在树形选择排序中，首先将所有元素构建成一颗完全二叉树，然后依次从树的根节点选择最小（或最大）元素进行交换。其思想类似于选择排序，但它使用树形结构来进行选择操作，减少了元素的比较次数。</p><p><strong>算法步骤</strong>：</p><ol start='' ><li>构建一颗完全二叉树，将待排序的元素插入到树的叶子节点。</li><li>将树从最后一个非叶子节点开始，进行堆化操作，使其满足堆的性质。</li><li>将堆的根节点与最后一个节点交换，并重新堆化，重复此过程，直到堆为空。</li></ol><p><strong>时间复杂度</strong>：</p><ul><li>最坏情况下：时间复杂度为 O(nlog⁡n)O(n \log n)，因为每次堆化操作的时间复杂度为 O(log⁡n)O(\log n)。</li><li>最好情况下：时间复杂度为 O(nlog⁡n)O(n \log n)。</li><li>平均情况下：时间复杂度为 O(nlog⁡n)O(n \log n)，比简单选择排序要高效。</li></ul><p><strong>代码实现（C++）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 堆化操作
void heapify(int arr[], int n, int i) {
    int largest = i;  // 假设根节点是最大值
    int left = 2 * i + 1;  // 左子节点
    int right = 2 * i + 2;  // 右子节点

    // 如果左子节点更大
    if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
    }

    // 如果右子节点更大
    if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
    }

    // 如果根节点不是最大值，交换并递归堆化
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

// 树形选择排序（堆排序）
void heapSort(int arr[], int n) {
    // 建立最大堆
    for (int i = n / 2 - 1; i &gt;= 0; i--) {
        heapify(arr, n, i);
    }

    // 逐步从堆中取出元素
    for (int i = n - 1; i &gt; 0; i--) {
        // 将堆顶元素与堆的最后一个元素交换
        swap(arr[0], arr[i]);

        // 重新堆化
        heapify(arr, i, 0);
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = sizeof(arr) / sizeof(arr[0]);

    heapSort(arr, n);

    cout &lt;&lt; "排序后的数组: ";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">排序后的数组: 5 6 7 11 12 13
</pre><hr /><h4><a name='header-n4130' class='md-header-anchor '></a>8.4.3 堆排序</h4><p><strong>堆排序</strong>是一种树形选择排序，基于完全二叉树的性质。堆排序首先将待排序数组构建成一个大根堆（或小根堆），然后将堆顶元素（最大或最小）与最后一个元素交换，并进行堆化操作，逐步缩小堆的范围，直到排序完成。</p><p>堆排序利用了<strong>堆</strong>这一数据结构，确保了每个父节点都大于（或小于）其子节点，从而可以在 O(log⁡n)O(\log n) 的时间内进行堆化。</p><p><strong>算法步骤</strong>：</p><ol start='' ><li>将数组构建为一个大根堆（对于升序排序），即每个节点都大于或等于其子节点。</li><li>将堆顶元素（最大元素）与堆的最后一个元素交换，将最大元素放到正确的位置。</li><li>对剩下的 n−1n-1 个元素进行堆化操作，保持堆的性质。</li><li>重复以上过程，直到整个数组排序完成。</li></ol><p><strong>时间复杂度</strong>：</p><ul><li>最坏情况下：时间复杂度为 O(nlog⁡n)O(n \log n)。</li><li>最好情况下：时间复杂度为 O(nlog⁡n)O(n \log n)。</li><li>平均情况下：时间复杂度为 O(nlog⁡n)O(n \log n)。</li></ul><p><strong>代码实现（C++）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 堆化操作
void heapify(int arr[], int n, int i) {
    int largest = i;  // 假设根节点是最大值
    int left = 2 * i + 1;  // 左子节点
    int right = 2 * i + 2;  // 右子节点

    // 如果左子节点更大
    if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
    }

    // 如果右子节点更大
    if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
    }

    // 如果根节点不是最大值，交换并递归堆化
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

// 堆排序
void heapSort(int arr[], int n) {
    // 建立最大堆
    for (int i = n / 2 - 1; i &gt;= 0; i--) {
        heapify(arr, n, i);
    }

    // 逐步从堆中取出元素
    for (int i = n - 1; i &gt; 0; i--) {
        // 将堆顶元素与堆的最后一个元素交换
        swap(arr[0], arr[i]);

        // 重新堆化
        heapify(arr, i, 0);
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = sizeof(arr) / sizeof(arr[0]);

    heapSort(arr, n);

    cout &lt;&lt; "排序后的数组: ";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
</pre><p><strong>输出</strong></p><p>：</p><pre class="md-fences mock-cm md-end-block" lang="">排序后的数组: 5 6 7 11 12 13
</pre><hr /><h3><a name='header-n4171' class='md-header-anchor '></a>总结</h3><ul><li><strong>简单选择排序</strong>：每次选择最小元素进行交换，时间复杂度为 O(n2)O(n^2)，适用于小规模数据排序。</li><li><strong>树形选择排序</strong>：通过构建堆来优化选择排序，时间复杂度为 O(nlog⁡n)O(n \log n)。</li><li><strong>堆排序</strong>：基于堆的选择排序算法，时间复杂度为 O(nlog⁡n)O(n \log n)，是一种效率较高的排序方法，适用于大规模数据排序。</li></ul><p>堆排序在时间效率上较为优秀，且具有 O(nlog⁡n)O(n \log n) 的最坏时间复杂度，但需要额外的空间来存储堆。</p><h3><a name='header-n4184' class='md-header-anchor '></a>8.5 归并排序</h3><p><strong>归并排序（Merge Sort）</strong>是一种典型的分治法（Divide and Conquer）排序算法。它将一个大的问题分解为多个小的子问题，并递归地解决每个子问题，最后将解决方案合并。</p><p><strong>基本思想</strong>：</p><ol start='' ><li>将待排序的数组分成两半，递归地对两半分别进行排序。</li><li>合并两个已排序的子数组，得到最终的排序数组。</li></ol><p>归并排序的关键在于<strong>合并操作</strong>，即将两个已排序的部分合并成一个有序数组。</p><p><strong>时间复杂度</strong>：</p><ul><li>最坏、最好和平均情况下的时间复杂度均为 O(nlog⁡n)O(n \log n)。</li><li>空间复杂度为 O(n)O(n)，因为归并排序需要额外的空间来存储合并过程中的数组。</li></ul><p><strong>代码实现（C++）</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
using namespace std;

// 合并两个子数组
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    int L[n1], R[n2];
    
    // 将数据拷贝到临时数组 L[] 和 R[]
    for (int i = 0; i &lt; n1; i++) {
        L[i] = arr[left + i];
    }
    for (int i = 0; i &lt; n2; i++) {
        R[i] = arr[mid + 1 + i];
    }
    
    int i = 0, j = 0, k = left;
    
    // 合并两个子数组
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    
    // 将 L[] 中剩余的元素拷贝到 arr[]
    while (i &lt; n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    
    // 将 R[] 中剩余的元素拷贝到 arr[]
    while (j &lt; n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// 归并排序的递归实现
void mergeSort(int arr[], int left, int right) {
    if (left &lt; right) {
        int mid = left + (right - left) / 2;
        
        mergeSort(arr, left, mid);  // 排序左半部分
        mergeSort(arr, mid + 1, right);  // 排序右半部分
        
        merge(arr, left, mid, right);  // 合并两个已排序的子数组
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    mergeSort(arr, 0, n - 1);
    
    cout &lt;&lt; "排序后的数组: ";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    
    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">排序后的数组: 5 6 7 11 12 13
</pre><p><strong>归并排序的优点</strong>：</p><ul><li><strong>稳定性</strong>：归并排序是稳定排序，它不会改变相等元素的顺序。</li><li><strong>时间复杂度</strong>：最坏、最好和平均时间复杂度都为 O(nlog⁡n)O(n \log n)，相对其他排序算法，性能稳定。</li><li><strong>适合大数据</strong>：因为其稳定的 O(nlog⁡n)O(n \log n) 时间复杂度，它适合于排序大数据。</li></ul><hr /><h3><a name='header-n4226' class='md-header-anchor '></a>8.6 基数排序</h3><p><strong>基数排序（Radix Sort）</strong>是一种非比较型的整数排序算法，它通过将数值按位数拆分进行排序，从低位到高位逐步排序，最终得到一个有序的数组。</p><p>基数排序利用了整数的每一位（从低位到高位）进行排序，并在每一位的排序中使用稳定的排序算法（通常是计数排序）。它的效率非常高，但只适用于整数或者能够转化为整数的场合。</p><p><strong>基本思想</strong>：</p><ol start='' ><li>从最低位开始，对所有数进行一次排序。</li><li>然后按次序逐步处理更高的位，直到最高位。</li><li>每次排序使用的是稳定排序（如计数排序），确保相同数字的位置不会改变。</li></ol><p><strong>时间复杂度</strong>：</p><ul><li>如果有 nn 个数字，每个数字的位数为 dd，则时间复杂度为 O(n⋅d)O(n \cdot d)。</li><li>对于固定范围内的整数，基数排序是非常高效的。</li></ul><h4><a name='header-n4252' class='md-header-anchor '></a>8.6.1 多关键字的排序</h4><p>多关键字排序是指当一个对象由多个属性组成时，按照多个属性进行排序。基数排序可以作为多关键字排序的基础，通过对每个关键字进行逐位排序，最终得到多关键字排序结果。</p><p><strong>时间复杂度</strong>：与基数排序相同，时间复杂度为 O(n⋅d)O(n \cdot d)，其中 nn 是数据项的个数，dd 是关键字的位数。</p><h4><a name='header-n4257' class='md-header-anchor '></a>8.6.2 链式基数排序</h4><p><strong>链式基数排序</strong>是在基数排序中使用<strong>链表</strong>作为桶的存储结构。在每一轮的排序中，数字根据当前位数的值被分配到不同的桶中。链式基数排序使用链表来存储桶中的元素，从而避免了元素的冲突。</p><p><strong>算法步骤</strong>：</p><ol start='' ><li>为每个可能的位数（从0到9）创建一个链表桶。</li><li>根据每个数字当前位的值，将数字插入到相应的链表桶中。</li><li>从链表桶中按顺序取出元素，重新组成数组，进行下一轮排序。</li></ol><p><strong>时间复杂度</strong>：和传统基数排序类似，时间复杂度为 O(n⋅d)O(n \cdot d)。</p><hr /><h3><a name='header-n4275' class='md-header-anchor '></a>总结</h3><ul><li><strong>归并排序</strong>：基于分治法，通过将数组递归地分割并合并，具有稳定的 O(nlog⁡n)O(n \log n) 时间复杂度，适用于大规模数据排序。</li><li><strong>基数排序</strong>：适用于整数排序，通过逐位排序来实现，时间复杂度为 O(n⋅d)O(n \cdot d)，适合大量数据且数字位数较少的情况。</li></ul><h3><a name='header-n4283' class='md-header-anchor '></a>8.7 外部排序</h3><p>外部排序（External Sorting）是当待排序的数据量大到不能完全放入内存时，采用的一种排序方法。由于数据量超出了内存容量，外部排序算法需要使用外部存储（如磁盘）来辅助完成排序。外部排序的基本目标是减少磁盘 I/O 操作，充分利用内存。</p><p>外部排序的核心思想是将大文件分割成小块，分别对每个小块进行排序，然后通过某种合并方式将这些排序好的小块合并成一个完整的排序文件。常见的外部排序算法包括多路归并和置换-选择排序。</p><h4><a name='header-n4288' class='md-header-anchor '></a>8.7.1 外部排序的基本方法</h4><p>外部排序的基本方法通常包括以下几个步骤：</p><ol start='' ><li><strong>分割</strong>：将大文件分成多个小块，并将每一块加载到内存中。</li><li><strong>排序</strong>：对每一块进行内存排序，常用的排序算法有快速排序、归并排序等。</li><li><strong>归并</strong>：使用多路归并算法将所有已排序的小块合并成一个大的排序文件。</li></ol><p><strong>核心挑战</strong>：外部排序的主要挑战在于磁盘 I/O 操作的效率，因为磁盘访问远比内存访问要慢得多。因此，外部排序需要尽量减少磁盘 I/O 的次数。</p><p><strong>常用的外部排序技术</strong>：</p><ul><li><strong>多路归并（K-way Merge）</strong>：通过优先队列（最小堆）等数据结构，实现对多个有序文件的合并。</li><li><strong>置换-选择排序</strong>：一种逐步从磁盘读取数据，并逐步将最小（或最大）值放到内存中排序的算法。</li></ul><hr /><h4><a name='header-n4313' class='md-header-anchor '></a>8.7.2 多路平衡归并的实现</h4><p><strong>多路平衡归并</strong>（K-way Merge）是一种外部排序算法，广泛应用于大数据处理。其基本思想是利用最小堆来实现多个已排序文件的合并。</p><p><strong>算法步骤</strong>：</p><ol start='' ><li><strong>初始化</strong>：将每个已排序文件的第一个元素放入最小堆中，堆的大小为文件数目。</li><li><strong>归并过程</strong>：每次从堆中取出最小的元素，将该元素写入最终的排序文件，并从相应的输入文件中读取下一个元素，放入堆中。</li><li><strong>重复</strong>：继续从堆中取出最小元素，直到所有文件都归并完毕。</li></ol><p><strong>代码实现</strong>（C++）：</p><pre class="md-fences mock-cm md-end-block" lang="" style="break-inside: unset;">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

using namespace std;

// 用来比较的结构体
struct Element {
    int value;  // 元素的值
    int fileIndex;  // 元素所在的文件编号
    int indexInFile;  // 元素在文件中的位置
    
    // 用于优先队列的比较函数，确保最小元素优先
    bool operator&gt;(const Element&amp; other) const {
        return value &gt; other.value;
    }
};

// 外部归并的多路平衡归并实现
void kWayMerge(vector&lt;vector&lt;int&gt;&gt;&amp; sortedFiles) {
    priority_queue&lt;Element, vector&lt;Element&gt;, greater&lt;Element&gt;&gt; minHeap;
    vector&lt;int&gt; indices(sortedFiles.size(), 0);  // 各个文件的当前索引

    // 初始化堆
    for (int i = 0; i &lt; sortedFiles.size(); i++) {
        if (sortedFiles[i].size() &gt; 0) {
            minHeap.push({sortedFiles[i][0], i, 0});
        }
    }

    // 执行归并过程
    while (!minHeap.empty()) {
        Element current = minHeap.top();
        minHeap.pop();

        // 输出最小元素（实际应用中是写入磁盘）
        cout &lt;&lt; current.value &lt;&lt; " ";

        // 如果当前文件还有更多元素，则将下一个元素加入堆
        if (current.indexInFile + 1 &lt; sortedFiles[current.fileIndex].size()) {
            int nextValue = sortedFiles[current.fileIndex][current.indexInFile + 1];
            minHeap.push({nextValue, current.fileIndex, current.indexInFile + 1});
        }
    }
    cout &lt;&lt; endl;
}

int main() {
    vector&lt;vector&lt;int&gt;&gt; sortedFiles = {
        {1, 5, 9},   // 文件1
        {2, 6, 10},  // 文件2
        {3, 7, 11},  // 文件3
        {4, 8, 12}   // 文件4
    };
    
    kWayMerge(sortedFiles);  // 调用多路归并函数
    
    return 0;
}
</pre><p><strong>输出</strong>：</p><pre class="md-fences mock-cm md-end-block" lang="">1 2 3 4 5 6 7 8 9 10 11 12 
</pre><p><strong>解释</strong>：</p><ul><li>程序首先将每个文件的首元素放入优先队列（最小堆）。</li><li>然后通过不断从堆中取出最小的元素，合并所有文件，直到所有文件的元素都被处理完。</li></ul><hr /><h4><a name='header-n4344' class='md-header-anchor '></a>8.7.3 置换-选择排序</h4><p><strong>置换-选择排序</strong>（Replacement Selection Sort）是外部排序的另一种常见方法，特别适用于对大量数据的排序。</p><p><strong>算法步骤</strong>：</p><ol start='' ><li><strong>分配内存</strong>：首先将大文件的部分数据加载到内存中。</li><li><strong>选择排序</strong>：对内存中的数据进行排序，选取最小或最大的元素进行替换。每次选取一个元素，放入已排序的部分，同时从磁盘读取下一个元素来填补内存中的空位。</li><li><strong>替换</strong>：通过替换选择排序中最小的或最大的元素，逐步将数据排序。</li></ol><p><strong>特点</strong>：</p><ul><li>每次读取的数据量是固定的，不会超过内存的大小。</li><li>不需要外部归并的操作，但每次替换时需要适当的缓存和处理。</li></ul><hr /><h4><a name='header-n4369' class='md-header-anchor '></a>8.7.4 最佳归并树</h4><p><strong>最佳归并树</strong>（Optimal Merge Tree）是一种用于外部排序的优化方法，旨在优化多路归并的归并过程。它通过构建一棵最优的二叉树来决定归并的顺序。</p><p><strong>构建步骤</strong>：</p><ol start='' ><li>将所有的文件视为叶节点，构建一棵最优的二叉树。</li><li>每次选择合并代价最小的两颗子树进行归并，直到只剩下根节点。</li></ol><p><strong>最优归并树的目标</strong>：减少磁盘 I/O 操作次数。通过选择合并最小的子树，能够降低总的归并成本。</p><hr /><h3><a name='header-n4384' class='md-header-anchor '></a>总结</h3><ul><li><strong>外部排序</strong>：解决了无法将所有数据加载到内存中的问题，常用方法包括多路归并和置换-选择排序。</li><li><strong>多路平衡归并</strong>：通过最小堆实现多个已排序文件的合并，时间复杂度为 O(nlog⁡k)O(n \log k)，其中 nn 是总数据量，kk 是文件数量。</li><li><strong>置换-选择排序</strong>：利用选择排序逐步填补内存，适用于外部排序中的数据替换操作。</li><li><strong>最佳归并树</strong>：优化归并过程，减少磁盘 I/O 操作，通过构建最优的合并树来提高效率。</li></ul><p>外部排序的核心在于减少磁盘 I/O 操作，通过合理地设计算法和存储结构，可以显著提高大数据量排序的效率。</p></div>
</body>
</html>